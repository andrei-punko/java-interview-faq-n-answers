<!--According to https://getbootstrap.com/docs/5.0/getting-started/introduction/-->
<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

    <title>Java interview Q&A</title>
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()"/>
</head>
<body>

<div class="container">
    <p align="justify">
        <a href="index.html">Main</a>&nbsp;
        <a href="answers-1.html">Ответы</a>&nbsp;
    </p>
<p align="justify">
<h1>Java interview questions and answers</h1><hr/>
</p>
<p align="justify">
<b>Какой контракт между equals() и hashCode()?</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Расскажи про stack и heap?</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Расскажи про Young Generation, Old Generation, PermGen</b><br/>
Young/Old generation - это области heap-а<br/>
PermGen (permanent generation) – в этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Не считается частью кучи.<br/>
</p>
<p align="justify">
<b>У объекта есть адрес памяти. И это память скорее всего ограничена каким-то размером. Какую проблему ты видишь для hashCode() который определен как адрес памяти? В </b><br/>
Старой java было реализовано по адресу памяти, в новой Java работает не так. <br/>
<a href="https://habr.com/ru/company/vk/blog/321306/">https://habr.com/ru/company/vk/blog/321306/</a><br/>
Реализация по умолчанию hashCode() (идентификационного хеша) не имеет отношения к адресу памяти объекта, как минимум в OpenJDK.<br/>
В HotSpot идентификационный хеш генерируется лишь раз, а затем кешируется в слове mark в заголовке объекта. Т.е. перемещения объекта после сборок мусора в памяти НЕ вызывают смену значения хэшкода.<br/>
</p>
<p align="justify">
<b>Если объект создался в Young Generation, объекты могут перемещаться и менять свой адрес или нет?</b><br/>
В какой-то момент объект перейдет из Young Generation в Old и если мы на основе адресов памяти вычисляли хэшкод, он измениться или нет? Если изменится, с этим могут быть какие-то проблемы? Что надо сделать с объектом чтобы его вычисленный хэшкод не изменялся?<br/>
См. ответ к вопросу 4.<br/>
</p>
<p align="justify">
<b>Есть класс Person с полями id и name. Эти поля должны обладать какими-то свойствами для вычисления хэшкода? Если поля будут неиммутабельными с этим могут быть проблемы? Если мы не можем гарантировать, что исходные данные immutable? </b><br/>
Для вычисления хэшкода поля должны быть иммутабельными.<br/>
Если поля будут неиммутабельными - при помещении объекта в хэшированную коллекцию его потом можно не найти.<br/>
Если не можем гарантировать иммутабельность всех полей - возможно стоит вычислять хэш только по полю id.<br/>
</p>
<p align="justify">
<b>Мы можем сохранять значение хэшкода когда его вычислили?</b><br/>
Если объект immutable, то значение хэшкода не изменится, поэтому может использовать его (например как ключ в мэпе)<br/>
Если объект не-immutable, то при изменении одного из полей хэшкод может измениться<br/>
Если вопрос был о некоем "кэшировании" вычисленного значения хэшкода - то делать этого не надо, т.к. вычисление хэшкода предполагается выполняющимся быстро и ничего не стоит вычислить его при необходимости еще раз "здесь и сейчас"<br/>
</p>
<p align="justify">
<b>Какой тип возвращает метод hashCode()? Какую размерность имеет int? Почему нельзя использовать long? (ответ: хэшкоды кешируются в хедере класса Object)</b><br/>
Int, длиной 4 байта<br/>
Я бы так ответил: потому что такой контракт метода hashCode - возвращать значение типа int<br/>
?<br/>
</p>
<p align="justify">
<b>Какие базовые реализации коллекций ты знаешь? Расскажи про интерфейсы коллекций.</b><br/>
<a href="https://habr.com/ru/post/237043/">https://habr.com/ru/post/237043/</a><br/>
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: <br/>
= простые последовательные наборы элементов Collection и <br/>
= наборы пар «ключ — значение» (словари) Map<br/>
От Collection наследуются интерфейсы Set, List, Queue.<br/>
</p>
<p align="justify">
Реализации коллекций:<br/>
= Интерфейс List:<br/>
	== ArrayList. Динамический массив объектов. Позволяет использовать null в качестве элемента,<br/>
	== LinkedList. Двунаправленный связный список. Позволяет использовать null в качестве элемента,<br/>
	== Vector. Динамический массив объектов, позволяет использовать null в качестве элемента. Синхронизирован. Не рекомендуется использовать, если не требуется достижения потокобезопасности.<br/>
	== Stack. Является расширением коллекции Vector. Частично синхронизирована (все операции, кроме push). Не рекомендуется использовать, лучше ArrayDeque.<br/>
= Интерфейс Set:<br/>
	== HashSet. Базируется на HashMap, при добавлении в качестве ключа используется добавляемый элемент, а в качестве значения - объект-пустышка (new Object()). Из-за особенностей реализации - порядок элементов при обходе не гарантируется,<br/>
	== LinkedHashSet. Базируется на LinkedHashMap, благодаря этому порядок элементов при обходе является идентичным порядку элементов при добавлении,<br/>
	== TreeSet. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".<br/>
= Интерфейс Map:<br/>
	== Hashtable. Не рекомендуется использовать, лучше взять HashMap или ConcurrentHashMap. Не позволяет использовать null в качестве значения или ключа,<br/>
	== HashMap. Не синхронизирована и позволяет использовать null как в качестве ключа, так и значения,<br/>
	== LinkedHashMap. В отличии от HashMap, порядок итерирования равен порядку добавления элементов,<br/>
	== TreeMap. Реализация Map, основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании.<br/>
= Интерфейс Queue:<br/>
	== PriorityQueue. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.<br/>
	== ArrayDeque. Представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null. Рекомендуется использовать вместо Stack.<br/>
</p>
<p align="justify">
<b>Чем List отличается от Set?</b><br/>
Список - доступ по индексу, возможны дубликаты<br/>
Множество - содержит только уникальные элементы<br/>
</p>
<p align="justify">
<b>Какие нововведения появились в Java 8?</b><br/>
</p>
<p align="justify">
<b>Что стало возможно использовать в интерфейсах, начиная с Java 8?</b><br/>
</p>
<p align="justify">
<b>Чем начиная с Java 8 отличаются абстрактные классы и интерфейсы? </b><br/>
?<br/>
</p>
<p align="justify">
<b>Как инстанцировать экземпляр интерфейса?</b><br/>
= создать анонимный класс, определив имплементацию нужных методов in-place<br/>
= создать динамический прокси, передав ему интерфейс в качестве параметра<br/>
</p>
<p align="justify">
<b>В каком варианте массив будет успешно отсортирован?</b><br/>
<pre>
List&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of("B", "C", "A"));
Collections.sort(list1);

List&lt;String&gt; list2 = Arrays.asList("B", "C", "A");
Collections.sort(list2);

List&lt;String&gt; list3 = List.of("B", "C", "A");
Collections.sort(list3);
</pre>
Решение:<br/>
С первой коллекцией все хорошо - сортировка выполнится<br/>
Arrays.asList() возвращает другой ArrayList – fixed sized list, сортировка выполнится<br/>
А вот List.of() - возвращает ImmutableList, поэтому Collections.sort(list3) упадет с UnsupportedOperationException<br/>
</p>
<p align="justify">
<b>Удали дубликаты: String strings[] = {"u", "z", "c", "a", "a", "b"}</b><br/>
Решение 1: Arrays.stream(strings).distinct().collect(Collectors.toSet())<br/>
Решение 2: new LinkedHashSet<>(Arrays.asList(strings))<br/>
</p>
<p align="justify">
<b>Преобразовать:</b><br/>
<pre>
List&lt;List&lt;String&gt;&gt; lists ---&gt; List&lt;String&gt; list
</pre>
Решение:<br/>
<pre>
lists.stream().flatMap(Collection::stream).collect(Collectors.toList())
</pre>
</p>
<p align="justify">
<b>Что будет напечатано в консоль?</b><br/>
<pre>
Stream.of("d2", "a2", "b1", "b3", "c")
        .map(s -&gt; {
            System.out.println("map: " + s);
            return s.toUpperCase();
        })
        .anyMatch(s -&gt; {
            System.out.println("anyMatch: " + s);
            return s.startsWith("A");
        });
</pre>
Метод anyMatch() будет применяться только до того момента, пока return не вернет true, поэтому будут напечатаны только строки для первых двух айтемов из списка:<br/>
Map: d2<br/>
AnyMatch: D2<br/>
Map: a2<br/>
AnyMatch: A2<br/>
</p>
<p align="justify">
<b>С каким GC работал больше всего?</b><br/>
Видимо G1, потому что он по умолчанию в последних Java<br/>
</p>
<p align="justify">
<b>Создается новый объект. Есть вероятность того, что он будет создан сразу в Old Generation?</b><br/>
Если размер объекта превышает определенную величину, JVM считает, что он очень большой, и сразу помещает объект его в Old Generation часть кучи.<br/>
</p>
<p align="justify">
<b>Что такое OutOfMemoryException и когда он случается? Типы OutOfMemoryException?</b><br/>
Когда нет памяти в heap и когда невозможно создать нативный Thread<br/>
</p>
<p align="justify">
<b>Что делает Java машина перед тем, как выкинуть OOM?</b><br/>
GC попробует сделать сборку мусора<br/>
</p>
<p align="justify">
<b>Как GC определяет, что какой-то объект не используется? </b><br/>
В ходе сборки мусора обнаруживает, что на него нет ссылок от других объектов<br/>
</p>
<p align="justify">
<b>Что такое жесткие ссылки? Откуда они?</b><br/>
?<br/>
</p>
<p align="justify">
<b>Что такое GC Root?</b><br/>
<a href="https://stackoverflow.com/questions/27186799/what-are-gc-roots-for-classes">https://stackoverflow.com/questions/27186799/what-are-gc-roots-for-classes</a><br/>
A garbage collection root is an object that is accessible from outside the heap.<br/>
Memory Analyzer categorizes garbage collection roots according to the following list:<br/>
= Class loaded by system ClassLoader<br/>
    static field in JDK classes(java.* etc)<br/>
= Live thread<br/>
    stack - local variables, method params<br/>
    java.lang.Thread instance<br/>
= Object held as synchronization monitor<br/>
= JNI references<br/>
= JVM specials...<br/>
</p>
<p align="justify">
<b>Что такое ThreadLocal поля?</b><br/>
Синглтон в рамках отдельного треда<br/>
</p>
<p align="justify">
<b>Что можешь сказать об этом коде:</b><br/>
<pre>
List&lt;Integer&gt; results = integers.stream()
        .map(integer -&gt; CompletableFuture.supplyAsync(() -&gt; process(integer), executor))
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
</pre>
</p>
<p align="justify">
Подсказки от интервьюера: как можно исключить последовательный запуск и ожидание каждого потока? (ответ: разорвать stream, собрать CompletableFuture в List и заджойнить не на intах, потому что они будут конвейерно джойнится по одной, а надо собрать List<CompletableFuture> и заджойнить и тогда они выполнятся параллельно)<br/>
</p>
<p align="justify">
<b>Логгировал ли в проекте что-нибудь? Когда логгер что-то логгирует, откуда он берет все данные? Где они все хранятся?</b><br/>
?<br/>
</p>
<p align="justify">
<b>Слышал когда-нибудь про MDC?</b><br/>
<a href="https://www.baeldung.com/mdc-in-log4j-2-logback">https://www.baeldung.com/mdc-in-log4j-2-logback</a><br/>
MDC (Mapped Diagnostic Context) provides a way to enrich log messages with information that could be unavailable in the scope where the logging actually occurs but that can be indeed useful to better track the execution of the program.<br/>
MDC allows us to fill a map-like structure with pieces of information that are accessible to the appender when the log message is actually written.<br/>
MDC implementations typically use ThreadLocals to store the contextual information. That's an easy and reasonable way to achieve thread-safety.<br/>
Here's the high-level idea:<br/>
= Fill the MDC with pieces of information that we want to make available to the appender<br/>
= Then log a message<br/>
= And finally clear the MDC<br/>
It is enough to change the conversion pattern, using the %X{} placeholder for each entry contained in the MDC we want to be logged:<br/>
<pre>
log4j.appender.consoleAppender.layout.ConversionPattern=
  %-4r [%t] %5p %c{1} %x - %m - tx.id=%X{transaction.id} tx.owner=%X{transaction.owner}%n
</pre>
Always remember to clean up the MDC context at the end of each execution. Another approach is to use ThreadPoolExecutor hooks and perform necessary cleanups after each execution. <br/>
</p>
<p align="justify">
<b>Что такое Spring и какие проблемы он решает? </b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Какие есть стереотипные аннотации в Spring?</b><br/>
@Component, @Repository, @Service и @Controller<br/>
</p>
<p align="justify">
<b>Чем отличается @Controller от @RestController?</b><br/>
@RestController - это сочетание аннотации @Controller и @ResponseBody<br/>
Controller – это класс, который отвечает за подготовку модели с данными, отображаемыми представлением, а также за выбор правильного представления.<br/>
</p>
<p align="justify">
<b>Чем отличается @Service от @Component?</b><br/>
В данный момент это одно и то же, но рекомендуется помечать аннотацией @Service именно классы, выполняющие сервисные функции<br/>
</p>
<p align="justify">
<b>Чем отличается @Component от @Repository?</b><br/>
Для @Repository выполняется дополнительная трансляция исключений из persistence layer<br/>
</p>
<p align="justify">
<b>Чем отличается scope prototype если смотреть в разрезе жизненного цикла бина?</b><br/>
<a href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s04.html">https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s04.html</a><br/>
There is one quite important thing to be aware of when deploying a bean in the prototype scope, in that the lifecycle of the bean changes slightly. Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, decorates and otherwise assembles a prototype object, hands it to the client and then has no further knowledge of that prototype instance. This means that while initialization lifecycle callback methods will be called on all objects regardless of scope, in the case of prototypes, _any configured destruction lifecycle callbacks will not be called_. It is the responsibility of the client code to clean up prototype scoped objects and release any expensive resources that the prototype bean(s) are holding onto. (One possible way to get the Spring container to release resources used by prototype-scoped beans is through the use of a custom bean post-processor which would hold a reference to the beans that need to be cleaned up)<br/>
In some respects, you can think of the Spring containers role when talking about a prototype-scoped bean as somewhat of a replacement for the Java 'new' operator. All lifecycle aspects past that point have to be handled by the client.<br/>
</p>
<p align="justify">
<b>Где хранится singleton бин?</b><br/>
Доступ к нему можно получить из bean registry<br/>
</p>
<p align="justify">
<b>Расскажи про жизненный цикл бина</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Ты на код-ревью. Что не нравится? Что бы сделал иначе? Что вызывает подозрение? Как сделать self-injection? Что нужно дописать для этого?</b><br/>
<pre>
@Component
@RequiredArgsConstructor
public class CachedPhotosService {
    private static final String RESIZED_PHOTO_CACHE_NAME = "RESIZED_PHOTO_CACHE_NAME";

	private final PhotoRepository photoRepository;
    private final PhotoValidationService photoValidationService;
    private final PhotoOperations photoOperations;

    @Cacheable(cacheNames = RESIZED_PHOTO_CACHE_NAME)
    public PhotoDTO resizedPhoto(String photoId, int width, int height) {
        photoValidationService.validateSize(width, height);

        Photo photo = photoRepository.findById(photoId);

        PhotoDTO photoDto = ConversionUtils.convert(photo);
        var resizedPhoto = photoOperations.resize(photoDto, width, height);

        return resizedPhoto;
    }

    public PhotoDTO iconifiedPhoto(String photoId) {
        return resizedPhoto(photoId, 100, 100);
    }
}
</pre>
= захардкоданы размеры в iconifiedPhoto(), вынес бы в константы<br/>
= надо добавить @Transactional(readOnly=true) на resizedPhoto()<br/>
= валидацию параметров width и height можно выполнять слоем выше, при помощи валидационных аннотаций<br/>
= ConversionUtils.convert() переделал бы: вместо статического метода сделать Спринг-компонент<br/>
= @Cacheable видимо не будет работать при вызовах iconifiedPhoto, для этого можно сделать self-injection: надо дописать getter для this и вызывать на нем resizedPhoto() из iconifiedPhoto()<br/>
</p>
<p align="justify">
<b>Расскажи какие тесты писал? </b><br/>
Юнит-тесты<br/>
Интеграционные<br/>
Функциональные<br/>
Перфоманс тесты<br/>
</p>
<p align="justify">
<b>Читал про Spring Test? @SpringBootTest, как написать, чтобы поднять только 1 bean? </b><br/>
<a href="https://stackoverflow.com/questions/51051994/spring-context-test-with-just-one-bean">https://stackoverflow.com/questions/51051994/spring-context-test-with-just-one-bean</a><br/>
Нужно аннотировать тест аннотацией, где указать в конфигурации только этот 1 бин:<br/>
<pre>
@RunWith(SpringRunner.class)
@SpringBootTest(properties = "spring.profiles.active=test")
@ContextConfiguration(classes = MyTestBean.class)
</pre>
В данной статье также указывается на необычность такого подхода: "It is in fact a valid way to achieve that goal; however, it is also a bit unusual to load an ApplicationContext that contains a single user bean"<br/>
</p>
<p align="justify">
<b>С какими NoSQL базами данных работал?</b><br/>
Redis, Amazon ElastiCache, Tarantool<br/>
</p>
<p align="justify">
<b>Зачем использовать NoSQL БД?</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>За счёт чего удается добиваться NoSQL БД большей производительности и масштабируемости?</b><br/>
Большей производительности добиваются за счет eventual consistency, когда при записи в БД клиенту отвечают, что запись уже проведена, хотя в реальности данные изменения еще не распространились по всему кластеру.<br/>
Большей масштабируемости добиваются за счет горизонтального масштабирования, которое в отличие от вертикального, можно проводить в более широким пределах.<br/>
</p>
<p align="justify">
<b>Какие минусы есть у использования NoSQL БД по сравнению с SQL БД?</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Какую аббревиатуру похожую на ACID используют относительно NoSQL БД?</b><br/>
ACID - Atomicity, Consistency, Isolation, Durability<br/>
BASE - Basically Available, Soft State, Eventually Consistent («базовая доступность, неустойчивое состояние, согласованность в конечном счете»).<br/>
Согласованность в конечном счете обеспечивает более высокую скорость записи, поскольку приложению не приходится дожидаться подтверждения того, что запись сохранилась. Как только хранилище данных приняло запись, но еще до того, как данные попали в долговременное хранение на ее диск или на диск другой машины, база данных может сообщить приложению, что операция записи прошла успешно, и приложение может переходить к следующей операции. Так вы выигрываете в производительности, правда, рискуете не увидеть тех данных, которые только что записали, либо данные могут совсем потеряться из-за какой-нибудь ошибки.<br/>
BASE has roots in Eric Brewer's Consistency, Availability and Partition-tolerance (CAP) Theorem, and eventual consistency is the underpinning of any distributed system that aims to provide high availability and partition tolerance.<br/>
</p>
<p align="justify">
<b>Слышал ли про инфраструктуру как код? Имел ли дело с Ansible?</b><br/>
Да, например в Openshift инфраструктура была описана в конфигах и лежала под контролем версий<br/>
Ansible был на одном проекте: были описаны функции в скриптах, которые вызывались с параметрами из TeamCity джоб<br/>
</p>
<p align="justify">
<b>Какие есть способы автоматизации развертывания Kubernetes?</b><br/>
Helm<br/>
</p>
<p align="justify">
<b>Зачем нужен Docker?</b><br/>
Контейнер позволяет создать изолированное окружение, в котором протестировать приложение<br/>
Также позволяет развернуть необходимую инфраструктуру, например БД, брокеры сообщений и т.д.<br/>
По сравнению с виртуалкой - требует намного меньше ресурсов<br/>
</p>
<p align="justify">
<b>Со временем запрос стал выполняться дольше. Какие есть способы ускорения?</b><br/>
Посмотреть, какие изменения были сделаны недавно, если деградация произошла не так давно. Возможны виноваты свежие изменения.<br/>
Посмотреть план запроса, убедиться, что используются те индексы, на которые рассчитываем. Либо добавить индексы, если их нет.<br/>
Также проблема может быть в данных: их стало столько, что индекс перестал использоваться. Также убедиться в этом при помощи плана запроса.<br/>
</p>
<p align="justify">
<b>Зачем нужны индексы?</b><br/>
Для ускорения поиска<br/>
</p>
<p align="justify">
<b>Почему бы не сделать индексы на все поля сразу?</b><br/>
Индекс надо в том числе обновлять. в какой-то момент затраты на это могут стать критичными и замедлять выполнение запросов<br/>
</p>
<p align="justify">
<b>Как работает индекс?</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Расскажи про Kafka? Из чего состоит Kafka?</b><br/>
</p>
<p align="justify">
<b>Во сколько раз увеличится скорость обработки если в одном топике есть 5 партиций и будет 10 consumerов?</b><br/>
?<br/>
</p>
<p align="justify">
<b>Команда Linux для просмотра java процессов</b><br/>
<pre>
ps aux | grep java
</pre>
</p>
<p align="justify">
<b>Разница между checked и unchecked exceptions</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Можно ли обработать RuntimeException? Обрабатывал ли?</b><br/>
Да. Это unchecked exception, и его отличие от checked лишь в том, что не надо отражать возможность его бросания в сигнатуре метода<br/>
</p>
<p align="justify">
<b>Для чего нужна аннотация @SneakyThrows в Lombok?</b><br/>
Чтобы избегнуть указания checked exceptions в сигнатуре метода, и потом быть обязанным их обрабатывать<br/>
</p>
<p align="justify">
<b>Что будет выведено в консоль?</b><br/>
<pre>
public static Stream&lt;String&gt; bar(Stream&lt;String&gt; stream) {
    System.out.println("start bar");
    return stream.filter(el -&gt; !el.equals("bar"))
            .peek(System.out::print);
}

public static void main(String[] args) {
    Stream&lt;String&gt; stream = Stream.of("foo", "bar", "foo", "bar");
    Stream&lt;String&gt; result = bar(stream);
}
</pre>
Кажется, что будет выведено 'foofoo', но на стриме не вызвана терминальная операция, поэтмоу ничего не будет выведено.<br/>
</p>
<p align="justify">
<b>Вернуть список пользователей, у которых какая-либо группа начинается на "А":</b><br/>
<pre>
@Data
class User {
    private int id;
    private String name;
    private List&lt;Group&gt; groups;
}

@Data
class Group {
    private int userId;
    private String name;
}

@Slf4j
public class Test {
    public List&lt;User&gt; foo(Stream&lt;User&gt; usersStream) {
	    // ...
        return result;
    }
}
</pre>
Решение:<br/>
<pre>
public List&lt;User&gt; foo(Stream&lt;User&gt; usersStream) {
    return usersStream
            .filter(user -&gt; user.groups.stream()
                    .map(Group::getName)
                    .anyMatch(s -&gt; s.startsWith("A"))
            )
            .collect(Collectors.toList());

</pre>
</p>
<p align="justify">
<b>Написать ExecutorService. Какие есть преимущества у ExecutorService перед Thread?</b><br/>
?<br/>
</p>
<p align="justify">
<b>Написать deadlock</b><br/>
Deadlock или взаимная блокировка — это ошибка, которая происходит когда потоки имеют циклическую зависимость от пары синхронизированных объектов.<br/>
<a href="https://www.javatpoint.com/deadlock-in-java">https://www.javatpoint.com/deadlock-in-java</a><br/>
<pre>
public class TestDeadlockExample1 {
    public static void main(String[] args) {
        final String resource1 = "resource1";
        final String resource2 = "resource2";

        // t1 tries to lock resource1 then resource2
        Thread t1 = new Thread() {
            @SneakyThrows
            public void run() {
                synchronized (resource1) {
                    System.out.println("Thread 1: locked resource 1");

                    Thread.sleep(100);

                    synchronized (resource2) {
                        System.out.println("Thread 1: locked resource 2");
                    }
                }
            }
        };

        // t2 tries to lock resource2 then resource1
        Thread t2 = new Thread() {
            @SneakyThrows
            public void run() {
                synchronized (resource2) {
                    System.out.println("Thread 2: locked resource 2");

                    Thread.sleep(100);

                    synchronized (resource1) {
                        System.out.println("Thread 2: locked resource 1");
                    }
                }
            }
        };

        t1.start();
        t2.start();
    }
}
</pre>
</p>
<p align="justify">
<b>Зачем нужно ключевое слово volatile?</b><br/>
Для многопоточной оптимизации переменная может быть скопирована, для реализации так называемого "кэша потока". Тогда разные потоки будут работать с разными ее копиями.<br/>
Использование volatile приводит к тому, что все потоки работают с одной и той же копией этой переменной.<br/>
</p>
<p align="justify">
<b>Зачем нужен GC? Привести пример работы любого GC которого знаешь.</b><br/>
?<br/>
</p>
<p align="justify">
<b>Отличие Spring от Spring Boot?</b><br/>
Было уже<br/>
</p>
<p align="justify">
<b>Как донастроить bean? (вопрос про BeanPostProcessor)</b><br/>
Написать свой BeanPostProcessor, там добавить нужную логику донастройки бина<br/>
</p>
<p align="justify">
<b>Преимущества инъекции зависимости в конструктор?</b><br/>
Это позволяет обнаруживать ошибки на ранней стадии: при отсутствии нужного бина в контексте, - все упадет на этапе старта приложения, а не позже, когда этот бин понадобится<br/>
</p>
<p align="justify">
<b>Какие есть 3 способа заинжектить несколько имплементаций одного интерфейса?</b><br/>
Ответ: @Qualifier, @Primary, по имени<br/>
</p>
<p align="justify">
<b>Будет ли это нормально работать? Нужно чтобы вся коллекция элементов нормально обработалась, либо ни один элемент нормально не обработался:</b><br/>
<pre>
@Transactional
public void processCollection(Collection&lt;Object&gt; objects) {
    objects.parallelStream()
            .forEach(this::processOne);
}

@Transactional
public void processOne(Object o) {
    ...
}
</pre>
</p>
<p align="justify">
<b>Как сделать REST-запрос? Какие способы знаешь сделать это?</b><br/>
= При помощи RestTemplate: или вызовом соответствующего метода (get/post и т.п.) либо вызовом метода exchange с указанием, какой HTTP-метод использовать<br/>
= При помощи библиотеки OkHttp<br/>
= При помощи библиотеки OpenFeign<br/>
</p>
<p align="justify">
<b>Как работает Hashtable?</b><br/>
Hashtable - это потокобезопасный ассоциативный список.<br/>
Методы помечены как synchronized, т.е. при добавлении/извлечении элемента блокируется вся коллекция, что не оптимально.<br/>
</p>
<p align="justify">
<b>Как работает ConcurrentHashMap?</b><br/>
<a href="https://stackoverflow.com/questions/12646404/concurrenthashmap-and-hashtable-in-java">https://stackoverflow.com/questions/12646404/concurrenthashmap-and-hashtable-in-java</a><br/>
= Hashtable is belongs to the Collection framework; ConcurrentHashMap belongs to the Executor framework.<br/>
= Hashtable uses _single lock_ for whole data. ConcurrentHashMap uses _multiple locks_ on segment level (16 by default) instead of object level i.e. whole Map.<br/>
= ConcurrentHashMap locking is applied only for updates. In case of retrievals, it allows full concurrency, retrievals reflect the results of the most recently completed update operations. So reads can happen very fast while writes are done with a lock.<br/>
= ConcurrentHashMap doesn't throw a ConcurrentModificationException if one thread tries to modify it while another is iterating over it and does not allow null values.<br/>
= ConcurrentHashMap returns Iterator, which fails-safe (i.e. iterator will make a copy of the internal data structure) on concurrent modification.<br/>
= ConcurrentHashMap uses a database shards logic (Segment<K, V>[] segments) is known as Concurrency-Level, i.e. divides the data into shards(segments) then puts locks on each shard (segment) instead of putting a single lock for whole data (Map). The default value is 16.<br/>
</p>
<p align="justify">
<b>Как работает HashMap?</b><br/>
Вычисляем хэшкод, остаток от деления его на кол-во бакетов дает номер бакета.<br/>
В каждом бакете односвязный список, в него добавляется entry, содержащая ключ+значение.<br/>
Начиная с Java 8 - после добавления 8го элемента в этот бакет - связный список перестраивается в красно-черное дерево.<br/>
Красно-чёрное дерево - самобалансирующееся двоичное дерево поиска, гарантирующее логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного атрибута узла дерева — «цвета».<br/>
As of Java 8 (see JEP 180), the data structure in which the values inside one bucket are stored is changed from a list to a balanced tree if a bucket contains 8 or more values, and it's changed back to a list if, at some point, only 6 values are left in the bucket. This improves the performance to be O(log n).<br/>
</p>
<p align="justify">
<b>Можно ли потерять элемент в HashMap?</b><br/>
Если метод hashCode так написан, что хэш ключа меняется, то можем действительно потерять объект в HashMap<br/>
</p>
<p align="justify">
<b>Какой тип классов ты бы использовал для ключа HashMap?</b><br/>
Immutable класс (например String)<br/>
</p>
<p align="justify">
<b>Как использовать свой класс в качестве ключа? Что если в этом классе есть поле коллекции (т.е. класс не до конца иммутабельный)?</b><br/>
Сделать свой класс immutable.<br/>
Если в классе есть поле коллекции - возвращать unmodifiable коллекцию в геттере.<br/>
</p>
<p align="justify">
<b>Какие использовал коллекции из Concurrent пакета?</b><br/>
LinkedBlockingQueue - в Java-лабе для коннекшн-пула<br/>
ConcurrentHashMap - для получения конкурентного мэпа<br/>
AtomicInteger - для конкурентного подсчета кол-ва событий<br/>
CopyOnWriteArrayList - thread-safe variant of ArrayList<br/>
</p>
<p align="justify">
<b>Есть 2 банковских аккаунта. Мы с одного хотим перевести деньги на другой. Из двух потоков в разном порядке захватываем мониторы этих аккаунтов (в первом потоке </b><br/>
Захватим монитор первого аккаунта и затем второго, а во втором потоке наоборот). Какая здесь есть проблема? Способы решить возникающий deadlock?<br/>
<a href="https://habr.com/ru/company/nordavind/blog/176541/">https://habr.com/ru/company/nordavind/blog/176541/</a><br/>
Видна проблема потенциального дедлока.<br/>
Решение - соблюдать два следующих правила:<br/>
= Первое правило: всегда отпускайте захваченные мьютексы в обратном захвату порядке, т.е. руководствуйтесь логикой «первый захвачен – последний отпущен».<br/>
= Второе правило: всегда соблюдайте один и тот же порядок захвата мьютексов в разных потоках.<br/>
Если вы в одном потоке захватываете мьютекс 1, а затем мьютекс 2, то недопустимо захватывать их в ином порядке в другом потоке.<br/>
</p>
<p align="justify">
<b>Какие есть виды сборщиков мусора?</b><br/>
<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a><br/>
= Serial<br/>
The serial collector is the default for client style machines in Java SE 5 and 6. With the serial collector, both minor and major garbage collections are done serially (using a single virtual CPU). In addition, it uses a mark-compact collection method. This method moves older memory to the beginning of the heap so that new memory allocations are made into a single continuous chunk of memory at the end of the heap. This compacting of memory makes it faster to allocate new chunks of memory to the heap.<br/>
</p>
<p align="justify">
= Parallel<br/>
The parallel garbage collector uses multiple threads to perform the young genertion garbage collection. By default on a host with N CPUs, the parallel garbage collector uses N garbage collector threads in the collection. The number of garbage collector threads can be controlled with command-line options:<br/>
-XX:ParallelGCThreads=<desired number><br/>
On a host with a single CPU the default garbage collector is used even if the parallel garbage collector has been requested. On a host with two CPUs the parallel garbage collector generally performs as well as the default garbage collector and a reduction in the young generationgarbage collector pause times can be expected on hosts with more than two CPUs. The Parallel GC comes in two flavors.<br/>
</p>
<p align="justify">
= Concurent Mark Sweep (CMS)<br/>
The Concurrent Mark Sweep (CMS) collector (also referred to as the concurrent low pause collector) collects the tenured generation. It attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. Normally the concurrent low pause collector does not copy or compact the live objects. A garbage collection is done without moving the live objects. If fragmentation becomes a problem, allocate a larger heap.<br/>
Note: CMS collector on young generation uses the same algorithm as that of the parallel collector.<br/>
</p>
<p align="justify">
= Garbage-First (G1)<br/>
The Garbage First or G1 garbage collector is available in Java 7 and is designed to be the long term replacement for the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector that has quite a different layout from the other garbage collectors described previously. However, detailed discussion is beyond the scope of this OBE.<br/>
</p>
<p align="justify">
См. также ответ на вопрос "Как работает Garbage Collector в java?" в https://andrei-punko.github.io/java-interview-faq-n-answers<br/>
</p>
<p align="justify">
<b>Преимущества @Autowired в конструктор?</b><br/>
Если одного из бинов для инжекта нету - приложение упадет при поднятии контекста, на старте, а не потом, позже, когда дернут нужную операцию и этот бин понадобится.<br/>
Такая архитектура позволяет устранять ошибки на ранней стадии.<br/>
</p>
<p align="justify">
<b>Всегда ли отрабатывает @PostConstruct?</b><br/>
Метод, аннотированный @PostConstruct, вызывается после вызова конструктора и инъекции зависимостей, перед вызовом метода init().<br/>
</p>
<p align="justify">
Оказывается, есть такая проблема:<br/>
<a href="https://answacode.com/questions/48380553/vesennyaya-zagruzka-postconstruct-ne-vyzyvaetsya-na-component">https://answacode.com/questions/48380553/vesennyaya-zagruzka-postconstruct-ne-vyzyvaetsya-na-component</a><br/>
Из-за новой модульной системы в Java9 есть проблема например в SpringBoot-1.5.9, поскольку класс аннотации @PostConstruct не находится в пути к классам. Есть несколько способов решить эту проблему:<br/>
= запустите приложение на Java8.<br/>
Или, если используется все же Java9:<br/>
= добавить зависимость javax.annotation:javax.annotation-api к POM или<br/>
= обновить до более новой Spring-Boot версии 2.0.0+, которая включает эту зависимость<br/>
</p>
<p align="justify">
<b>Spring Cloud. Какие компоненты есть у Spring Cloud?</b><br/>
Eureka - service discovery<br/>
Ribbon - client-side load balancer<br/>
Hystrix - circuit breaker<br/>
Feign - declarative REST client, instead of Spring RestTemplate<br/>
Zuul - JVM-based router and server side load balancer<br/>
Config - configuration management of distributed system<br/>
Bus - uses lightweight message broker to link distributed system nodes. The primary usage is to broadcast configuration changes or other management information<br/>
Stream - framework built on top of Spring Boot and Spring Integration that helps in creating event-driven or message-driven microservices<br/>
Sleuth - provides Spring Boot auto-configuration for distributed tracing<br/>
</p>
<p align="justify">
<b>Оркестраторы?</b><br/>
<a href="https://mcs.mail.ru/blog/what-are-container-orchestration-systems">https://mcs.mail.ru/blog/what-are-container-orchestration-systems</a><br/>
Задачи оркестраторов контейнеров:<br/>
= Подготовка инфраструктуры и развертывание.<br/>
Это установка приложения и его зависимостей на сервер, включая подготовку этого сервера — установку библиотек, служб и т.д.<br/>
</p>
<p align="justify">
= Конфигурация и планирование<br/>
Это часть подготовки сервера, а именно его настройка с помощью специальных программ-планировщиков. Их применяют не только для микросервисных приложений, но и для монолитных. Инструменты управления конфигурацией обычно используют «факты», чтобы убедиться в достоверности данных о сервере: например, «убедитесь, что /etc/my.cnf содержит то-то» или «NGinX должен работать со следующими файлами конфигурации». Оркестраторы содержат в себе такие планировщики, их не надо ставить отдельно.<br/>
</p>
<p align="justify">
= Распределение ресурсов<br/>
Для развертывания приложения в продакшен-кластере требуется выделить вычислительные ресурсы сервера для различных процессов: это объемы памяти и CPU. Устанавливаются запрашиваемые и предельные параметры, правила при достижении контейнерами ресурсных лимитов, различные ограничения. Это важно для поддержания приложения в рабочем состоянии и сведения затрат к минимуму.<br/>
</p>
<p align="justify">
= Масштабирование контейнеров на основе рабочих нагрузок<br/>
Простой излишних ресурсов приводит к издержкам, а недостаток — к нестабильной работе приложения. Регулировать объемы используемых ресурсов позволяет масштабирование, основанное на анализе нагрузок, которое может быть ручным или автоматизированным.<br/>
</p>
<p align="justify">
= Балансировка нагрузки<br/>
Автоматический анализ и распределение рабочих нагрузок на сервер целиком и контейнеры в частности. Балансировка оптимизирует использование ресурсов, увеличивает пропускную способность каналов связи, минимизирует время отклика и помогает избежать перегрузки отдельных ресурсов.<br/>
</p>
<p align="justify">
= Маршрутизация трафика<br/>
Чтобы приложение было доступно из интернета, нужно настроить правильное распределение трафика из внешней сети по контейнерам и нужным сервисам.<br/>
</p>
<p align="justify">
= Мониторинг состояния контейнеров<br/>
Эта функция позволяет видеть, какие контейнеры и их образы запущены и где, какие команды используются в контейнерах, какие контейнеры потребляют слишком много ресурсов и почему. Автоматический аудит журнала ошибок позволяет вовремя устранять неполадки.<br/>
</p>
<p align="justify">
= Обеспечение безопасного взаимодействия между контейнерами<br/>
На основе непрерывной оценки кластеров, узлов и реестра контейнеров предоставляются данные о неверных конфигурациях и других уязвимостях, которые могут представлять угрозу, а также рекомендации по устранению выявленных угроз.<br/>
</p>
<p align="justify">
Примеры систем оркестрации контейнеров:<br/>
= Kubernetes. Портативная платформа с открытым исходным кодом, считается отраслевым стандартом. Поддерживает и декларативную конфигурацию объектов, и автоматизацию. Можно автоматизировать масштабирование, развертывание с помощью шаблонов и управление рабочей нагрузкой и сервисами контейнеров.<br/>
</p>
<p align="justify">
= OpenShift Container Platform. Платформа корпоративного уровня в формате PaaS для разработки, развертывания и управления не только контейнерными, но и классическими приложениями и их компонентами в режиме самообслуживания. Позволяет автоматизировать их в физических, виртуальных и общедоступных, частных и гибридных облачных средах.<br/>
</p>
<p align="justify">
= Docker Swarm. Это "родная", базовая система кластеризации и оркестровки контейнеров Docker. Использует декларативную модель. Взаимодействие с кластером происходит через команды Docker, а управление действиями — через менеджер Swarm.<br/>
</p>
<p align="justify">
<b>Разница аннотаций @SpringBootTest и JUnit?</b><br/>
The @SpringBootTest annotation is useful when we need to bootstrap the entire container. The annotation works by creating the ApplicationContext that will be utilized in our tests.<br/>
Аннотации JUnit тестируют один класс в изоляции<br/>
</p>
<p align="justify">
<b>Что такое пирамида тестирования?</b><br/>
<a href="https://dou.ua/lenta/columns/testing-in-jiji/">https://dou.ua/lenta/columns/testing-in-jiji/</a><br/>
Пирамида тестирования — один из способов обеспечения качества ПО, визуализация, которая помогает группировать тесты по типу их назначения.<br/>
Чем выше мы будем подниматься по пирамиде, тем выше комплексность, цена и хрупкость тестов.<br/>
</p>
<p align="justify">
= Первый (нижний) уровень: unit-тесты<br/>
В основе пирамиды лежат маленькие, дешевые и быстрые unit-тесты. За их написание и поддержку отвечает команда разработчиков. Весь старый и новый функционал должен быть подкреплен unit-тестами. Именно с их помощью можно быстро и комплексно проверить стабильность приложения.<br/>
</p>
<p align="justify">
= Второй уровень: интеграционные тесты<br/>
Суть этого процесса в объединении программных модулей в группы и их последующее тестирование. Проще говоря, это проверка бизнес-логики без использования UI. Пишут разработчики либо QA<br/>
</p>
<p align="justify">
= Третий уровень: тесты пользовательского функционала (end-to-end / functional tests)<br/>
Здесь количество тестов должно быть наименьшим. Воссоздавая пользовательские сценарии, мы проверяем приложения на стабильность и работоспособность. На этом уровне тесты самые хрупкие.<br/>
</p>
<p align="justify">
<b>Зачем нужны разные виды тестов?</b><br/>
Тесты вообще нужны для<br/>
= проверки работоспособности: при добавлении нового кода - приложение работает как ожидалось<br/>
= фиксации рабочего состояния: при изменении старого кода - быть уверенным в том, что переходим из рабочего состояния в рабочее<br/>
Разные виды тестов обеспечивают разную гранулярность тестируемых блоков (в крупную/мелкую клетку) и позволяют лучше и быстрее опеределить, что именно и где сломалось.<br/>
</p>
<p align="justify">
<b>Kafka. Consumer/producer, консьюмер-группа, как работает топик, партиция? Как работает кластер Кафки? Transaction log Kafka. Гарантия доставки сообщения.</b><br/>
Transaction log Kafka - сообщения хранятся в текстовом файле, доступны по офсету<br/>
?<br/>
</p>
<p align="justify">
<b>Отличие stack от heap. Как их конфигурировать? Какие еще области памяти знаешь? Расскажи про Java Memory Model? Как устроена память в Java?</b><br/>
<a href="https://itsobes.ru/JavaSobes/na-kakie-oblasti-delitsia-pamiat-jvm/">https://itsobes.ru/JavaSobes/na-kakie-oblasti-delitsia-pamiat-jvm/</a><br/>
JVM разделяет память на две основные категории: "кучу" (heap) и "не кучу" (non-heap).<br/>
= Heap - куча, вся managed-память, в которой хранятся все пользовательские объекты. Параметры -Xms, -Xmn и -Xmx устанавливают начальный, минимальный и максимальный размеры хипа соответственно.<br/>
Части кучи: Young Generation (Eden + Survivor 1 & 2), Old Generation и другие – специфичные для сборщика мусора части кучи, поколения. Могут быть разные, но общий подход сохраняется: долгоживущий объект постепенно двигается во всё более старое поколение; сборка мусора в разных поколениях происходит раздельно; чем поколение старше, тем сборка в нём реже, но и дороже.<br/>
</p>
<p align="justify">
= Stack – место под примитивы и ссылки на объекты (но не сами объекты). Хранит локальные переменные и возвращаемые значения функций. Здесь же хранятся ссылки на объекты пока те конструируются. Все данные в стеке – GC roots. Освобождается сразу на выходе из функции. Принадлежит потоку, размер по-умолчанию указывается параметром виртуальной машины -Xss, но при создании потока программно можно указать отличное значение.<br/>
Xss - stack size of each thread, default value is 256 KB in JDK1.4 and 1 MB in JDK1.5+<br/>
</p>
<p align="justify">
= PermGen (permanent generation) – в этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Изначально размера -XX:PermSize, растет динамически до -XX:MaxPermSize. Не считается частью кучи.<br/>
</p>
<p align="justify">
= Metaspace – с Java 8 заменяет permanent generation. Отличие в том, что по умолчанию metaspace ограничен только размерами доступной на машине памяти, но так же как PermGen может быть ограничен, параметром -XX:MaxMetaspaceSize.<br/>
</p>
<p align="justify">
<b>Написать тело метода printTree который пройдет по всему дереву Node и распечатает каждый элемент. Какие варианты есть кроме рекурсии, чтобы избежать StackOverFlow?</b><br/>
<pre>
class Node {
	private Node left;
	private Node right;
	private int value;

	public void printTree(Node root) {}
}
</pre>
Решение:<br/>
<pre>
public void printTree(Node root) {
    Queue&lt;Node&gt; children = new ArrayDeque&lt;&gt;();
    children.add(root);
    while (!children.isEmpty()) {
        Node node = children.remove();

        System.out.println(node.value);

        if (node.left != null) {
            children.add(node.left);
        }
        if (node.right != null) {
            children.add(node.right);
        }
    }
}
</pre>
</p>
<p align="justify">
<b>Какие типы операций существуют в Stream API?</b><br/>
Два типа: intermediate and terminal - конвейерный и терминальный<br/>
</p>
<p align="justify">
<b>Что такое функциональный интерфейс?</b><br/>
Это интерфейс, который содержит только 1 абстрактный метод. Основное назначение – использование в лямбда выражениях и method reference.<br/>
</p>
<p align="justify">
<b>Что напечатает следующее выражение:</b><br/>
<pre>
Arrays.stream(new Integer[]{1, 4, 3})
        .peek(e -&gt; {
            System.out.println("Saw " + e);
        })
        .sorted()
        .peek(e -&gt; {
            System.out.println("Saw 2 " + e);
        })
        .anyMatch(item -&gt; item == 3);
</pre>
Ответ:<br/>
Saw 1<br/>
Saw 4<br/>
Saw 3<br/>
Saw 2 1<br/>
Saw 2 3<br/>
Cтрока "Saw 2 4" не выводится, т.к. на числе 3 выполнилось условие anyMatch() и дальнейший поиск не производится<br/>
</p>
<p align="justify">
Из javadoc к anyMatch:<br/>
"Returns whether any elements of this stream match the provided predicate.<br/>
May not evaluate the predicate on all elements if not necessary for determining the result."<br/>
</p>
<p align="justify">
<b>Отличие Spring от Spring Boot?</b><br/>
<a href="https://www.geeksforgeeks.org/difference-between-spring-and-spring-boot/">https://www.geeksforgeeks.org/difference-between-spring-and-spring-boot/</a><br/>
= Spring is an open-source lightweight framework that allows Java EE developers to build simple, reliable, and scalable enterprise applications. This framework mainly focuses on providing various ways to help you manage your business objects. It made the development of Web applications much easier than compared to classic Java frameworks and Application Programming Interfaces (APIs), such as Java database connectivity (JDBC), JavaServer Pages(JSP), and Java Servlet. This framework uses various new techniques such as Aspect-Oriented Programming (AOP), Plain Old Java Object (POJO), and dependency injection (DI), to develop enterprise applications.<br/>
</p>
<p align="justify">
The Spring framework can be considered as a collection of sub-frameworks, also called layers, such as Spring AOP. Spring Object-Relational Mapping (Spring ORM). Spring Web Flow, and Spring Web MVC. You can use any of these modules separately while constructing a Web application. The modules may also be grouped together to provide better functionalities in a Web application.<br/>
</p>
<p align="justify">
= Spring Boot is built on top of the conventional spring framework. So, it provides all the features of spring and is yet easier to use than spring. Spring Boot is a microservice-based framework and making a production-ready application in very less time. In Spring Boot everything is auto-configured. We just need to use proper configuration for utilizing a particular functionality. Spring Boot is very useful if we want to develop REST API.<br/>
</p>
<p align="justify">
<b>Как работает Spring Boot стартер? Как написать свой?</b><br/>
= Добавить в src/main/resources/META-INF файл spring.factories, где перечислены бины автоконфигураций<br/>
= Добавить бины автоконфигурации, которые по сути - описание части Спринг-контекста, с висящей на бинах автоконфигурации аннотацией @Conditional с различными условиями, когда эту автоконфигурацию включать<br/>
= Добавить проперти для бинов, которые будут использоваться по умолчанию<br/>
= При использовании данного стартера его зависимости будут включены транзитивно, поэтому добавить туда нужные зависимости для его (стартера) использования<br/>
</p>
<p align="justify">
<b>Что такое циклическая зависимость? Способы решения.</b><br/>
Циклическая зависимость в Spring на самом деле является циклической ссылкой, то есть два или более bean-компонентов ссылаются друг на друга, образуя замкнутый цикл. Например, A зависит от B, B зависит от C, а C зависит от A.<br/>
</p>
<p align="justify">
Сценарии разрешения циклической зависимости в Spring включают:<br/>
= Циклическая зависимость конструктора<br/>
	Не может быть решена, и может быть выброшено только исключение BeanCurrentlyInCreationException<br/>
	Частично можно решить, используя @Lazy на параметре конструктора, но тогда от инжекта через конструктор теряется смысл<br/>
= Циклическая зависимость атрибутов поля<br/>
	Spring разделяет этап создания и этап инжекта бина<br/>
</p>
<p align="justify">
<b>Какие есть способы инъекции бинов?</b><br/>
= через поля (не рекомендуется)<br/>
= через конструкторы (рекомендуется)<br/>
= через сеттеры (лучше - для опциональных зависимостей)<br/>
</p>
<p align="justify">
<b>Какие есть Spring Scope?</b><br/>
<a href="https://www.baeldung.com/spring-bean-scopes">https://www.baeldung.com/spring-bean-scopes</a><br/>
The latest version of the Spring framework defines 6 types of scopes:<br/>
= singleton<br/>
= prototype<br/>
= request<br/>
= session<br/>
= application (similar to the singleton scope, but there is a very important difference with regards to the scope of the bean)<br/>
	When beans are application scoped, the same instance of the bean is shared across multiple servlet-based applications running in the same ServletContext, while singleton scoped beans are scoped to a single application context only.<br/>
= websocket (exhibits singleton behavior, but limited to a WebSocket session only)<br/>
</p>
<p align="justify">
<b>Зачем нужен Scope Prototype? Примеры использования</b><br/>
Когда надо создавать новый экземпляр бина каждый раз для выполнения бизнес-задачи, <br/>
Например бин с неким контекстом, который актуален для обработки именно этого запроса<br/>
</p>
<p align="justify">
<b>Есть один интерфейс и 2 bean которые его используют. Как сделать @Autowired нужного bean?</b><br/>
Можно указать нужный бин с помощью @Qualifier, либо указать один из них как @Primary<br/>
</p>
<p align="justify">
<b>Привести примеры использования шаблонов проектирования в Spring</b><br/>
<a href="https://habr.com/ru/company/otus/blog/451516/">https://habr.com/ru/company/otus/blog/451516/</a><br/>
= Proxy (Заместитель)<br/>
Прокси предоставляет заместителя для другого объекта, чтобы контролировать доступ к нему.<br/>
Широко используется в AoP. Хороший пример использования Proxy — это org.springframework.aop.framework.ProxyFactoryBean. Эта фабрика создаёт AOP-прокси на основе Spring-бина.<br/>
</p>
<p align="justify">
= Singleton (Одиночка)<br/>
Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы.<br/>
В Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер.<br/>
Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект.<br/>
Рекомендуется использовать область видимости singleton для бинов без состояния.<br/>
</p>
<p align="justify">
= Factory (Фабрика)<br/>
Этот паттерн позволяет инициализировать объект через публичный статический метод, называемый фабричным методом.<br/>
Spring использует паттерн Factory для создания объекта бина с использованием следующих двух подходов:<br/>
  == BeanFactory - простой контейнер, который обеспечивает базовую поддержку DI (Dependency Injection, инъекция зависимостей). Для работы с этим контейнером используется интерфейс org.springframework.beans.factory.BeanFactory.<br/>
  == ApplicationContext - другой контейнер, присутствующий в Spring, который добавляет специфичные enterprise-функции. Эти функции включают в себя возможность чтения параметров из property-файлов и публикацию событий приложения для слушателей событий. Для работы с этим контейнером используется интерфейс org.springframework.context.ApplicationContext.<br/>
</p>
<p align="justify">
  Наиболее часто используемые реализации ApplicationContext:<br/>
  == FileSystemXmlApplicationContext — в конструкторе необходимо указать полный путь к XML-файлу с конфигурацией бинов.<br/>
  == ClassPathXmlApplicationContext — необходимо поместить XML-файл с конфигурацией бинов в CLASSPATH.<br/>
  == AnnotationConfigApplicationContext — чтение аннотаций для создания контейнеров.<br/>
</p>
<p align="justify">
= Template (Шаблон)<br/>
Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как взаимодействие с БД, отправка сообщений в очереди и т.п.).<br/>
Например: JdbcTemplate, JmsTemplate, RestTemplate<br/>
</p>
<p align="justify">
= Model View Controller (Модель-Представление-Контроллер)<br/>
Преимущество Spring MVC в том, что контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.<br/>
</p>
<p align="justify">
= Front Controller (Контроллер запросов)<br/>
Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам.<br/>
Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру.<br/>
</p>
<p align="justify">
= View Helper (Вспомогательный компонент представления)<br/>
В Spring есть несколько пользовательских JSP-тегов и макросов Velocity, помогающих отделить код от представления.<br/>
View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.<br/>
Фреймворки, такие как Spring и Struts, предоставляют собственные библиотеки тегов для инкапсуляции логики обработки в хелперах вместо размещения логики в представлении, таком как JSP-файлы.<br/>
</p>
<p align="justify">
= Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления)<br/>
IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения.<br/>
В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).<br/>
</p>
<p align="justify">
= Service Locator (Локатор служб)<br/>
ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает бин по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин.<br/>
Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе бина первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же бина через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.<br/>
</p>
<p align="justify">
= Observer-Observable (Наблюдатель)<br/>
Используется в механизме событий ApplicationContext.<br/>
Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.<br/>
</p>
<p align="justify">
= Context Object (Контекстный объект)<br/>
Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу.<br/>
ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.<br/>
</p>
<p align="justify">
<b>Если не использовать @Transactional будет ли использован прокси?</b><br/>
Да, в Spring все бины создаются через прокси, а не только те, что используют @Transactional<br/>
</p>
<p align="justify">
<b>Как создать прокси объект? С помощью каких механизмов это делает Spring?</b><br/>
<a href="https://medium.com/@spac.valentin/java-dynamic-proxy-mechanism-and-how-spring-is-using-it-93756fc707d5">https://medium.com/@spac.valentin/java-dynamic-proxy-mechanism-and-how-spring-is-using-it-93756fc707d5</a><br/>
There are multiple ways of creating proxies:<br/>
= Using plain java objects, if you know the interface beforehand. These are static proxies because you know at compile time the types of all involved objects.<br/>
</p>
<p align="justify">
= Using a byte-code generation/manipulation library (e.g. cglib, javassist). Used primarily when the target (class to be proxied) does not implement any interface. One of its limitations is that the proxy target must not be a final class, as this approach uses inheritance to generate the proxy.<br/>
</p>
<p align="justify">
= Using JDK Dynamic Proxies which creates implementations of Java interfaces at runtime using Reflection.<br/>
</p>
<p align="justify">
The latter two are dynamic proxies because they work without knowing at compile time the types to be proxied but they leverage reflection to determine it at runtime.<br/>
</p>
<p align="justify">
Spring делает это при помощи третьего способа, используя ProxyFactory, сохраняя бины в bean registry (чтобы потом извлечь нужный по типу)<br/>
</p>
<p align="justify">
<b>Какие еще есть способы модификации исходных классов (вопрос про weaving, AspectJ)</b><br/>
<a href="https://www.baeldung.com/aspectj">https://www.baeldung.com/aspectj</a><br/>
Виды оборачивания существующего кода в дополнительный код:<br/>
= compile-time weaving is simplest approach. When we have both the source code of the aspect and the code that we are using aspects in, the AspectJ compiler will compile from source and produce a woven class files as output. Afterward, upon execution of your code, the weaving process output class is loaded into JVM as a normal Java class.<br/>
= load-time weaving is simply binary weaving deferred until the point that a class loader loads a class file and defines the class to the JVM.<br/>
= post-compile-time (sometimes called binary weaving) weaving is used to weave existing class files and JAR files.<br/>
</p>
<p align="justify">
<b>Плюсы и минусы SQL и NoSQL баз данных</b><br/>
<a href="https://boodet.online/blog/relyacionnye-vs-nerelyacionnye-bazy-dannyh-otlichiya-i-preimushhestva">https://boodet.online/blog/relyacionnye-vs-nerelyacionnye-bazy-dannyh-otlichiya-i-preimushhestva</a><br/>
= Язык<br/>
SQL используют универсальный язык структурированных запросов для определения и обработки данных. Это накладывает определенные ограничения: прежде чем начать обработку, данные надо разместить внутри таблиц и описать.<br/>
NoSQL таких ограничений не имеет. Динамические схемы для неструктурированных данных позволяют:<br/>
== ориентировать информацию на столбцы или документы;<br/>
== основывать ее на графике;<br/>
== организовывать в виде хранилища KeyValue;<br/>
== создавать документы без предварительного определения их структуры, использовать разный синтаксис;<br/>
== добавлять поля непосредственно в процессе обработки.<br/>
</p>
<p align="justify">
= Структура<br/>
SQL основаны на таблицах, а NoSQL — на документах, парах ключ-значение, графовых БД, хранилищах с широкими столбцами.<br/>
</p>
<p align="justify">
= Масштабируемость<br/>
В большинстве случаев базы данных SQL можно масштабировать по вертикали. Что это значит? Можно увеличить возможную нагрузку на один сервер, нарастив ЦП, ОЗУ или объем накопителя.<br/>
В отличие от SQL базы данных NoSQL масштабируются по горизонтали. Это означает, что больший трафик обрабатывается путем разделения или добавления большего количества серверов. Это делает NoSQL удобнее при работе с большими или меняющимися наборами данных.<br/>
</p>
<p align="justify">
SQL используют, если нужна обработка большого количества сложных запросов, или рутинного анализа данных.<br/>
Выбирайте реляционную БД, если нужна надежная обработка транзакций и ссылочная целостность.<br/>
</p>
<p align="justify">
NoSQL используют, если объем данных большой. Отсутствие явных структурированных механизмов ускорит процесс обработки Big Data. А еще это безопаснее — такие БД сложнее взломать.<br/>
Выбирайте NoSQL, если:<br/>
= необходимо хранить массивы в объектах JSON;<br/>
= записи хранятся в коллекции с разными полями или атрибутами;<br/>
= необходимо горизонтальное масштабирование.<br/>
</p>
<p align="justify">
<b>Какой механизм есть в NoSQL для защиты от сбоев типа перезагрузка/выключение сервера?</b><br/>
?<br/>
</p>
<p align="justify">
<b>Виды NoSQL БД</b><br/>
Графовая, key-value, документная, колоночная<br/>
</p>
<p align="justify">
<b>Уровни изоляции БД</b><br/>
<a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9</a><br/>
= Read uncommitted. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.<br/>
</p>
<p align="justify">
= Read committed. Во многих БД это уровень по умолчанию. Защита от dirty read, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных. Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или версионности.<br/>
</p>
<p align="justify">
= Repeatable read. Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.<br/>
Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.<br/>
</p>
<p align="justify">
= Serializable. Все транзакции выполняются последовательно, одна за другой.<br/>
</p>
<p align="justify">
<b>Какая разница между фантомным чтением и неповторяющимся чтением?</b><br/>
Неповторяющееся чтение - при повторном чтении в рамках одной транзакции - ранее прочитанные данные оказываются изменены.<br/>
Фантомное чтение - при повторной выборке строк по одним и тем же критериям в рамках одной транзакции - видим вставку новых строк другой параллельной транзакцией.<br/>
</p>
<p align="justify">
<b>Анализировал ли план запроса?</b><br/>
Да, там перечислены веса для каждой части запроса, откуда можно понять, на что тратится основное время при выполнении запроса.<br/>
Также можно увидеть, используются ли индексы и какие.<br/>
</p>
<p align="justify">
<b>Какие есть способы оптимизации выборки?</b><br/>
От менее к более радикальным:<br/>
= Использование индексов и внешних ключей для ускорения запроса<br/>
= Использование JOIN вместо подзапросов<br/>
= Использование UNION для замены созданных вручную временных таблиц<br/>
= Использование хинтов, чтобы сделать план запроса более оптимальным<br/>
= Изменение запроса с целью уменьшения использования вычислительных ресурсов<br/>
	== выбирать только нужные поля<br/>
	== избегать использования функций в where<br/>
	== избегать запросов вида like с подстановочными знаками в начале<br/>
	== использовать count(), когда этого достаточно, вместо извлечения коллекции<br/>
	== ограничить максимальное количество извлекаемых записей, использовать страничный запрос<br/>
	== использовать "жадную загрузку" где надо, чтобы избежать "проблемы N+1"<br/>
= Выполнить нормализацию БД<br/>
</p>
<p align="justify">
<b>Составной индекс в БД. Каким правилом нужно руководствоваться при составлении составного индекса? (ответ: по уникальности)</b><br/>
Составной индекс - в котором участвует не одна, а несколько колонок БД.<br/>
При составлении индекса надо ориентироваться прежде всего на запросы. Но если запросы можно изменять, то лучше расположить колонки в индексе так, чтобы вначале шли колонки с низкой cardinality.<br/>
</p>
<p align="justify">
<b>Рассказать про функциональный интерфейс и лямбда-функцию</b><br/>
Функциональный интерфейс в Java — интерфейс, в котором объявлен только один абстрактный метод.<br/>
Лямбда-выражение или просто лямбда в Java — упрощённая запись анонимного класса, реализующего функциональный интерфейс.<br/>
</p>
<p align="justify">
<b>Что такое identity hashCode?</b><br/>
<a href="https://habr.com/ru/company/vk/blog/321306/">https://habr.com/ru/company/vk/blog/321306/</a><br/>
Реализация по умолчанию hashCode() возвращает значение, которое называется идентификационный хеш (identity hash code).<br/>
Как оказалось, реализация по умолчанию hashCode() (идентификационного хеша) не имеет отношения к адресу памяти объекта, как минимум в OpenJDK.<br/>
В HotSpot идентификационный хеш генерируется лишь раз, а затем кешируется в слове mark в заголовке объекта. Т.е. перемещения объекта после сборок мусора в памяти НЕ вызывают смену значения хэшкода.<br/>
</p>
<p align="justify">
<b>Сборщик мусора, который не собирает мусор</b><br/>
Epsilon<br/>
</p>
<p align="justify">
<b>Где используется ForkJoinPool?</b><br/>
В Stream API: parallelStream использует ForkJoinPool.commonPool(), a thread pool shared by the entire application.<br/>
</p>
<p align="justify">
<b>Шардирование vs партиционирование</b><br/>
<a href="https://web-creator.ru/articles/partitioning_replication_sharding">https://web-creator.ru/articles/partitioning_replication_sharding</a><br/>
= Партиционирование — это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным администратором критериям. Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. Для правильного конфигурирования параметров партиционирования необходимо, чтобы в каждом потоке было примерно одинаковое количество записей.<br/>
Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, а не со всех архивом за годы существования новостного ресурса.<br/>
</p>
<p align="justify">
= Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave). Мастера используются для изменения данных, а слэйвы — для считывания. В классической схеме репликации обычно один мастер и несколько слэйвов, так как в большей части веб-проектов операций чтения на несколько порядков больше, чем операций записи. Однако в более сложной схеме репликации может быть и несколько мастеров.<br/>
Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов — используемый для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.<br/>
</p>
<p align="justify">
= Шардинг — это прием, который позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных.<br/>
Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, таким образом все данные пользователя будут храниться и обрабатываться на одном сервере, а не собираться по частям с нескольких.<br/>
</p>
<p align="justify">
<b>Если индекс строится по полю VARCHAR, какой лучше индекс применять?</b><br/>
Лучше применять Hash-индекс, т.к. по нему быстрее найти значение. Т.к. в случае B-Tree будем долго идти по дереву, пока дойдем до конца<br/>
</p>
<p align="justify">
<b>Рассказать о PECS</b><br/>
<a href="https://habr.com/ru/post/559268/">https://habr.com/ru/post/559268/</a><br/>
PECS - "Producer Extends Consumer Super".<br/>
Если у нас есть некая коллекция, типизированная wildcard с верхней границей (extends) – то это, «продюсер». «Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает».<br/>
Если же у нас коллекция, типизированная wildcard по нижней границе (super) – то это, «потребитель», который «только принимает, а предоставить ничего не может». <br/>
</p>
<p align="justify">
<b>Ковариантность/контравариантность типов</b><br/>
<a href="https://itsobes.ru/JavaSobes/chto-takoe-kovariantnost-i-kontravariantnost/">https://itsobes.ru/JavaSobes/chto-takoe-kovariantnost-i-kontravariantnost/</a><br/>
Ковариантность/контравариантность типов – это сохранение/обращение порядка наследования для производных типов. Проще говоря, когда у ковариантных сущностей типами-параметрами являются родитель и наследник, они сами становятся как бы родителем и наследником. Контравариантные наоборот, становятся наследником и родителем.<br/>
</p>
<p align="justify">
Легче всего осознать эти понятия на примерах:<br/>
= Ковариантность: List<Integer> можно присвоить в переменную типа List<? extends Number> (как будто он наследник List<Number>).<br/>
= Контравариантность: в качестве параметра метода List<Number>#sort типа Comparator<? super Number> может быть передан Comparator<Object> (как будто он родитель Comparator<Number>).<br/>
</p>
<p align="justify">
Существует еще одно связанное понятие – инвариантность. Инвариантность – это отсутствие свойств ковариантности и контрвариантности. Дженерики без вайлдкардов инвариантны: List<Number> нельзя положить ни в переменную типа List<Double>, ни в List<Object>.<br/>
Массивы ковариантны: в переменную Object[] можно присвоить значение типа String[].<br/>
</p>
<p align="justify">
<b>Set, можно ли положить в него null? Почему куда-то можно, куда-то нельзя, что необходимо для работы с TreeSet, как в него положить null?</b><br/>
В HashSet можно<br/>
В TreeSet нельзя. Чтобы было можно - надо указать такой компаратор, который позволяет сравнивать с null.<br/>
</p>

    <hr/>
    <p>
        <small>
            Autogenerated content from <a href="https://github.com/andrei-punko/java-interview-faq-n-answers">source</a>
        </small>
    </p>
</div>

<!-- Optional JavaScript; choose one of the two! -->

<!-- Option 1: Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
        crossorigin="anonymous"></script>

<!-- Option 2: Separate Popper and Bootstrap JS -->
<!--
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.6.0/dist/umd/popper.min.js" integrity="sha384-KsvD1yqQ1/1+IA7gi3P0tyJcT3vR+NdBTt13hSJ2lnve8agRGXTTyNaBYmCR/Nwi" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.min.js" integrity="sha384-nsg8ua9HAw1y0W1btsyWgBklPnCUAFLuTMS2G72MMONqmOymq585AcH49TLBQObG" crossorigin="anonymous"></script>
-->
</body>
</html>
