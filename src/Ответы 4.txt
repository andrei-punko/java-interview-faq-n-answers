
1,2. Отличие stack от heap. Как их конфигурировать? Какие еще области памяти знаешь?
https://itsobes.ru/JavaSobes/na-kakie-oblasti-delitsia-pamiat-jvm/
JVM разделяет память на две основные категории: "кучу" (heap) и "не кучу" (non-heap).
= Heap - куча, вся managed-память, в которой хранятся все пользовательские объекты. Параметры -Xms, -Xmn и -Xmx устанавливают начальный, минимальный и максимальный размеры хипа соответственно.
Части кучи: Young Generation (Eden + Survivor 1 & 2), Old Generation и другие – специфичные для сборщика мусора части кучи, поколения. Могут быть разные, но общий подход сохраняется: долгоживущий объект постепенно двигается во всё более старое поколение; сборка мусора в разных поколениях происходит раздельно; чем поколение старше, тем сборка в нём реже, но и дороже.
	
= Stack – место под примитивы и ссылки на объекты (но не сами объекты). Хранит локальные переменные и возвращаемые значения функций. Здесь же хранятся ссылки на объекты пока те конструируются. Все данные в стеке – GC roots. Освобождается сразу на выходе из функции. Принадлежит потоку, размер по-умолчанию указывается параметром виртуальной машины -Xss, но при создании потока программно можно указать отличное значение.
Xss - stack size of each thread, default value is 256 KB in JDK1.4 and 1 MB in JDK1.5+

= PermGen (permanent generation) – в этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Изначально размера -XX:PermSize, растет динамически до -XX:MaxPermSize. Не считается частью кучи.

= Metaspace – с Java 8 заменяет permanent generation. Отличие в том, что по умолчанию metaspace ограничен только размерами доступной на машине памяти, но так же как PermGen может быть ограничен, параметром -XX:MaxMetaspaceSize.

3. Написать тело метода printTree который пройдет по всему дереву Node и распечатает каждый элемент. Какие варианты есть кроме рекурсии, чтобы избежать StackOverFlow?
```
class Node {
	private Node left;
	private Node right;
	private int value;

	public void printTree(Node root) {}
}
```
Решение:
```
public void printTree(Node root) {
    Queue<Node> children = new ArrayDeque<>();
    children.add(root);
    while (!children.isEmpty()) {
        Node node = children.remove();

        System.out.println(node.value);

        if (node.left != null) {
            children.add(node.left);
        }
        if (node.right != null) {
            children.add(node.right);
        }
    }
}
```

4.  Какие типы операций существуют в Stream API?
два типа: intermediate and terminal - конвейерный и терминальный

5. Что такое функциональный интерфейс?
Это интерфейс, который содержит только 1 абстрактный метод. Основное назначение – использование в лямбда выражениях и method reference.

6. Что напечатает следующее выражение:
```
Arrays.stream(new Integer[]{1, 4, 3})
        .peek(e -> {
            System.out.println("Saw " + e);
        })
        .sorted()
        .peek(e -> {
            System.out.println("Saw 2 " + e);
        })
        .anyMatch(item -> item == 3);
```
Ответ:
Saw 1
Saw 4
Saw 3
Saw 2 1
Saw 2 3
//Cтрока "Saw 2 4" не выводится, т.к. на числе 3 выполнилось условие anyMatch() и дальнейший поиск не производится

Из javadoc к anyMatch:
"Returns whether any elements of this stream match the provided predicate.
May not evaluate the predicate on all elements if not necessary for determining the result."

7. Отличие Spring от Spring Boot?
https://www.geeksforgeeks.org/difference-between-spring-and-spring-boot/
= Spring is an open-source lightweight framework that allows Java EE developers to build simple, reliable, and scalable enterprise applications. This framework mainly focuses on providing various ways to help you manage your business objects. It made the development of Web applications much easier than compared to classic Java frameworks and Application Programming Interfaces (APIs), such as Java database connectivity (JDBC), JavaServer Pages(JSP), and Java Servlet. This framework uses various new techniques such as Aspect-Oriented Programming (AOP), Plain Old Java Object (POJO), and dependency injection (DI), to develop enterprise applications.

The Spring framework can be considered as a collection of sub-frameworks, also called layers, such as Spring AOP. Spring Object-Relational Mapping (Spring ORM). Spring Web Flow, and Spring Web MVC. You can use any of these modules separately while constructing a Web application. The modules may also be grouped together to provide better functionalities in a Web application.

= Spring Boot is built on top of the conventional spring framework. So, it provides all the features of spring and is yet easier to use than spring. Spring Boot is a microservice-based framework and making a production-ready application in very less time. In Spring Boot everything is auto-configured. We just need to use proper configuration for utilizing a particular functionality. Spring Boot is very useful if we want to develop REST API.

8. Как работает Spring Boot стартер? Как написать свой?
= Добавить в src/main/resources/META-INF файл spring.factories, где перечислены бины автоконфигураций
= Добавить бины автоконфигурации, которые по сути - описание части Спринг-контекста, с висящей на бинах автоконфигурации аннотацией @Conditional с различными условиями, когда эту автоконфигурацию включать
= Добавить проперти для бинов, которые будут использоваться по умолчанию
= При использовании данного стартера его зависимости будут включены транзитивно, поэтому добавить туда нужные зависимости для его (стартера) использования

9. Что такое циклическая зависимость? Способы решения.
Циклическая зависимость в Spring на самом деле является циклической ссылкой, то есть два или более bean-компонентов ссылаются друг на друга, образуя замкнутый цикл. Например, A зависит от B, B зависит от C, а C зависит от A.

Сценарии разрешения циклической зависимости в Spring включают:
= Циклическая зависимость конструктора
	Не может быть решена, и может быть выброшено только исключение BeanCurrentlyInCreationException
	Частично можно решить, используя @Lazy на параметре конструктора, но тогда от инжекта через конструктор теряется смысл
= Циклическая зависимость атрибутов поля
	Spring разделяет этап создания и этап инжекта бина

10. Какие есть способы инъекции бинов?
= через поля (не рекомендуется)
= через конструкторы (рекомендуется)
= через сеттеры (лучше - для опциональных зависимостей)

11. Какие есть Spring Scope?
https://www.baeldung.com/spring-bean-scopes
The latest version of the Spring framework defines 6 types of scopes:
= singleton
= prototype
= request
= session
= application (similar to the singleton scope, but there is a very important difference with regards to the scope of the bean)
	When beans are application scoped, the same instance of the bean is shared across multiple servlet-based applications running in the same ServletContext, while singleton scoped beans are scoped to a single application context only.
= websocket (exhibits singleton behavior, but limited to a WebSocket session only)

12. Зачем нужен Scope Prototype? Примеры использования
Когда надо создавать новый экземпляр бина каждый раз для выполнения бизнес-задачи, 
например бин с неким контекстом, который актуален для обработки именно этого запроса

13. Есть один интерфейс и 2 bean которые его используют. Как сделать @Autowired нужного bean?
Можно указать нужный бин с помощью @Qualifier, либо указать один из них как @Primary

14. Привести примеры использования шаблонов проектирования в Spring
https://habr.com/ru/company/otus/blog/451516/
= Proxy (Заместитель)
Прокси предоставляет заместителя для другого объекта, чтобы контролировать доступ к нему.
Широко используется в AoP. Хороший пример использования Proxy — это org.springframework.aop.framework.ProxyFactoryBean. Эта фабрика создаёт AOP-прокси на основе Spring-бина.

= Singleton (Одиночка)
Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы.
В Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер.
Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект.
Рекомендуется использовать область видимости singleton для бинов без состояния.

= Factory (Фабрика)
Этот паттерн позволяет инициализировать объект через публичный статический метод, называемый фабричным методом.
Spring использует паттерн Factory для создания объекта бина с использованием следующих двух подходов:
  == BeanFactory - простой контейнер, который обеспечивает базовую поддержку DI (Dependency Injection, инъекция зависимостей). Для работы с этим контейнером используется интерфейс org.springframework.beans.factory.BeanFactory.
  == ApplicationContext - другой контейнер, присутствующий в Spring, который добавляет специфичные enterprise-функции. Эти функции включают в себя возможность чтения параметров из property-файлов и публикацию событий приложения для слушателей событий. Для работы с этим контейнером используется интерфейс org.springframework.context.ApplicationContext.
  
  Наиболее часто используемые реализации ApplicationContext:
  == FileSystemXmlApplicationContext — в конструкторе необходимо указать полный путь к XML-файлу с конфигурацией бинов.
  == ClassPathXmlApplicationContext — необходимо поместить XML-файл с конфигурацией бинов в CLASSPATH.
  == AnnotationConfigApplicationContext — чтение аннотаций для создания контейнеров.

= Template (Шаблон)
Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как взаимодействие с БД, отправка сообщений в очереди и т.п.).
Например: JdbcTemplate, JmsTemplate, RestTemplate

= Model View Controller (Модель-Представление-Контроллер)
Преимущество Spring MVC в том, что контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.

= Front Controller (Контроллер запросов)
Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам.
Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру.

= View Helper (Вспомогательный компонент представления)
В Spring есть несколько пользовательских JSP-тегов и макросов Velocity, помогающих отделить код от представления.
View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.
Фреймворки, такие как Spring и Struts, предоставляют собственные библиотеки тегов для инкапсуляции логики обработки в хелперах вместо размещения логики в представлении, таком как JSP-файлы.

= Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления)
IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения.
В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).

= Service Locator (Локатор служб)
ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает бин по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин.
Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе бина первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же бина через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.

= Observer-Observable (Наблюдатель)
Используется в механизме событий ApplicationContext.
Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.

= Context Object (Контекстный объект)
Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу.
ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.

15. Если не использовать @Transactional будет ли использован прокси?
Да, в Spring все бины создаются через прокси, а не только те, что используют @Transactional

16. Как создать прокси объект? С помощью каких механизмов это делает Spring?
https://medium.com/@spac.valentin/java-dynamic-proxy-mechanism-and-how-spring-is-using-it-93756fc707d5
There are multiple ways of creating proxies:
= Using plain java objects, if you know the interface beforehand. These are static proxies because you know at compile time the types of all involved objects.

= Using a byte-code generation/manipulation library (e.g. cglib, javassist). Used primarily when the target (class to be proxied) does not implement any interface. One of its limitations is that the proxy target must not be a final class, as this approach uses inheritance to generate the proxy.

= Using JDK Dynamic Proxies which creates implementations of Java interfaces at runtime using Reflection.

The latter two are dynamic proxies because they work without knowing at compile time the types to be proxied but they leverage reflection to determine it at runtime.

Spring делает это при помощи третьего способа, используя ProxyFactory, сохраняя бины в bean registry (чтобы потом извлечь нужный по типу)

17. Какие еще есть способы модификации исходных классов (вопрос про weaving, AspectJ)
https://www.baeldung.com/aspectj
Виды оборачивания существующего кода в дополнительный код:
= compile-time weaving is simplest approach. When we have both the source code of the aspect and the code that we are using aspects in, the AspectJ compiler will compile from source and produce a woven class files as output. Afterward, upon execution of your code, the weaving process output class is loaded into JVM as a normal Java class.
= load-time weaving is simply binary weaving deferred until the point that a class loader loads a class file and defines the class to the JVM.
= post-compile-time (sometimes called binary weaving) weaving is used to weave existing class files and JAR files.

18. Плюсы и минусы SQL и NoSQL баз данных
https://boodet.online/blog/relyacionnye-vs-nerelyacionnye-bazy-dannyh-otlichiya-i-preimushhestva
= Язык
SQL используют универсальный язык структурированных запросов для определения и обработки данных. Это накладывает определенные ограничения: прежде чем начать обработку, данные надо разместить внутри таблиц и описать.
NoSQL таких ограничений не имеет. Динамические схемы для неструктурированных данных позволяют:
== ориентировать информацию на столбцы или документы;
== основывать ее на графике;
== организовывать в виде хранилища KeyValue;
== создавать документы без предварительного определения их структуры, использовать разный синтаксис;
== добавлять поля непосредственно в процессе обработки.

= Структура
SQL основаны на таблицах, а NoSQL — на документах, парах ключ-значение, графовых БД, хранилищах с широкими столбцами.

= Масштабируемость
В большинстве случаев базы данных SQL можно масштабировать по вертикали. Что это значит? Можно увеличить возможную нагрузку на один сервер, нарастив ЦП, ОЗУ или объем накопителя.
В отличие от SQL базы данных NoSQL масштабируются по горизонтали. Это означает, что больший трафик обрабатывается путем разделения или добавления большего количества серверов. Это делает NoSQL удобнее при работе с большими или меняющимися наборами данных.

SQL используют, если нужна обработка большого количества сложных запросов, или рутинного анализа данных.
Выбирайте реляционную БД, если нужна надежная обработка транзакций и ссылочная целостность.

NoSQL используют, если объем данных большой. Отсутствие явных структурированных механизмов ускорит процесс обработки Big Data. А еще это безопаснее — такие БД сложнее взломать.
Выбирайте NoSQL, если:
= необходимо хранить массивы в объектах JSON;
= записи хранятся в коллекции с разными полями или атрибутами;
= необходимо горизонтальное масштабирование.

19. Какой механизм есть в NoSQL для защиты от сбоев типа перезагрузка/выключение сервера?
?

20. Виды NoSQL БД
Графовая, key-value, документная, колоночная

21. Уровни изоляции БД
https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9
= Read uncommitted. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.

= Read committed. Во многих БД это уровень по умолчанию. Защита от dirty read, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных. Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или версионности.

= Repeatable read. Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.
Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.

= Serializable. Все транзакции выполняются последовательно, одна за другой.

22. Какая разница между фантомным чтением и неповторяющимся чтением?
Неповторяющееся чтение - при повторном чтении в рамках одной транзакции - ранее прочитанные данные оказываются изменены.
Фантомное чтение - при повторной выборке строк по одним и тем же критериям в рамках одной транзакции - видим вставку новых строк другой параллельной транзакцией.

23. Анализировал ли план запроса?
Да, там перечислены веса для каждой части запроса, откуда можно понять, на что тратится основное время при выполнении запроса.
Также можно увидеть, используются ли индексы и какие.

24. Какие есть способы оптимизации выборки?
От менее к более радикальным:
= Использование индексов и внешних ключей для ускорения запроса
= Использование JOIN вместо подзапросов
= Использование UNION для замены созданных вручную временных таблиц
= Использование хинтов, чтобы сделать план запроса более оптимальным
= Изменение запроса с целью уменьшения использования вычислительных ресурсов
	== выбирать только нужные поля
	== избегать использования функций в where
	== избегать запросов вида like с подстановочными знаками в начале
	== использовать count(), когда этого достаточно, вместо извлечения коллекции
	== ограничить максимальное количество извлекаемых записей, использовать страничный запрос
	== использовать "жадную загрузку" где надо, чтобы избежать "проблемы N+1"
= Выполнить нормализацию БД

25. Составной индекс в БД. Каким правилом нужно руководствоваться при составлении составного индекса? (ответ: по уникальности)
Составной индекс - в котором участвует не одна, а несколько колонок БД.
При составлении индекса надо ориентироваться прежде всего на запросы. Но если запросы можно изменять, то лучше расположить колонки в индексе так, чтобы вначале шли колонки с низкой cardinality.


- Рассказать про функциональный интерфейс и лямбда-функцию
Функциональный интерфейс в Java — интерфейс, в котором объявлен только один абстрактный метод.
Лямбда-выражение или просто лямбда в Java — упрощённая запись анонимного класса, реализующего функциональный интерфейс.

- Что такое identity hashCode?
https://habr.com/ru/company/vk/blog/321306/
Реализация по умолчанию hashCode() возвращает значение, которое называется идентификационный хеш (identity hash code).
Как оказалось, реализация по умолчанию hashCode() (идентификационного хеша) не имеет отношения к адресу памяти объекта, как минимум в OpenJDK.
В HotSpot идентификационный хеш генерируется лишь раз, а затем кешируется в слове mark в заголовке объекта. Т.е. перемещения объекта после сборок мусора в памяти НЕ вызывают смену значения хэшкода.

- Сборщик мусора, который не собирает мусор
Epsilon

- Где используется ForkJoinPool?
В Stream API: parallelStream использует ForkJoinPool.commonPool(), a thread pool shared by the entire application.

- Шардирование vs партиционирование
https://web-creator.ru/articles/partitioning_replication_sharding
= Партиционирование — это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным администратором критериям. Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. Для правильного конфигурирования параметров партиционирования необходимо, чтобы в каждом потоке было примерно одинаковое количество записей.
Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, а не со всех архивом за годы существования новостного ресурса.

= Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave). Мастера используются для изменения данных, а слэйвы — для считывания. В классической схеме репликации обычно один мастер и несколько слэйвов, так как в большей части веб-проектов операций чтения на несколько порядков больше, чем операций записи. Однако в более сложной схеме репликации может быть и несколько мастеров.
Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов — используемый для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.

= Шардинг — это прием, который позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных.
Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, таким образом все данные пользователя будут храниться и обрабатываться на одном сервере, а не собираться по частям с нескольких.

- Если индекс строится по полю VARCHAR, какой лучше индекс применять?
Лучше применять Hash-индекс, т.к. по нему быстрее найти значение. Т.к. в случае B-Tree будем долго идти по дереву, пока дойдем до конца

