
1. Какой контракт между equals() и hashCode()?
было уже

2. Расскажи про stack и heap?
было уже

3. Расскажи про Young Generation, Old Generation, PermGen
Young/Old generation - это области heap-а
PermGen (permanent generation) – в этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Не считается частью кучи.

4. У объекта есть адрес памяти. И это память скорее всего ограничена каким-то размером. Какую проблему ты видишь для hashCode() который определен как адрес памяти? В 
старой java было реализовано по адресу памяти, в новой Java работает не так. 
https://habr.com/ru/company/vk/blog/321306/
Реализация по умолчанию hashCode() (идентификационного хеша) не имеет отношения к адресу памяти объекта, как минимум в OpenJDK.
В HotSpot идентификационный хеш генерируется лишь раз, а затем кешируется в слове mark в заголовке объекта. Т.е. перемещения объекта после сборок мусора в памяти НЕ вызывают смену значения хэшкода.

5. Если объект создался в Young Generation, объекты могут перемещаться и менять свой адрес или нет?
В какой-то момент объект перейдет из Young Generation в Old и если мы на основе адресов памяти вычисляли хэшкод, он измениться или нет? Если изменится, с этим могут быть какие-то проблемы? Что надо сделать с объектом чтобы его вычисленный хэшкод не изменялся?
См. ответ к вопросу 4.

6. Есть класс Person с полями id и name. Эти поля должны обладать какими-то свойствами для вычисления хэшкода? Если поля будут неиммутабельными с этим могут быть проблемы? Если мы не можем гарантировать, что исходные данные immutable? 
Для вычисления хэшкода поля должны быть иммутабельными.
Если поля будут неиммутабельными - при помещении объекта в хэшированную коллекцию его потом можно не найти.
Если не можем гарантировать иммутабельность всех полей - возможно стоит вычислять хэш только по полю id.

7. Мы можем сохранять значение хэшкода когда его вычислили?
если объект immutable, то значение хэшкода не изменится, поэтому может использовать его (например как ключ в мэпе)
если объект не-immutable, то при изменении одного из полей хэшкод может измениться
если вопрос был о некоем "кэшировании" вычисленного значения хэшкода - то делать этого не надо, т.к. вычисление хэшкода предполагается выполняющимся быстро и ничего не стоит вычислить его при необходимости еще раз "здесь и сейчас"

8. Какой тип возвращает метод hashCode()? Какую размерность имеет int? Почему нельзя использовать long? (ответ: хэшкоды кешируются в хедере класса Object)
int, длиной 4 байта
я бы так ответил: потому что такой контракт метода hashCode - возвращать значение типа int
?

9. Какие базовые реализации коллекций ты знаешь? Расскажи про интерфейсы коллекций.
https://habr.com/ru/post/237043/
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: 
= простые последовательные наборы элементов Collection и 
= наборы пар «ключ — значение» (словари) Map
От Collection наследуются интерфейсы Set, List, Queue.

Реализации коллекций:
= Интерфейс List:
	== ArrayList. Динамический массив объектов. Позволяет использовать null в качестве элемента,
	== LinkedList. Двунаправленный связный список. Позволяет использовать null в качестве элемента,
	== Vector. Динамический массив объектов, позволяет использовать null в качестве элемента. Синхронизирован. Не рекомендуется использовать, если не требуется достижения потокобезопасности.
	== Stack. Является расширением коллекции Vector. Частично синхронизирована (все операции, кроме push). Не рекомендуется использовать, лучше ArrayDeque.
= Интерфейс Set:
	== HashSet. Базируется на HashMap, при добавлении в качестве ключа используется добавляемый элемент, а в качестве значения - объект-пустышка (new Object()). Из-за особенностей реализации - порядок элементов при обходе не гарантируется,
	== LinkedHashSet. Базируется на LinkedHashMap, благодаря этому порядок элементов при обходе является идентичным порядку элементов при добавлении,
	== TreeSet. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".
= Интерфейс Map:
	== Hashtable. Не рекомендуется использовать, лучше взять HashMap или ConcurrentHashMap. Не позволяет использовать null в качестве значения или ключа,
	== HashMap. Не синхронизирована и позволяет использовать null как в качестве ключа, так и значения,
	== LinkedHashMap. В отличии от HashMap, порядок итерирования равен порядку добавления элементов,
	== TreeMap. Реализация Map, основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании.
= Интерфейс Queue:
	== PriorityQueue. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.
	== ArrayDeque. Представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null. Рекомендуется использовать вместо Stack.

10. Чем List отличается от Set?
список - доступ по индексу, возможны дубликаты
множество - содержит только уникальные элементы

11. Какие нововведения появились в Java 8?
12. Что стало возможно использовать в интерфейсах, начиная с Java 8?
?

13. Чем начиная с Java 8 отличаются абстрактные классы и интерфейсы. (ответ: в интерфейсе нельзя использовать не статические поля)
?

14. Как инстанцировать экземпляр интерфейса?
= создать анонимный класс, определив имплементацию нужных методов in-place
= создать динамический прокси, передав ему интерфейс в качестве параметра

15. В каком варианте массив будет успешно отсортирован: (от 0 до 3 вариантов):
1. List<String> list = new ArrayList<>(stirings);
2. List<String> list = Arrays.asList(strings);
3. List<String> list = List.of(strings);
Collections.sort(list);
?

Какую реализацию List возвращает Arrays.asList? (ответ: возвращает другой ArrayList – fixed sized list)
Какую реализацию List возвращает List.of? (ответ: возвращает ImmutableList)

16. Удали дубликаты: String strings[] = {"u", "z", "c", "a", "a", "b"}
Решение 1: Arrays.stream(strings).distinct().collect(Collectors.toSet())
Решение 2: new LinkedHashSet<>(Arrays.asList(strings))

17.  Преобразовать: List<List<String>> lists ---> List<String> list
```
lists.stream().flatMap(Collection::stream).collect(Collectors.toList())
```

18. Что будет напечатано в консоль?
```
Stream.of("d2", "a2", "b1", "b3", "c")
        .map(s -> {
            System.out.println("map: " + s);
            return s.toUpperCase();
        })
        .anyMatch(s -> {
            System.out.println("anyMatch: " + s);
            return s.startsWith("A");
        });
```
Метод anyMatch() будет применяться только до того момента, пока return не вернет true, поэтому будут напечатаны только строки для первых двух айтемов из списка:
map: d2
anyMatch: D2
map: a2
anyMatch: A2

19. Какие виды GC знаешь?
было уже

20. С каким GC работал больше всего?
Видимо G1, потому что он по умолчанию в последних Java

21. Создается новый объект. Есть вероятность того, что он будет создан сразу в Old Generation?
Если размер объекта превышает определенную величину, JVM считает, что он очень большой, и сразу помещает объект его в Old Generation часть кучи.

22. Что такое OutOfMemoryException и когда он случается? 
24. Типы OutOfMemoryException?
Когда нет памяти в heap и когда невозможно создать нативный Thread

23. Что делает Java машина перед тем, как выкинуть OOM?
GC попробует сделать сборку мусора

25. Как GC определяет, что какой-то объект не используется? 
В ходе сборки мусора обнаруживает, что на него нет ссылок от других объектов

26. Что такое жесткие ссылки? Откуда они?
?

27. Что такое GC Root?
https://stackoverflow.com/questions/27186799/what-are-gc-roots-for-classes
A garbage collection root is an object that is accessible from outside the heap.
Memory Analyzer categorizes garbage collection roots according to the following list:
= Class loaded by system ClassLoader
    static field in JDK classes(java.* etc)
= Live thread
    stack - local variables, method params
    java.lang.Thread instance
= Object held as synchronization monitor
= JNI references
= JVM specials...

28. Что такое ThreadLocal поля?
Синглтон в рамках отдельного треда

29. Что можешь сказать об этом коде:
List<Integer> results = integers.stream()
        .map(integer -> CompletableFuture.supplyAsync(() -> process(integer), executor))
        .map(CompletableFuture::join)
        .collect(Collectors.toList());

Подсказки от интервьюера: как можно исключить последовательный запуск и ожидание каждого потока? (ответ: разорвать stream, собрать CompletableFuture в List и заджойнить не на intах, потому что они будут конвейерно джойнится по одной, а надо собрать List<CompletableFuture> и заджойнить и тогда они выполнятся параллельно)

30. Работал ли со Spring Cloud? 
было уже

31. Логгировал ли в проекте что-нибудь? Когда логгер что-то логгирует, откуда он берет все данные? Где они все хранятся?
?

32. Слышал когда-нибудь про MDC?
https://www.baeldung.com/mdc-in-log4j-2-logback
MDC (Mapped Diagnostic Context) provides a way to enrich log messages with information that could be unavailable in the scope where the logging actually occurs but that can be indeed useful to better track the execution of the program.
MDC allows us to fill a map-like structure with pieces of information that are accessible to the appender when the log message is actually written.
MDC implementations typically use ThreadLocals to store the contextual information. That's an easy and reasonable way to achieve thread-safety.
Here's the high-level idea:
= Fill the MDC with pieces of information that we want to make available to the appender
= Then log a message
= And finally clear the MDC
It is enough to change the conversion pattern, using the %X{} placeholder for each entry contained in the MDC we want to be logged:
```
log4j.appender.consoleAppender.layout.ConversionPattern=
  %-4r [%t] %5p %c{1} %x - %m - tx.id=%X{transaction.id} tx.owner=%X{transaction.owner}%n
```
Always remember to clean up the MDC context at the end of each execution. Another approach is to use ThreadPoolExecutor hooks and perform necessary cleanups after each execution. 

33. Что такое Spring и какие проблемы он решает? 
было уже

34. Какие есть стереотипные аннотации в Spring?
@Component, @Repository, @Service и @Controller

35. Чем отличается @Controller от @RestController?
@RestController - это сочетание аннотации @Controller и @ResponseBody
Controller – это класс, который отвечает за подготовку модели с данными, отображаемыми представлением, а также за выбор правильного представления.

36. Чем отличается @Service от @Component?
В данный момент это одно и то же, но рекомендуется помечать аннотацией @Service именно классы, выполняющие сервисные функции

37. Чем отличается @Component от @Repository?
Для @Repository выполняется дополнительная трансляция исключений из persistence layer

38. Какие есть scope у бина?
См. Ответы 4, вопрос 11

39. Чем отличается scope prototype если смотреть в разрезе жизненного цикла бина?
https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s04.html
There is one quite important thing to be aware of when deploying a bean in the prototype scope, in that the lifecycle of the bean changes slightly. Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, decorates and otherwise assembles a prototype object, hands it to the client and then has no further knowledge of that prototype instance. This means that while initialization lifecycle callback methods will be called on all objects regardless of scope, in the case of prototypes, _any configured destruction lifecycle callbacks will not be called_. It is the responsibility of the client code to clean up prototype scoped objects and release any expensive resources that the prototype bean(s) are holding onto. (One possible way to get the Spring container to release resources used by prototype-scoped beans is through the use of a custom bean post-processor which would hold a reference to the beans that need to be cleaned up)
In some respects, you can think of the Spring containers role when talking about a prototype-scoped bean as somewhat of a replacement for the Java 'new' operator. All lifecycle aspects past that point have to be handled by the client.

40. Где хранится singleton бин?
Доступ к нему можно получить из bean registry

41. Расскажи про жизненный цикл бина
было уже

42. Какие есть вариант инъекции бина?
См. Ответы 4, вопрос 10

43. Как создать свой Spring Boot starter?
См. Ответы 4, вопрос 8

44. Ты на код-ревью. Что не нравится? Что бы сделал иначе? Что вызывает подозрение? Как сделать self-injection? Что нужно дописать для этого?
@Component
@RequiredArgsConstructor
public class CachedPhotosService {
    private static final String RESIZED_PHOTO_CACHE_NAME = "RESIZED_PHOTO_CACHE_NAME";

	private final PhotoRepository photoRepository;
    private final PhotoValidationService photoValidationService;
    private final PhotoOperations photoOperations;

    @Cacheable(cacheNames = RESIZED_PHOTO_CACHE_NAME)
    public PhotoDTO resizedPhoto(String photoId, int width, int height) {
        photoValidationService.validateSize(width, height);

        Photo photo = photoRepository.findById(photoId);

        PhotoDTO photoDto = ConversionUtils.convert(photo);
        var resizedPhoto = photoOperations.resize(photoDto, width, height);

        return resizedPhoto;
    }

    public PhotoDTO iconifiedPhoto(String photoId) {
        return resizedPhoto(photoId, 100, 100);
    }
}
= захардкоданы размеры в iconifiedPhoto(), вынес бы в константы
= надо добавить @Transactional(readOnly=true) на resizedPhoto()
= валидацию параметров width и height можно выполнять слоем выше, при помощи валидационных аннотаций
= ConversionUtils.convert() переделал бы: вместо статического метода сделать Спринг-компонент
= @Cacheable видимо не будет работать при вызовах iconifiedPhoto, для этого можно сделать self-injection: надо дописать getter для this и вызывать на нем resizedPhoto() из iconifiedPhoto()

45. Расскажи какие тесты писал? 
юнит-тесты
интеграционные
функциональные
перфоманс тесты

46. Слышал про Testcontainers?
да

47. Слышал про WireMock?
да

48. Слышал про Mockito?
да

49. Читал про Spring Test? @SpringBootTest, как написать, чтобы поднять только 1 bean? 
https://stackoverflow.com/questions/51051994/spring-context-test-with-just-one-bean
Нужно аннотировать тест аннотацией, где указать в конфигурации только этот 1 бин:
```
@RunWith(SpringRunner.class)
@SpringBootTest(properties = "spring.profiles.active=test")
@ContextConfiguration(classes = MyTestBean.class)
```
В данной статье также указывается на необычность такого подхода: "It is in fact a valid way to achieve that goal; however, it is also a bit unusual to load an ApplicationContext that contains a single user bean"

50. С какими NoSQL базами данных работал?
Redis, Amazon ElastiCache, Tarantool

51. Зачем использовать NoSQL БД?
было уже

52. За счёт чего удается добиваться NoSQL БД большей производительности и масштабируемости?
Большей производительности добиваются за счет eventual consistency, когда при записи в БД клиенту отвечают, что запись уже проведена, хотя в реальности данные изменения еще не распространились по всему кластеру.
Большей масштабируемости добиваются за счет горизонтального масштабирования, которое в отличие от вертикального, можно проводить в более широким пределах.

53. Какие минусы есть у использования NoSQL БД по сравнению с SQL БД?
было уже

54. Какую аббревиатуру похожую на ACID используют относительно NoSQL БД?
ACID - Atomicity, Consistency, Isolation, Durability
BASE - Basically Available, Soft State, Eventually Consistent («базовая доступность, неустойчивое состояние, согласованность в конечном счете»).
Согласованность в конечном счете обеспечивает более высокую скорость записи, поскольку приложению не приходится дожидаться подтверждения того, что запись сохранилась. Как только хранилище данных приняло запись, но еще до того, как данные попали в долговременное хранение на ее диск или на диск другой машины, база данных может сообщить приложению, что операция записи прошла успешно, и приложение может переходить к следующей операции. Так вы выигрываете в производительности, правда, рискуете не увидеть тех данных, которые только что записали, либо данные могут совсем потеряться из-за какой-нибудь ошибки.
BASE has roots in Eric Brewer's Consistency, Availability and Partition-tolerance (CAP) Theorem, and eventual consistency is the underpinning of any distributed system that aims to provide high availability and partition tolerance.

55. Слышал ли про инфраструктуру как код? Имел ли дело с Ansible?
Да, например в Openshift инфраструктура была описана в конфигах и лежала под контролем версий
Ansible был на одном проекте: были описаны функции в скриптах, которые вызывались с параметрами из TeamCity джоб

56. Какие есть способы автоматизации развертывания Kubernetes?
Helm
