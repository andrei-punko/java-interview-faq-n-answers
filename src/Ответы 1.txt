
1. Какой контракт между equals() и hashCode()?
было уже

2. Расскажи про stack и heap?
?

3. Расскажи про Young Generation, Old Generation, PermGen
Young/Old generation - это области heap-а
PermGen (permanent generation) – в этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Не считается частью кучи.

4. У объекта есть адрес памяти. И это память скорее всего ограничена каким-то размером. Какую проблему ты видишь для hashCode() который определен как адрес памяти? В 
старой java было реализовано по адресу памяти, в новой Java работает не так. 
https://habr.com/ru/company/vk/blog/321306/
Реализация по умолчанию hashCode() (идентификационного хеша) не имеет отношения к адресу памяти объекта, как минимум в OpenJDK.
В HotSpot идентификационный хеш генерируется лишь раз, а затем кешируется в слове mark в заголовке объекта. Т.е. перемещения объекта после сборок мусора в памяти НЕ вызывают смену значения хэшкода.

5. Если объект создался в Young Generation, объекты могут перемещаться и менять свой адрес или нет?
В какой-то момент объект перейдет из Young Generation в Old и если мы на основе адресов памяти вычисляли хэшкод, он измениться или нет? Если изменится, с этим могут быть какие-то проблемы? Что надо сделать с объектом чтобы его вычисленный хэшкод не изменялся?
См. ответ к вопросу 4.

6. Есть класс Person с полями id и name. Эти поля должны обладать какими-то свойствами для вычисления хэшкода? Если поля будут неиммутабельными с этим могут быть проблемы? Если мы не можем гарантировать, что исходные данные immutable? 
Для вычисления хэшкода поля должны быть иммутабельными.
Если поля будут неиммутабельными - при помещении объекта в хэшированную коллекцию его потом можно не найти.
Если не можем гарантировать иммутабельность всех полей - возможно стоит вычислять хэш только по полю id.

7. Мы можем сохранять значение хэшкода когда его вычислили?
если объект immutable, то значение хэшкода не изменится, поэтому может использовать его (например как ключ в мэпе)
если объект не-immutable, то при изменении одного из полей хэшкод может измениться
если вопрос был о некоем "кэшировании" вычисленного значения хэшкода - то делать этого не надо, т.к. вычисление хэшкода предполагается выполняющимся быстро и ничего не стоит вычислить его при необходимости еще раз "здесь и сейчас"

8. Какой тип возвращает метод hashCode()? Какую размерность имеет int? Почему нельзя использовать long? (ответ: хэшкоды кешируются в хедере класса Object)
int, длиной 4 байта
я бы так ответил: потому что такой контракт метода hashCode - возвращать значение типа int
?

9. Какие базовые реализации коллекций ты знаешь? Расскажи про интерфейсы коллекций.
?

10. Чем List отличается от Set?
список - доступ по индексу, возможны дубликаты
множество - содержит только уникальные элементы

11. Какие нововведения появились в Java 8?
12. Что стало возможно использовать в интерфейсах, начиная с Java 8?
?

13. Чем начиная с Java 8 отличаются абстрактные классы и интерфейсы. (ответ: в интерфейсе нельзя использовать не статические поля)
?

14. Как инстанцировать экземпляр интерфейса?
= создать анонимный класс, определив имплементацию нужных методов in-place
= создать динамический прокси, передав ему интерфейс в качестве параметра

15. В каком варианте массив будет успешно отсортирован: (от 0 до 3 вариантов):
1. List<String> list = new ArrayList<>(stirings);
2. List<String> list = Arrays.asList(strings);
3. List<String> list = List.of(strings);
Collections.sort(list);

Какую реализацию List возвращает Arrays.asList? (ответ: возвращает другой ArrayList – fixed sized list)
Какую реализацию List возвращает List.of? (ответ: возвращает ImmutableList)

16. Удали дубликаты: String strings[] = {"u", "z", "c", "a", "a", "b"}
Решение 1: Arrays.stream(strings).distinct().collect(Collectors.toSet())
Решение 2: new LinkedHashSet<>(Arrays.asList(strings))

17.  Преобразовать: List<List<String>> lists ---> List<String> list
lists.stream().flatMap(Collection::stream).collect(Collectors.toList())

18. Что будет напечатано в консоль?
```
Stream.of("d2", "a2", "b1", "b3", "c")
        .map(s -> {
            System.out.println("map: " + s);
            return s.toUpperCase();
        })
        .anyMatch(s -> {
            System.out.println("anyMatch: " + s);
            return s.startsWith("A");
        });
```
Метод anyMatch() будет применяться только до того момента, пока return не вернет true, поэтому будут напечатаны только строки для первых двух айтемов из списка:
map: d2
anyMatch: D2
map: a2
anyMatch: A2

19. Какие виды GC знаешь?
было уже

20. С каким GC работал больше всего?
Видимо G1, потому что он по умолчанию в последних Java

21. Создается новый объект. Есть вероятность того, что он будет создан сразу в Old Generation?
Если размер объекта превышает определенную величину, JVM считает, что он очень большой, и сразу помещает объект его в Old Generation часть кучи.

22. Что такое OutOfMemoryException и когда он случается? 
?

23. Что делает Java машина перед тем, как выкинуть OOM? (ответ: GC попробует сделать сборку) 
?

24. Типы OutOfMemoryException?
Когда нет памяти в heap и когда невозможно создать нативный Thread

25. Как GC определяет, что какой-то объект не используется? 
?

26. Что такое жесткие ссылки? Откуда они?
?

27. Что такое GC Root?
?

28. Что такое ThreadLocal поля?
Синглтон в рамках отдельного треда

29. Что можешь сказать об этом коде:
List<Integer> results = integers.stream()
        .map(integer -> CompletableFuture.supplyAsync(() -> process(integer), executor))
        .map(CompletableFuture::join)
        .collect(Collectors.toList());

Подсказки от интервьюера: как можно исключить последовательный запуск и ожидание каждого потока? (ответ: разорвать stream, собрать CompletableFuture в List и заджойнить не на intах, потому что они будут конвейерно джойнится по одной, а надо собрать List<CompletableFuture> и заджойнить и тогда они выполнятся параллельно)

30. Работал ли со Spring Cloud? 
было уже

31. Логгировал ли в проекте что-нибудь? Когда логгер что-то логгирует, откуда он берет все данные? Где они все хранятся?
?

32. Слышал когда-нибудь про MDC?
https://www.baeldung.com/mdc-in-log4j-2-logback
MDC (Mapped Diagnostic Context) provides a way to enrich log messages with information that could be unavailable in the scope where the logging actually occurs but that can be indeed useful to better track the execution of the program.
?

33. Что такое Spring и какие проблемы он решает? 
?

34. Какие есть стереотипные аннотации в Spring?
@Component, @Repository, @Service и @Controller

35. Чем отличается @Controller от @RestController?
@RestController - это сочетание аннотации @Controller и @ResponseBody
Controller – это класс, который отвечает за подготовку модели с данными, отображаемыми представлением, а также за выбор правильного представления.

36. Чем отличается @Service от @Component?
В данный момент это одно и то же, но рекомендуется помечать аннотацией @Service именно классы, выполняющие сервисные функции

37. Чем отличается @Component от @Repository?
Для @Repository выполняется дополнительная трансляция исключений из persistence layer

38. Какие есть scope у бина?
См. Ответы 4, вопрос 11

39. Чем отличается scope prototype если смотреть в разрезе жизненного цикла бина?
?

40. Где хранится singleton бин?
Доступ к нему можно получить из bean registry

41. Расскажи про жизненный цикл бина
?

42. Какие есть вариант инъекции бина?
См. Ответы 4, вопрос 10

43. Как создать свой Spring Boot starter?
См. Ответы 4, вопрос 8

44. Ты на код-ревью. Что не нравится? Что бы сделал иначе? Что вызывает подозрение? Как сделать self-injection? Что нужно дописать для этого?
@Component
@RequiredArgsConstructor
public class CachedPhotosService {
    private static final String RESIZED_PHOTO_CACHE_NAME = "RESIZED_PHOTO_CACHE_NAME";

	private final PhotoRepository photoRepository;
    private final PhotoValidationService photoValidationService;
    private final PhotoOperations photoOperations;

    @Cacheable(cacheNames = RESIZED_PHOTO_CACHE_NAME)
    public PhotoDTO resizedPhoto(String photoId, int width, int height) {
        photoValidationService.validateSize(width, height);

        Photo photo = photoRepository.findById(photoId);

        PhotoDTO photoDto = ConversionUtils.convert(photo);
        var resizedPhoto = photoOperations.resize(photoDto, width, height);

        return resizedPhoto;
    }

    public PhotoDTO iconifiedPhoto(String photoId) {
        return resizedPhoto(photoId, 100, 100);
    }
}
= захардкоданы размеры в iconifiedPhoto(), вынес бы в константы
= надо добавить @Transactional(readOnly=true) на resizedPhoto()
= валидацию параметров width и height можно выполнять слоем выше, при помощи валидационных аннотаций
= ConversionUtils.convert() переделал бы: вместо статического метода сделать Спринг-компонент
= @Cacheable видимо не будет работать при вызовах iconifiedPhoto, для этого можно сделать self-injection: надо дописать getter для this и вызывать на нем resizedPhoto() из iconifiedPhoto()

45. Расскажи какие тесты писал? 
юнит-тесты
интеграционные
функциональные
перфоманс тесты

46. Слышал про Testcontainers?
да

47. Слышал про WireMock?
да

48. Слышал про Mockito?
да

49. Читал про Spring Test? @SpringBootTest, как написать, чтобы поднять только 1 bean? 
?

50. С какими NoSQL базами данных работал?
Redis, Amazon ElastiCache, Tarantool

51. Зачем использовать NoSQL БД?
было уже

52. За счёт чего удается добиваться NoSQL БД большей производительности и масштабируемости?
Большей производительности добиваются за счет eventual consistency, когда при записи в БД клиенту отвечают, что запись уже проведена, хотя в реальности данные изменения еще не распространились по всему кластеру.
Большей масштабируемости добиваются за счет горизонтального масштабирования, которое в отличие от вертикального, можно проводить в более широким пределах.

53. Какие минусы есть у использования NoSQL БД по сравнению с SQL БД?
было уже

54. Какую аббревиатуру похожую на ACID используют относительно NoSQL БД?
ACID - Atomicity, Consistency, Isolation, Durability
BASE - Basically Available, Soft State, Eventually Consistent («базовая доступность, неустойчивое состояние, согласованность в конечном счете»).
Согласованность в конечном счете обеспечивает более высокую скорость записи, поскольку приложению не приходится дожидаться подтверждения того, что запись сохранилась. Как только хранилище данных приняло запись, но еще до того, как данные попали в долговременное хранение на ее диск или на диск другой машины, база данных может сообщить приложению, что операция записи прошла успешно, и приложение может переходить к следующей операции. Так вы выигрываете в производительности, правда, рискуете не увидеть тех данных, которые только что записали, либо данные могут совсем потеряться из-за какой-нибудь ошибки.
BASE has roots in Eric Brewer's Consistency, Availability and Partition-tolerance (CAP) Theorem, and eventual consistency is the underpinning of any distributed system that aims to provide high availability and partition tolerance.

55. Слышал ли про инфраструктуру как код? Имел ли дело с Ansible?
Да, например в Openshift инфраструктура была описана в конфигах и лежала под контролем версий
Ansible был на одном проекте: были описаны функции в скриптах, которые вызывались с параметрами из TeamCity джоб

56. Какие есть способы автоматизации развертывания Kubernetes?
Helm
