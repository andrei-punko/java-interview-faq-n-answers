
1. Иерархия коллекций в java?
?

2. Как работает Hashtable?
Hashtable - это потокобезопасный ассоциативный список.
Методы помечены как synchronized, т.е. при добавлении/извлечении элемента блокируется вся коллекция, что не оптимально.

3. Как работает ConcurrentHashMap?
https://stackoverflow.com/questions/12646404/concurrenthashmap-and-hashtable-in-java
= Hashtable is belongs to the Collection framework; ConcurrentHashMap belongs to the Executor framework.
= Hashtable uses _single lock_ for whole data. ConcurrentHashMap uses _multiple locks_ on segment level (16 by default) instead of object level i.e. whole Map.
= ConcurrentHashMap locking is applied only for updates. In case of retrievals, it allows full concurrency, retrievals reflect the results of the most recently completed update operations. So reads can happen very fast while writes are done with a lock.
= ConcurrentHashMap doesn't throw a ConcurrentModificationException if one thread tries to modify it while another is iterating over it and does not allow null values.
= ConcurrentHashMap returns Iterator, which fails-safe (i.e. iterator will make a copy of the internal data structure) on concurrent modification.
= ConcurrentHashMap uses a database shards logic (Segment<K, V>[] segments) is known as Concurrency-Level, i.e. divides the data into shards(segments) then puts locks on each shard (segment) instead of putting a single lock for whole data (Map). The default value is 16.

4. Как работает HashMap?
Вычисляем хэшкод, остаток от деления его на кол-во бакетов дает номер бакета.
В каждом бакете односвязный список, в него добавляется entry, содержащая ключ+значение.
Начиная с Java 8 - после добавления 8го элемента в этот бакет - связный список перестраивается в красно-черное дерево.
Красно-чёрное дерево - самобалансирующееся двоичное дерево поиска, гарантирующее логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного атрибута узла дерева — «цвета».
As of Java 8 (see JEP 180), the data structure in which the values inside one bucket are stored is changed from a list to a balanced tree if a bucket contains 8 or more values, and it's changed back to a list if, at some point, only 6 values are left in the bucket. This improves the performance to be O(log n).

5. Можно ли потерять элемент в HashMap?
Если метод hashCode так написан, что хэш ключа меняется, то можем действительно потерять объект в HashMap

6. Какой тип классов ты бы использовал для ключа HashMap?
Immutable класс (например String)

7. Как использовать свой класс в качестве ключа? Что если в этом классе есть поле коллекции (т.е. класс не до конца иммутабельный)?
Сделать свой класс immutable.
Если в классе есть поле коллекции - возвращать unmodifiable коллекцию в геттере.

8. Какие использовал коллекции из Concurrent пакета?
LinkedBlockingQueue - в Java-лабе для коннекшн-пула
ConcurrentHashMap - для получения конкурентного мэпа
AtomicInteger - для конкурентного подсчета кол-ва событий
CopyOnWriteArrayList - thread-safe variant of ArrayList

9. Расскажи про Java Memory Model?
11. Как устроена память в Java?
Отвечено в "Ответы 4 - Вопрос 1,2"

10. Есть 2 банковских аккаунта. Мы с одного хотим перевести деньги на другой. Из двух потоков в разном порядке захватываем мониторы этих аккаунтов (в первом потоке 
захватим монитор первого аккаунта и затем второго, а во втором потоке наоборот). Какая здесь есть проблема? Способы решить возникающий deadlock?
https://habr.com/ru/company/nordavind/blog/176541/
Видна проблема потенциального дедлока.
Решение - соблюдать два следующих правила:
= Первое правило: всегда отпускайте захваченные мьютексы в обратном захвату порядке, т.е. руководствуйтесь логикой «первый захвачен – последний отпущен».
= Второе правило: всегда соблюдайте один и тот же порядок захвата мьютексов в разных потоках.
Если вы в одном потоке захватываете мьютекс 1, а затем мьютекс 2, то недопустимо захватывать их в ином порядке в другом потоке.

12. Какие есть виды сборщиков мусора?
https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
= Serial
The serial collector is the default for client style machines in Java SE 5 and 6. With the serial collector, both minor and major garbage collections are done serially (using a single virtual CPU). In addition, it uses a mark-compact collection method. This method moves older memory to the beginning of the heap so that new memory allocations are made into a single continuous chunk of memory at the end of the heap. This compacting of memory makes it faster to allocate new chunks of memory to the heap.

= Parallel
The parallel garbage collector uses multiple threads to perform the young genertion garbage collection. By default on a host with N CPUs, the parallel garbage collector uses N garbage collector threads in the collection. The number of garbage collector threads can be controlled with command-line options:
-XX:ParallelGCThreads=<desired number>
On a host with a single CPU the default garbage collector is used even if the parallel garbage collector has been requested. On a host with two CPUs the parallel garbage collector generally performs as well as the default garbage collector and a reduction in the young generationgarbage collector pause times can be expected on hosts with more than two CPUs. The Parallel GC comes in two flavors.

= Concurent Mark Sweep (CMS)
The Concurrent Mark Sweep (CMS) collector (also referred to as the concurrent low pause collector) collects the tenured generation. It attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. Normally the concurrent low pause collector does not copy or compact the live objects. A garbage collection is done without moving the live objects. If fragmentation becomes a problem, allocate a larger heap.
Note: CMS collector on young generation uses the same algorithm as that of the parallel collector.

= Garbage-First (G1)
The Garbage First or G1 garbage collector is available in Java 7 and is designed to be the long term replacement for the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector that has quite a different layout from the other garbage collectors described previously. However, detailed discussion is beyond the scope of this OBE.

См. также ответ на вопрос "Как работает Garbage Collector в java?" в https://andrei-punko.github.io/java-interview-faq-n-answers

13. Какие есть способы инъекции бина?
Отвечено в "Ответы 4 - Вопрос 10"

14. Преимущества @Autowired в конструктор?
Если одного из бинов для инжекта нету - приложение упадет при поднятии контекста, на старте, а не потом, позже, когда дернут нужную операцию и этот бин понадобится.
Такая архитектура позволяет устранять ошибки на ранней стадии.

15. Всегда ли отрабатывает @PostConstruct?
Метод, аннотированный @PostConstruct, вызывается после вызова конструктора и инъекции зависимостей, перед вызовом метода init().

Оказывается, есть такая проблема:
https://answacode.com/questions/48380553/vesennyaya-zagruzka-postconstruct-ne-vyzyvaetsya-na-component
Из-за новой модульной системы в Java9 есть проблема например в SpringBoot-1.5.9, поскольку класс аннотации @PostConstruct не находится в пути к классам. Есть несколько способов решить эту проблему:
= запустите приложение на Java8.
Или, если используется все же Java9:
= добавить зависимость javax.annotation:javax.annotation-api к POM или
= обновить до более новой Spring-Boot версии 2.0.0+, которая включает эту зависимость

16. Spring Cloud. Какие компоненты есть у Spring Cloud?
Eureka - service discovery
Ribbon - client-side load balancer
Hystrix - circuit breaker
Feign - declarative REST client, instead of Spring RestTemplate
Zuul - JVM-based router and server side load balancer
Config - configuration management of distributed system
Bus - uses lightweight message broker to link distributed system nodes. The primary usage is to broadcast configuration changes or other management information
Stream - framework built on top of Spring Boot and Spring Integration that helps in creating event-driven or message-driven microservices
Sleuth - provides Spring Boot auto-configuration for distributed tracing

17. Работал ли с ELK стэком?
да

18. Оркестраторы?
https://mcs.mail.ru/blog/what-are-container-orchestration-systems
Задачи оркестраторов контейнеров:
= Подготовка инфраструктуры и развертывание.
Это установка приложения и его зависимостей на сервер, включая подготовку этого сервера — установку библиотек, служб и т.д.

= Конфигурация и планирование
Это часть подготовки сервера, а именно его настройка с помощью специальных программ-планировщиков. Их применяют не только для микросервисных приложений, но и для монолитных. Инструменты управления конфигурацией обычно используют «факты», чтобы убедиться в достоверности данных о сервере: например, «убедитесь, что /etc/my.cnf содержит то-то» или «NGinX должен работать со следующими файлами конфигурации». Оркестраторы содержат в себе такие планировщики, их не надо ставить отдельно.

= Распределение ресурсов
Для развертывания приложения в продакшен-кластере требуется выделить вычислительные ресурсы сервера для различных процессов: это объемы памяти и CPU. Устанавливаются запрашиваемые и предельные параметры, правила при достижении контейнерами ресурсных лимитов, различные ограничения. Это важно для поддержания приложения в рабочем состоянии и сведения затрат к минимуму.

= Масштабирование контейнеров на основе рабочих нагрузок
Простой излишних ресурсов приводит к издержкам, а недостаток — к нестабильной работе приложения. Регулировать объемы используемых ресурсов позволяет масштабирование, основанное на анализе нагрузок, которое может быть ручным или автоматизированным.

= Балансировка нагрузки
Автоматический анализ и распределение рабочих нагрузок на сервер целиком и контейнеры в частности. Балансировка оптимизирует использование ресурсов, увеличивает пропускную способность каналов связи, минимизирует время отклика и помогает избежать перегрузки отдельных ресурсов.

= Маршрутизация трафика
Чтобы приложение было доступно из интернета, нужно настроить правильное распределение трафика из внешней сети по контейнерам и нужным сервисам.

= Мониторинг состояния контейнеров
Эта функция позволяет видеть, какие контейнеры и их образы запущены и где, какие команды используются в контейнерах, какие контейнеры потребляют слишком много ресурсов и почему. Автоматический аудит журнала ошибок позволяет вовремя устранять неполадки.

= Обеспечение безопасного взаимодействия между контейнерами
На основе непрерывной оценки кластеров, узлов и реестра контейнеров предоставляются данные о неверных конфигурациях и других уязвимостях, которые могут представлять угрозу, а также рекомендации по устранению выявленных угроз.

Примеры систем оркестрации контейнеров:
= Kubernetes. Портативная платформа с открытым исходным кодом, считается отраслевым стандартом. Поддерживает и декларативную конфигурацию объектов, и автоматизацию. Можно автоматизировать масштабирование, развертывание с помощью шаблонов и управление рабочей нагрузкой и сервисами контейнеров.

= OpenShift Container Platform. Платформа корпоративного уровня в формате PaaS для разработки, развертывания и управления не только контейнерными, но и классическими приложениями и их компонентами в режиме самообслуживания. Позволяет автоматизировать их в физических, виртуальных и общедоступных, частных и гибридных облачных средах.

= Docker Swarm. Это "родная", базовая система кластеризации и оркестровки контейнеров Docker. Использует декларативную модель. Взаимодействие с кластером происходит через команды Docker, а управление действиями — через менеджер Swarm.

19. Разница аннотаций @SpringBootTest и JUnit?
The @SpringBootTest annotation is useful when we need to bootstrap the entire container. The annotation works by creating the ApplicationContext that will be utilized in our tests.
Аннотации JUnit тестируют один класс в изоляции

20. Что такое пирамида тестирования?
https://dou.ua/lenta/columns/testing-in-jiji/
Пирамида тестирования — один из способов обеспечения качества ПО, визуализация, которая помогает группировать тесты по типу их назначения.
Чем выше мы будем подниматься по пирамиде, тем выше комплексность, цена и хрупкость тестов.

= Первый (нижний) уровень: unit-тесты
В основе пирамиды лежат маленькие, дешевые и быстрые unit-тесты. За их написание и поддержку отвечает команда разработчиков. Весь старый и новый функционал должен быть подкреплен unit-тестами. Именно с их помощью можно быстро и комплексно проверить стабильность приложения.

= Второй уровень: интеграционные тесты
Суть этого процесса в объединении программных модулей в группы и их последующее тестирование. Проще говоря, это проверка бизнес-логики без использования UI. Пишут разработчики либо QA

= Третий уровень: тесты пользовательского функционала (end-to-end / functional tests)
Здесь количество тестов должно быть наименьшим. Воссоздавая пользовательские сценарии, мы проверяем приложения на стабильность и работоспособность. На этом уровне тесты самые хрупкие.

21. Зачем нужны разные виды тестов?
Тесты вообще нужны для
= проверки работоспособности: при добавлении нового кода - приложение работает как ожидалось
= фиксации рабочего состояния: при изменении старого кода - быть уверенным в том, что переходим из рабочего состояния в рабочее
Разные виды тестов обеспечивают разную гранулярность тестируемых блоков (в крупную/мелкую клетку) и позволяют лучше и быстрее опеределить, что именно и где сломалось.

22. Kafka, consumer/producer?
?
