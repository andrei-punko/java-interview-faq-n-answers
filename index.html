<!--According to https://getbootstrap.com/docs/5.0/getting-started/introduction/-->
<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

    <title>Java interview questions and answers</title>
</head>
<body>

<div class="container">
    <h1>
        Java interview questions and answers
    </h1>
    <hr/>
    
<p align="justify">
<b>Links</b></br>
<a href="http://javamex.com">http://javamex.com</a></br>
<a href="http://javarevisited.blogspot.com">http://javarevisited.blogspot.com</a></br>
</p>
<p align="justify">
<b>Исключения, роль наследования в обработке исключений. Что знаешь о try, final/finally/finalize. Секция throws в сигнатуре метода</b></br>
Ключевое слово final означает, что final-класс не может быть расширен, метод – переопределен, значение переменной – изменено.</br>
В блок try помещается критический блок кода, который может бросать исключения. Обработка исключений ведется в блоке catch. Блок finally выполняется всегда, кроме случая потоков-демонов и вызова System.exit(0).</br>
Инструкция throws в сигнатуре метода означает, что метод может бросить указанное исключение. Тот, кто вызывает метод должен обработать его или передать выше. Throws в классах-потомках – см. п.Полиморфизм.</br>
При перечислении блоков catch вначале следует указывать исключения-потомки, потом – предки. В обратном случае будет обработано исключение более общего класса и следующий блок catch не вызовется.</br>
Метод finalize() вызывается сборщиком мусора до освобождения памяти, занимаемой объектом. Это означает, что неизвестно, когда объект будет финализирован. Поэтому надо избегать освобождать в нем такие ресурсы, как дескрипторы файлов, сокеты, соединения с БД и т.д., т.к. Java имеет конечное кол-во таких ресурсов и неизвестно, когда сборщик освободит эти ресурсы вызовом finalize-метода.</br>
</p>
<p align="justify">
<b>Назвать и описать J2EE-паттерны (Factory, Builder, Command, MVC, Front Controller, Controller, Decorator, DTO, DAO и т.д.). Написать singleton.</b></br>
<b>Fundamental patterns:</b></br>
Delegation (Делегирование) - объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.</br>
Functional design (Функциональный дизайн) - гарантирует, что каждый модуль компьютерной программы имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие части программы.</br>
Immutable (Неизменяемый) – объект, который не может быть изменён после своего создания.</br>
Interface (Интерфейс) - общий метод для структурирования компьютерных программ для того, чтобы их было проще понять.</br>
</p>
<p align="justify">
<b>Creational (порождающие) patterns:</b></br>
Abstract Factory (абстрактная фабрика) – класс, который представляет интерфейс для создания компонентов системы.</br>
Builder (строитель) – класс, который представляет интерфейс для создания сложного объекта.</br>
Factory method (фабричный метод) – определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанциировать.</br>
Lazy initialization (отложенная инициализация) – объект, инициализируемый во время первого обращения к нему.</br>
Object pool (объектный пул) – класс, который представляет собой интерфейс для работы с набором инициализированных и готовых к использованию объектов.</br>
Singleton (одиночка) – класс, который может иметь только один экземпляр.</br>
</p>
<p align="justify">
<b>Structural (структурные) patterns:</b></br>
Adapter/Wrapper (Адаптер) – Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.</br>
Bridge (Мост) - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.</br>
Composite (Компоновщик) - Объект, который объединяет в себе объекты, подобные ему самому (объект может быть представлен одиночным объектом или набором (коллекцией) объектов).</br>
Decorator (Декоратор) - добавление/ограничение функциональности объекта во время выполнения, без наследования (наследование добавляет функциональность к классам во время компиляции). Этот паттерн реализуют классы пакета java.io.*. Пример:</br>
File file = new File(“fname”);</br>
FileInputStream fis = new FileInputStream(file);</br>
BufferedInputStream fis = new BufferedInputStream(fis);</br>
Facade (Фасад) – объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.</br>
Flyweight (Приспособленец) – объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым. Цель – оптимизация работы с памятью путем предотвращения создания экземпляров эл-тов, имеющих общую сущность. Св-ва приспособленца делятся на внешние и внутренние; внутренние – всегда неизменны, внешние могут отличаться в зависимости от места и контекста применения и должны быть вынесены за пределы приспособленца. Дополняет Factory, которая создает новый объект только, если нет уже созданного с нужными параметрами. Пример: String.</br>
Proxy (Заместитель) - объект, который является посредником между двумя другими объектами, и который реализовывает/ограничивает доступ к объекту, к которому обращаются через него.</br>
</p>
<p align="justify">
<b>Behavioral (поведенческие) patterns:</b></br>
Command (Команда) - представляет действие. Объект команды заключает в себе само действие и его параметры.</br>
Iterator/Cursor (Итератор) – поведенческий паттерн, обеспечивает путь получения эл-тов коллекции последовательно без открытия ее внутреннего представления.</br>
Memento/Token (Хранитель) - позволяет не нарушая инкапсуляцию зафиксировать и сохранить внутреннее состояния объекта так, чтобы позднее восстановить его в этом состоянии.</br>
Null object – предотвращает нулевые указатели, предоставляя объект “по умолчанию”.</br>
Observer (Наблюдатель) - определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.</br>
Reactor (Реактор) – демультиплексирует сообщения, разделяя один поток сообщений на несколько потоков, и передает их обработчиками. Похож на Observer (Publisher) паттерн, но у того только один источник сообщений, тогда как реактор перехватывает сообщения от нескольких источников.</br>
Chain of responsibility (цепочка обязанностей) – сообщения в системе обрабатываются по схеме “обработай сам, либо перешли другому”; в системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа.</br>
Mediator (Посредник) – обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга (частный случай Mediator-а - Front Controller – обеспечивает централизованную входную точку для обработки запросов).</br>
</p>
<p align="justify">
<b>Реализация Singleton:</b></br>
1.Неленивый Singleton</br>
Public class Singleton {		// Static field</br>
    public static final Singleton INSTANCE = new Singleton();</br>
}</br>
</p>
<p align="justify">
Public enum Singleton {		// Enum Singleton</br>
    INSTANCE;</br>
}</br>
</p>
<p align="justify">
2.Ленивый Singleton</br>
Public class Singleton {		// Synchronized Accessor</br>
    private static Singleton instance;</br>
</p>
<p align="justify">
    public static synchronized Singleton getInstance() {</br>
        if (instance == null) {</br>
            instance = new Singleton();</br>
        }</br>
        return instance;</br>
    }</br>
}</br>
</p>
<p align="justify">
Public class Singleton {		// Double Checked Locking & volatile</br>
        private static volatile Singleton instance;</br>
</p>
<p align="justify">
        public static Singleton getInstance() {</br>
        Singleton localInstance = instance;</br>
        if (localInstance == null) {</br>
            synchronized (Singleton.class) {</br>
                localInstance = instance;</br>
                if (localInstance == null) {</br>
                    instance = localInstance = new Singleton();</br>
                }</br>
            }</br>
        }</br>
        return localInstance;</br>
    }</br>
}</br>
</p>
<p align="justify">
Public class Singleton {		// On Demand Holder idiom</br>
    public static class SingletonHolder {</br>
        public static final Singleton HOLDER_INSTANCE = new Singleton();</br>
    }</br>
</p>
<p align="justify">
    public static Singleton getInstance() {</br>
        return SingletonHolder.HOLDER_INSTANCE;</br>
    }</br>
}</br>
<b>Советы по использованию</b></br>
1) Использовать нормальную (не ленивую) инициализацию везде где это возможно (п.2)</br>
2) Для статических полей использовать On Demand Holder idom (п.2.3)</br>
3) Для простых полей использовать Double Chedked Lock & volatile idom (п.2.2)</br>
4) Во всех остальных случаях использовать Syncronized accessor (п.2.1)</br>
</p>
<p align="justify">
<b>Struts.</b></br>
Struts framework – среда для разработки Java EE web-приложений с помощью технологий Java Servlet и JSP. Способствует разработке приложений с архитектурой, соответствующей паттерну MVC, Model2. Включает следующие основные ф-ции:</br>
1. Controller servlet, который координирует запросы к соответствующим Action классам, созданным разработчиком. Те обращаются к модели; модель возвращает строку “ActionForward”, сообщая контроллеру, какую страницу отправить клиенту. Класс ActionForm помогает передавать данные между моделью и представлением.</br>
2. Библиотеки JSP-тегов и их поддержка в сервлете-контроллере для создания интерактивных приложений, основанных на веб-формах</br>
3. Вспомогательные классы для парсинга XML, автоматического наполнения JavaBeans, i18n сообщений, валидации входных данных, создания шаблонов (tiles)</br>
Разработчик пишет код модели (представляющей обычно набор JavaBeans) и создает конф. файл struts-config.xml, который связывает воедино модель, представление и контроллер.</br>
</p>
<p align="justify">
<b>JSF. Чем JSF лучше Struts?</b></br>
JSF – фреймворк для веб-приложений, написанный на Java. Служит для того, чтобы облегчить разработку пользовательских интерфейсов для Java EE приложений. В отличие от прочих MVC фреймворков, управляемых запросами, JSF основывается на использовании компонентов. Для отображения используются JSP, Facelets.</br>
JSF включает:</br>
• Набор API для представления компонент пользовательского интерфейса и управления их состоянием, обработкой событий и валидацией вводимой информации, определения навигации, а также поддержку i18n и доступности</br>
• Специальная библиотека JSP тегов для выражения интерфейса JSF на JSP странице</br>
Технология JSF усиливает существующие концепции пользовательского интерфейса и концепции web-уровня без привязки разработчика к конкретному языку разметки, протоколу или клиентскому устр-ву. Возможно настраивать рендеринг JSF-компонент на различных клиентских устр-вах (библиотека JSP-тегов для рендеринга на HTML-клиенте).</br>
Чем JSF лучше Struts для меня: произвожу описание только вида и модели, без контроллера. Автоматически: данные отображаются из вида в модель, происходит валидация. Возможно визуальная настройка переходов между страницами вида. Можно использовать шаблоны, вкладывая их один в другой.</br>
</p>
<p align="justify">
<b>Spring. Spring IoC. AoP.</b></br>
= Spring Framework – универсальный фреймворк с открытым исходным кодом на Java. Может быть рассмотрен как коллекция меньших фреймворков или фреймворков во фреймворке. Большинство из них может работать независимо друг от друга. Spring делится на структурные эл-ты:</br>
• Inversion of Control контейнер: конфигурирование компонент приложений и управление жизненным циклом Java-объектов</br>
• Фреймворк аспектно-ориентированного программирования: работает с функциональностью, которая не может быть реализована возможностями объектно-ориентированного программирования на Java без потерь</br>
• Фреймворк доступа к данным: работает с системами управления реляционными БД на Java платформе используя JDBC и Object-relational mapping средства обеспечивая решения задач, которые повторяются в большом числе Java-based environments</br>
• Фреймворк управления транзакциями: координация различных API управления транзакциями и инструментарий настраиваемого управления транзакциями для объектов Java</br>
• Фреймворк MVC: каркас, основанный на HTTP и сервлетах предоставляющий множество возможностей для расширения и настройки (customization)</br>
• Фреймворк удалённого доступа: конфигурируемая передача Java-объектов через сеть в стиле RPC, поддерживающая RMI, CORBA, HTTP-based протоколы, включая web-сервисы (SOAP)</br>
• Фреймворк аутентификации и авторизации</br>
• Фреймворк удалённого управления: конфигурируемое представление и управление Java объектами для локальной или удалённой конфигурации с помощью JMX</br>
• Фреймворк работы с сообщениями: конфигурируемая регистрация объектов-слушателей сообщений для прозрачной обработки сообщений из очереди сообщений с помощью JMS, улучшенная отправка сообщений по стандарту JMS API</br>
• Тестирование: каркас, поддерживающий классы для написания модульных и интеграционных тестов</br>
Центральной частью Spring является IoC контейнер, предоставляющий ср-ва конфигурирования и управления объектами Java при помощи рефлексии. Контейнер отвечает за управление жизненным циклом объекта: создание, вызов методов инициализации и конфигурирование объектов путем связывания между собой.</br>
Объекты, создававемые контейнером, называются Beans. Обычно конфигурирование контейнера осуществляется посредством XML-файлов, содержащих определение Bean-ов и предоставляющих информацию, необходимую для создания Bean-ов. Объекты могут быть получены либо с помощью поиска зависимости, либо внедрения зависимости.</br>
Поиск зависимости – шаблон проектирования, когда вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определенным именем или определенного типа.</br>
Внедрение зависимости (Dependency injection) - шаблон проектирования, когда контейнер передает экземпляры объектов по их имени другим объектам либо с помощью конструктора, либо свойства, либо фабричного метода. Является специфичной формой обращения контроля (IoC), где изменение порядка связи является путем получения необходимой зависимости.</br>
</p>
<p align="justify">
= AoP (АОП, аспектно-ориентированно программирование) – парадигма программирования, основанная на идее разделения функциональности для улучшения разбиения программы на модули.</br>
Аспект – модуль или класс, реализующий сквозную функциональность.</br>
Сквозная функциональность – функциональность, которую нельзя выделить в отдельные сущности, ее реализация рассыпана по различным модулям программы. СФ приводит к рассредоточенному и запутанному коду, сложному для понимания и сопровождения.</br>
Примеры сквозной функциональности: ведение лога, обработка ошибок, трассировка, авторизация. Для программы, написанное в парадигме ООП, любая функциональность, по которой не была проведена декомпозиция, является сквозной.</br>
</p>
<p align="justify">
<b>Что такое сервер приложений? Что такое веб-сервер, в чём его отличие от сервера приложений? Привести примеры веб-сервера и сервера приложений. Минимальные требования для веб-приложения.</b></br>
Сервер – ПО, выполняющееся на некотором аппаратном обеспечении, и исполняющее сервисные (т.е. обслуживающие) функции по запросу клиента, предоставляя ему доступ к определенным ресурсам.</br>
Веб-сервер – сервер, принимающий HTTP-запросы от клиентов (обычно веб-браузеров), и выдающий им HTTP-ответы. Веб-сервером могут называть как ПО с такими функциями, так и сам компьютер, на котором оно выполняется.</br>
Примеры веб-серверов: Apache, IIS, nginx, lighttpd.</br>
Веб-приложение – клиент-серверное приложение, в котором клиент – браузер, а сервер – веб-сервер. Клиенты не зависят от ОС пользователя, поэтому веб-приложения являются межплатформенными сервисами. Состоит из клиентской и серверной части.</br>
Минимальные требования для веб-приложения:</br>
• веб-сервер с запущенным на нем сервлетом</br>
• mapping в конфигурационном файле сервлета, чтобы клиент мог получить доступ к сервлету</br>
• наличие браузера у клиента</br>
Сервер приложений – программная платформа (software framework), предназначенная для исполнения процедур (программ, скриптов), которые поддерживают построение приложений. Действует как набор компонентов, доступных разработчику через API, который определен самой платформой. Термин сервер приложений часто используется для веб-серверов, которые поддерживают Java EE, хотя он не ограничивается только Java.</br>
Преимущества сервера приложений:</br>
• Целостность – гарантированные обновления и улучшения приложений для всех пользователей</br>
• Централизованная настройка и управление – изменения настроек (сервера БД или системных) могут производиться централизованно</br>
• Безопасность – можно управлять доступом к данным и частям приложений</br>
• Поддержка транзакций – единицы активности, во время которой большое число изменений ресурсов может быть выполнено атомарно</br>
Современные серверы приложений не только генерируют страницы, но и выполняют такие сервисы, как кластеризация, отказоустойчивость, балансировка нагрузки, позволяя разработчикам сфокусироваться на реализации бизнес-логики.</br>
Термин сервер приложений обычно относится к Java-серверам приложений. В этом случае сервер приложений ведет себя как расширенная виртуальная машина для запуска приложений, прозрачно управляя соединениями с БД с одной стороны и соединениями с веб-клиентом с другой.</br>
Примеры серверов приложений: GlassFish, WebSphere, JBoss, Zope.</br>
</p>
<p align="justify">
<b>Контейнер сервлетов. Сервлет, его методы, жизненный цикл.</b></br>
Контейнер сервлетов (Web-контейнер) (КС) – компонент веб-сервера для взаимодействия с сервлетами. КС отвечает за управление жизненным циклом сервлетов, мэппингом URL к конкретному сервлету, идентификацию и авторизацию клиента, запрашивающего URL, организацию сессии для клиента. Может работать как самостоятельный веб-сервер или интегрироваться в Java EE сервер приложений.</br>
Примеры КС: Apache Tomcat, JBoss, GlassFish, WebSphere.</br>
Сервлет – Java-программа, выполняющаяся на стороне сервера и расширяющая его функциональные возможности. Взаимодействует с клиентами посредством принципа запрос-ответ. Реализует Servlet интерфейс, который определяет методы жизненного цикла.</br>
Жизненный цикл сервлета состоит из следующих шагов:</br>
1. В случае отсутствия сервлета в контейнере:</br>
• Класс сервлета загружается контейнером</br>
• Контейнер создает экземпляр класса сервлета</br>
• Контейнер вызывает метод init(). Он инициализирует сервлет и вызывается в первую очередь, до того, как сервлет сможет обслуживать запросы. За весь жизненный цикл метод init() вызывается только однажды</br>
2. Обслуживание клиентского запроса. Каждый запрос обрабатывается в своем отдельном потоке. Контейнер вызывает метод service() для каждого запроса. Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса (doGet(), doPost(), doPut(), doDelete() и т.д.). Разработчик сервлета должен предоставить реализацию для этих методов. Если поступил запрос, метод для которого не реализован, вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.</br>
3. В случае, если контейнеру необходимо удалить сервлет, он вызывает метод destroy(). Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.</br>
API сервлета определяют взаимодействие КС и сервлета, содержатся в Java пакете javax.servlet. Классы для HTTP – в пакете javax.servlet.http.</br>
</p>
<p align="justify">
<b>Отличие getParameter от getAttribute в сервлете.</b></br>
GetParameter возвращает (в виде String) значение параметра, который был отправлен HTML-формой или был включен в строку запроса. getAttribute возвращает Java-объект, который был сохранен в текущем контексте (по сути – в сессии).</br>
</p>
<p align="justify">
<b>Можно ли в web.xml определить сервлет без указания url паттерна и как к нему обратиться?</b></br>
В файле <Tomcat directory>/conf/web.xml можно раскомментировать invoker servlet, который может запускать анонимные сервлеты (mapping которых не указан). Синтаксис следующий:</br>
<a href="http://<host>:<port>/<appname>/servlet/<full qualified class name (т.е. пакет+имя.класса)>">http://<host>:<port>/<appname>/servlet/<full qualified class name (т.е. пакет+имя.класса)></a></br>
В данный момент invoker считается deprecated.</br>
</p>
<p align="justify">
<b>Что такое сессия?</b></br>
Сессия – информационный диалог между двумя и более коммуникационными устр-вами или компьютером и юзером. Длится какой-то промежуток времени. Могут отправляться сообщения в обоих направлениях. Чаще всего хотя бы одно из взаимодействующих устр-в сохраняет информацию о сессии, реже – взаимодействие состоит из независимых request-ов с response-ами.</br>
Для сервлета сессия – файл, создаваемый на сервере, куда сохраняются данные, присланные пользователем. Клиенту выдается “ключ сессии” (Session ID) – уникальный указатель на этот файл.</br>
</p>
<p align="justify">
<b>Что нужно сделать пользователю, чтобы зайти на сайт и что происходит при этом?</b></br>
Пользователь должен иметь подключение к Интернету, браузер и знать url сайта. При этом прописанные в его системе DNS преобразуют url в ip-адрес, к которому браузер и осуществляет запрос. DNS-сервер кэширует запросы. По заданному адресу должен располагаться веб-сервер, который передаст браузеру свою стартовую страницу.</br>
</p>
<p align="justify">
<b>Что нужно написать в браузерной строке, чтобы обратиться к сервлету? Как обратиться к конкретному сервлету? Можно ли из браузерной строки напрямую вызвать метод сервлета?</b></br>
Для обращения к сервлету используется запись: http://<host>:<port>/<context path>/<servlet name (in web.xml)>. Для обращения к конкретному сервлету надо использовать соответствующее имя в web.xml.</br>
Напрямую вызвать метод сервлета нельзя; контейнер вызывает метод service() для каждого запроса. Метод service() определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса (doGet(), doPost(), doPut(), doDelete() и т.д.).</br>
</p>
<p align="justify">
<b>HTTP. Описать структуру HTTP-протокола.</b></br>
HTTP – протокол прикладного уровня передачи данных. Его основой является технология “клиент-сервер”, т.е. предполагается существования потребителей (клиентов) и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом. Используется в качестве “транспорта” для других протоколов прикладного уровня (SOAP, XML-RPC). Основным объектом манипуляции в HTTP является ресурс, на который указывает URI в запросе клиента. Ресурсами могут быть файлы, логические объекты или что-то абстрактное. Особенностью является возможность указания в запросе и ответе способа представления одного и того же ресурса по различным параметрам (формату, кодировке, языку) (указывается в заголовке HTTP). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться двоичными данными, хотя сам протокол текстовый. Не поддерживает сохранение состояния между парами “запрос-ответ”. Состояние может сохраняться в куки на стороне клиента и сессии на стороне сервера.</br>
Достоинства протокола:</br>
• Простота в реализации</br>
• Расширяемость благодаря внедерению собственных заголовков. Совместимость с другими клиентами и серверами при этом сохраняется: они будут просто игнорировать неизвестные им заголовки</br>
• Распостраненность: поддержка протокола в качестве клиента многими программами, выбор среди хостинговых компаний с серверами HTTP</br>
Недостатки протокола:</br>
• Большой размер сообщений по сравнению с передачей двоичных данных</br>
• Отсутствуют в явном виде ср-ва навигации по ресурсам сервера (например: нельзя запросить список доступных файлов)</br>
• Нет поддержки распределенности</br>
   Каждое HTTP-сообщение состоит из трех частей, которые передаются в указанном порядке:</br>
1. Стартовая строка (Starting line) – определяет тип сообщения. Содержит метод (указывает операцию над ресурсом), URI, версию протокола</br>
2. Заголовки (Headers) – характеризуют тело сообщения, параметры передачи и прочие сведения (содержат строки с парами параметр:значение)</br>
3. Тело сообщения (Message Body) – непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой. Тело может отсутствовать.</br>
HTTPS – расширение протокола HTTP, поддерживающее шифрование. Данные “упаковываются” в криптографический протокол SSL или TLS.</br>
Для HTTP обычно используются TCP-порты 80 или 8080, а для HTTPS - 443.</br>
</p>
<p align="justify">
<b>Зачем нужен объект request?</b></br>
Контейнер сервлетов создает объект request класса HttpServletRequest и передает его как аргумент в методы сервлета (doGet, doPost и т.д.). Объект request содержит информацию запроса для HTTP-сервлета (пары “ключ-значение” параметров, заголовки запросов, Cookies, URL запроса и т.д.).</br>
</p>
<p align="justify">
<b>Lifecycle of JSP. Является ли jsp сервлетом? Области видимости переменных в JSP.</b></br>
JSP – технология, позволяющая создавать содержимое со статическими и динамическими компонентами. Могут использоваться библиотеки JSP тегов, а также EL (Expression Language), для внедрения Java-кода в статическое содержимое JSP-страниц. Отличие между сервлетом и JSP в том, что сервлет обычно внедряет HTML в Java-код, а JSP – наоборот.</br>
В JSP могут использоваться: HTML, комментарии (игнорируются транслятором), скриптовые элементы (Java-код, который впоследствии станет частью конечного сервлета), директивы (начинаются с <%@, позволяют управлять структурой сервлета), действия (для задания используемых beans и контроля над поведением движка сервлета).</br>
Весь код страницы компилируется в java-код сервлета JSP-компилятором Jasper, а затем транслируется в байт-код JVM (потом исполняется - интерпретатором) (т.е. JSP является сервлетом). JSP-компилятор обычно является составной частью сервера приложений и запускается автоматически при первом доступе к JSP, но страницы также могут быть прекомпилированы для улучшения производительности или отслеживания ошибок.</br>
Есть 4 области видимости JavaBean в JSP: page, request, session, application. Без явного указания используется scope=”page”.</br>
</p>
<p align="justify">
<b>Отличие jsp:include от директивы include.</b></br>
• Действие jsp:include вставляет содержимое файла при запросе JSP-страницы (поэтому во вставляемом файле исключается наличие кода JSP). Потеря эффективности, но преимущество в гибкости.</br>
Пример записи: <jsp:include page="relativeURL" [flush="true"]>. Необязательный аттрибут flush управляет (не)освобождением буфера выходного потока страницы JSP.</br>
• Директива include вставляет содержимое файла (текстового или JSP) на этапе трансляции. Процедура вставки происходит статически, т.е. текст включаемого файла добавляется к JSP. Если включаемый файл – JSP, его JSP-элементы будут транслироваться наряду с эл-тами исходного файла.</br>
Пример записи: <%@ include file="relativeURL" %></br>
В обоих случаях URL интерпретируется относительно страницы, на которой расположено действие/директива, но можно задать расположение относительно корня сервлета, добавив в начало URL символ “/”.</br>
</p>
<p align="justify">
<b>Чем отличаются методы POST и GET? Если не указать напрямую, какой из этих методов выполнится по умолчанию?</b></br>
Метод GET (он выполняется по умолчанию) передает всю информацию в заголовке запроса (через URL), а POST – внутри тела запроса. Заголовок запроса имеет ограничение на максимальный размер, соответственно, в GET ограничен объем передаваемых данных.</br>
В спецификации HTTP указано, что метод GET не должен иметь смысл действия, отличного от получения запрашиваемой информации (поэтому он называется «безопасным»). Для выполнения каких-либо операций, изменяющих данные на сервере, должен использоваться метод POST.</br>
Ответы на POST запросы никогда не кэшируются, на GET – кэшируются по умолчанию (может быть отключено изменением заголовка страницы ответа, посылаемого сервером).</br>
POST запрос может “симулировать” GET запрос, указывая параметры как в заголовке запроса, так и в теле.</br>
“Главное” отличие – GET не может передать файл, а POST – может.</br>
</p>
<p align="justify">
<b>У нас есть одна форма в ней 2 input поля и submit, как переслать первое поле методом POST, второе методом GET? Зачем это может понадобиться?</b></br>
См. ответ на предыдущий вопрос (о симуляции GET запроса). Это (наверное) может понадобиться, если после нажатия на submit новый url должен содержать значение поля, пересылаемого методом GET.</br>
</p>
<p align="justify">
<b>В чём различие forward и redirect? Что делает RequestDispatcher.include()?</b></br>
Пересылка (forward) осуществляется на стороне сервера, при этом новая страница обрабатывает тот же запрос, что и предыдущая. Браузер при этом не догадывается, что в процессе задействовано несколько страниц.</br>
Переадресация (redirect) означает, что первая страница требует от браузера сделать новый запрос к нужной странице. Поэтому URL в браузере будет заменен на новый.</br>
• Переадресация медленнее (т.к. браузер повторяет запрос)</br>
• Объекты, помещенные в контекст запроса, после переадресации становятся недоступными, т.к. создается новый запрос</br>
RequestDispatcher – инструмент для того, чтобы переслать запрос другому ресурсу. Содержит только 2 метода: forward(request, response) – для перенаправления запроса, include(request, response) – для включения в результат работы текущего сервлета результата работы вызываемого сервлета.</br>
RequestDispatcher.include() включает в текущий сервлет статическое содержимое (HTML, JavaScript) каждый раз, когда сервлет обрабатывает запрос.</br>
</p>
<p align="justify">
<b>Что такое classpath? Если в classpath есть две одинаковые библиотеки (или разные версии одной библиотеки), объект класса из какой библиотеки создастся?</b></br>
Classpath – это переменная окружения; содержит пути к классам, jar-файлам.</br>
Если в classpath есть несколько одинаковых библиотек, создастся класс из библиотеки, объявленной первой.</br>
</p>
<p align="justify">
<b>Как скомпилировать и запустить класс, используя консоль?</b></br>
• <Путь_к_JDK>\bin\javac <Путь_к_java-классу>\<Имя класса>.java</br>
После этого в папке с java-файлом появится файл <Имя класса>.class</br>
Более подробно: <Путь_к_JDK>\bin\javac -d <Директория_build> -sourcepath <Список_директорий_через_;> <Путь_к_java-классу>\<Имя класса>.java</br>
• <Путь_к_JDK>\bin\java <Путь_к_java-классу>\<Имя класса></br>
Если путь к JDK прописан в classpath:</br>
• javac <Путь_к_java-классу>\<Имя класса>.java</br>
• java <Путь_к_java-классу>\<Имя класса></br>
</p>
<p align="justify">
<b>Какие различия в архитектуре, процессе компиляции исходного кода и запуска программ на java и c++? За счёт чего обеспечивается кроссплатформенность приложений на java?</b></br>
Исходный код транслируется в промежуточный байт-код, формат которого не зависит от архитектуры компьютера. Непосредственно во время работы программы для увеличения производительности байт-код компилируется JIT-компилятором в машинный код. Поэтому программа может выполняться на любых процессорах; для ее работы необходима только JVM (она интерпретирует байт-код). В отличие от С и С++ элементы спецификации Java не зависят от реализации: размеры основных типов данных и арифметические операции над ними строго определены.</br>
</p>
<p align="justify">
<b>Коллекции, их виды, основные интерфейсы. Особенности разных видов коллекций. Когда какие стоит применять? В частности: сравнить ArrayList и LinkedList, HashMap и Hashtable. Коллекции из пакета concurrent. Реализации коллекций.</b></br>
<a href="http://java.sun.com/docs/books/tutorial/collections/index.html">http://java.sun.com/docs/books/tutorial/collections/index.html</a></br>
<a href="http://habrahabr.ru/post/127864/">http://habrahabr.ru/post/127864/</a></br>
Collection, Set, List, Queue, Map, SortedSet, SortedMap - интерфейсы.</br>
Коллекция (К) представляет собой группу объектов, называемых ее элементами. Класс Collection является базовым для всех Java-коллекций. Перебирать элементы коллекции можно двумя способами:</br>
• при помощи конструкции for-each: for (Object o: collection) { ... }</br>
• при помощи итератора:</br>
Iterator it = collection.iterator;</br>
While(it.hasNext()) {</br>
Object o = it.next();</br>
...</br>
}</br>
Итератор кроме методов next и hasNext также имеет метод remove, который может быть вызван 1 раз при каждом next (несоблюдение этого условия приводит к исключению).</br>
Collection имеет методы: size, isEmpty, contains, add, remove.</br>
Операции над всей коллекцией сразу:</br>
• containsAll – возвращает true, если данная К содержит все эл-ты указанной К</br>
• addAll – добавляет все элементы указанной К к данной К</br>
• removeAll – удаляет из данной К все эл-ты, содержащиеся в указанной К</br>
• retainAll - удаляет из данной К все эл-ты, НЕ содержащиеся в указанной К</br>
• clear – удаляет все эл-ты К</br>
• перевод коллекции в массив:</br>
Object[] a = c.toArray();			//for Object type</br>
String[] a = c.toArray(new String[0]);	//for String type, for example</br>
</p>
<p align="justify">
<b>Виды коллекций:</b></br>
• Set (множество) – не может содержать одинаковых элементов. Интерфейс Set содержит только методы класса Collection и дополнительные ограничения, чтобы избегнуть дубликатов. Есть 3 реализации Set:</br>
	= HashSet, хранящий эл-ты в hashtable, что дает лучшую по производительности реализацию, но не гарантирует нужный порядок при итерации</br>
	= TreeSet, хранящий элементы в дереве; порядок элементов основывается на их значениях. Медленнее HashSet</br>
	= LinkedHashSet, реализующий hashtable с linkedlist, при этом порядок эл-тов основывается на порядке, в котором они добавлялись в множество. Помогает избежать хаотического порядка эл-тов, обеспечиваемого HashSet, чуть более высокой ценой</br>
• List (список) – упорядоченная коллекция (последовательность). Может содержать одинаковые эл-ты. Вдобавок к методам, унаследованным от Collection, List включает следующие операции:</br>
	= Позиционный поиск: get(index) и установка: set(index, element)</br>
	= Поиск элемента, возвращение индекса: indexOf, lastIndexOf</br>
	= Получение собственных итераторов, использующих преимущества “последовательной” природы списка: listIterator(), listIterator(index)</br>
	= Получение подсписка текущего списка: subList(from, to)</br>
Список обеспечивает кроме стандартного итератора свой собственный, расширенный итератор, который имеет дополнительные методы: hasPrevious, previous, nextIndex, previousIndex, set, add. Также возможно получить итератор уже установленный на указанный индекс.</br>
	Есть 2 реализации списка:</br>
	= ArrayList, обычно показывающий лучшую производительность</br>
	= LinkedList, дающий лучшую производительность при определенных условиях</br>
	= Vector – модифицированная, более ранняя реализация List. Имеет другие (более длинные) имена методов, некоторые методы отсутствуют. Потокобезопасен (обычные (не concurrent) коллекции - нет). Если не нужна потокобезопасность – рекомендуется использовать ArrayList, а не Vector</br>
		При добавлении новые эл-ты добавляются в конец списка.		</br>
• Queue (очередь) – содержит элементы в определенном порядке. Обычно – FIFO. Кроме методов Collection содержит новые методы:</br>
</p>
<p align="justify">
Операция: 				Insert (вставляет элемент в порядке, соответствующем типу очереди)</br>
Throws exception:		add(e)</br>
Return special value:	offer(e)</br>
</p>
<p align="justify">
Операция: 				Remove (возвращает и удаляет из начала очереди)</br>
Throws exception:		remove()</br>
Return special value:	poll()</br>
</p>
<p align="justify">
Операция: 				Examine (возвращает, но не удаляет из начала очереди)</br>
Throws exception:		element()</br>
Return special value:	peek()</br>
</p>
<p align="justify">
LinkedList реализует FIFO очередь.</br>
PriorityQueue упорядочивает элементы в соответствии с их значениями.</br>
• Map (карта) – объект, обеспечивающий мэпинг ключей их значениям. Ключи уникальны, не могут повторяться, в качестве ключей могут использоваться Immutable объекты. Методы интерфейса:</br>
	= Базовые операции: put, get, remove, containsKey, containsValue, size, isEmpty</br>
	= Операции со всей коллекцией сразу: putAll, clear</br>
	= Получение вида (view) коллекции: keySet, values, entrySet</br>
Реализации карт: HashMap, TreeMap, LinkedHashMap. Их поведение и производительность аналогичны HashSet, TreeSet, LinkedHashSet.</br>
Hashtable – потокобезопасная реализация Map.</br>
Отличия Map от HashTable:</br>
	= Map – интерфейс, HashTable - реализация</br>
	= Map обеспечивает получение вида (view) коллекции (см. выше)</br>
	= Map позволяет осуществлять итерацию по ключам, значениям или парам ключ-значение; Hashtable не поддерживает 3й вариант</br>
	= Hashtable содержит метод contains, который возвращает true, если Hashtable содержит данное значение (а не ключ). Map содержит 2 различных метода: containsKey и containsValue</br>
• SortedSet и SortedMap – множество и карта соответственно, отсортированные в соответствии с натуральным порядком значений эл-тов  или в соответствии с компаратором, передаваемым в SortedSet/SortedMap при создании</br>
Их реализации соответственно: TreeSet и TreeMap</br>
Класс Collections содержит статические методы для работы с коллекциями: swap, shuffle, min, max, sort, reverse и т.д. Сортировка выполняется для объектов, реализующих интерфейс Comparable или с передачей в sort компаратора, сравнивающего два эл-та этого типа.</br>
Коллекцию можно сделать синхронизированной при помощи методов класса Collections, например:</br>
Map myMap = Collections.synchronizedMap(myMap); //один lock на весь map</br>
Если класс содержит поле-коллекцию и для нее нужен getter, то возвращать лучше немодифицируемую копию, например: return Collections.unmodifiableSet(mySet).</br>
</p>
<p align="justify">
Коллекции concurrent позволяют потокозащищенно получить любое кол-во одновременных чтений и настраиваемое кол-во одновременных записей. Concurrent Collections содержатся в пакете java.util.concurrent. Существуют следующие интерфейсы:</br>
• BlockingQueue определяет FIFO структуру данных, которая обеспечивает операцию ожидания, пока очередь станет не пустой при получении эл-та и пока в очереди не появится место при добавлении эл-та в нее</br>
Реализации:</br>
ArrayBlockingQueue - блокирующая очередь (БО) на основе array,</br>
DelayQueue - БО, элементы которой могут быть получены по истечению задержки</br>
LinkedBlockingQueue,LinkedBlockingDeque - связанные блокирующие очередь и 2-стороння очередь</br>
PriorityBlockingQueue – БО с приоритетом</br>
SynchronousQueue – очередь, где каждый put должен подождать take и наоборот</br>
• ConcurrentMap – подинтерфейс Map, который определяет полезные atomic операции. Эти операции удаляют или заменяют пару ключ-значение, только если ключ присутствует, или добавляют пару ключ-значение, только если ключ отсутствует</br>
Реализации:</br>
ConcurrentHashMap – блокирующий HashMap</br>
ConcurrentSkipListMap – блокирующий TreeMap</br>
• ConcurrentNavigableMap – подинтерфейс ConcurrentMap</br>
ConcurrentSkipListMap (см. выше)</br>
</p>
<p align="justify">
<b>Области памяти виртуальной машины (куча, стек и т.д.). Какие области памяти использует java для размещения простых типов, объектов, функций и т.д.? </b></br>
Память JVM состоит из следующих сегментов:</br>
• Не-куча/стек (non-heap). Стек создается для каждого потока, здесь размещаются локальные переменные примитивных типов и аргументы (значения, переданные методам). Создается при старте JVM</br>
• Куча (heap). Здесь хранятся объекты и переменные примитивных типов, если они являются полями класса. Создается при старте JVM</br>
• Код самой JVM, ее внутренние структуры и т.д.</br>
Ответ на вопрос: функции хранятся в куче, а в стеке – стек их вызовов; простые типы и объекты хранятся в стеке, если являются локальными, или в куче в обратном случае.</br>
</p>
<p align="justify">
<b>Как работает Garbage Collector в java? Какие самые распространенные алгоритмы? Можно ли самому указать сборщику мусора, какой объект удалить из памяти?</b></br>
Работа сборщика мусора состоит из:</br>
• определения недостижимых объектов</br>
• собственно, сборки мусора</br>
Для определения недостижимых объектов может использоваться один из двух подходов:</br>
1. Алгоритм выставления флагов.</br>
Для каждого объекта хранится бит, указывающий на достижимость объекта. Изначально все объекты, кроме корневых, считаются недостижимыми. Рекурсивно просматриваются и помечаются как достижимые объекты еще не помеченные и до которых можно добраться из корневых объектов по ссылкам. Объекты с неустановленным битом достижимости считаются недостижимыми. Данный алгоритм гарантированно удаляет неиспользуемые объекты с циклическими ссылками.</br>
2. Алгоритм подсчета ссылок.</br>
Ведется просто подсчет ссылок на объекты. Без дополнительных уточнений этот алгоритм не удаляет объекты с циклическими ссылками.</br>
При сборке мусора используется одна из двух стратегий:</br>
1. Неперемещающий сборщик быстрее освобождает память (нужна только пометка соответствующих блоков, как свободных), но тратит больше времени на ее выделение (память фрагментирована).</br>
2. Перемещающий сборщик требует сравнительно больше времени при сборе мусора (тратится дополнительное время на дефрагментацию памяти и изменение всех ссылок на перемещаемые объекты), но перемещение позволяет использовать простой и быстрый алгоритм выделения памяти.</br>
Неперемещающий сборщик лучше работает с инородным кодом (не изменяет положение существующих объектов в памяти). Также для работы с инородным кодом используется pinning – явная блокировка объекта, запрещающая его перемещение во время сборки мусора.</br>
Практика показывает, что недавно созданные объекты чаще становятся недостижимыми, чем существующие длительное время. Поэтому, современные сборщики подразделяют все объекты на несколько поколений – серий объектов с близким временем существования. Как только память, выделенная одному из поколений, заканчивается, в этом поколении и во всех более «молодых» производится поиск недостижимых объектов. Все они удаляются, а оставшиеся переводятся в более «старое» поколение.</br>
Самому нельзя указать сборщику мусора, что надо удалить определенный объект из памяти, т.к. поведение сборщика недетерминировано.</br>
</p>
<p align="justify">
<b>Что такое поток? Какими способами можно создать поток, запустить его, остановить? Состояния потока. Как выполнить набор команд в отдельном потоке? Как остановить выполнение потока? Что лучше: наследоваться от Thread или реализовывать Runnable?</b></br>
	Термин поток может обозначать:</br>
• Экземпляр класса java.lang.Thread, являющийся обычным объектом</br>
• Поток выполнения – отдельный процесс, имеющий собственный стек вызовов. Поток выполнения самостоятельной подзадачи в многозадачном окружении. Программа пишется так, словно каждый поток запускается сам по себе и использует процессор в монопольном режиме. Процессор же переключается между потоками, выделяя каждому некоторый отрезок времени (либо используется многопроцессорный компьютер). Это позволяет масштабировать производительность (установкой доп. процессоров)</br>
Для создания потока надо создать экземпляр класса Thread. У класса есть метод run, куда помещается код, который требуется выполнить в отдельном потоке. Определить и инстанциировать поток можно двумя способами:</br>
• Расширить класс Thread:</br>
Public class MyThread extends Thread {</br>
    @Override</br>
    public void run() { ... }</br>
}</br>
...</br>
MyThread t = new MyThread();	//Инстанциирование потока</br>
T.start();				//Запуск потока</br>
• Реализовать интерфейс Runnable:</br>
Class MyRunnable implements Runnable {</br>
    @Override</br>
    public void run() { ... }</br>
}</br>
...</br>
MyRunnable r = new MyRunnable();	//Инстанциирование потока</br>
Thread t = new Thread(r);</br>
T.start();				//Запуск потока</br>
Проще говоря, Thread – работник, Runnable – работа.</br>
Предпочтительнее 2й способ, т.к. расширяя Thread, наш класс уже не сможет быть потомком другого класса.</br>
Состояния потока:</br>
• Инстанциированный, но незапущенный пока поток находится в состоянии new (новый) и считается not alive (не живым)</br>
• После вызова метода start экземпляра потока, он становится alive (живым) и переходит в состояние runnable/ready-to-run (готов к запуску, работоспособный). То, что поток alive, не означает, что метод run уже начал выполняться. В состоянии runnable поток ждет своей очереди от процессора. В состояние runnable поток может перейти из состояния running</br>
• Состояние running означает, что поток сейчас запущен. Существует несколько способов попасть в состояние runnable, но в running – есть один способ: планировщик потоков выбрал данный поток из пула потоков.</br>
• Поток считается dead (мертвым) после того, как метод run закончит выполняться. Поток из этого состояния нельзя запустить снова</br>
• Состояния waiting/blocked/sleeping характеризуют поток, как не готовый к работе, т.е. он жив, но в настоящее время не может быть выполнен. При этом он не runnable, но может вернуться в это состояние. Он может быть заблокирован и ждет ресурсов, занятых другим потоком или спит до истечения времени в методе sleep или находится в состоянии ожидания, т.к. в run встретился метод wait (вызов notify или notifyAll переведет поток из состояния waiting в состояние runnable). Один поток не может попросить другой заблокироваться</br>
Для определения запущен ли поток и его состояния используются методы isAlive и getState.</br>
При вызове вручную метода run, метод просто выполнится в том же потоке, из которого был запущен (в основном потоке программы). В каждом отдельном потоке порядок выполнения предсказуем, но порядок выполнения потоков не предсказуем.</br>
Приостановка выполнения потока может быть выполнена следующими способами:</br>
• Отправка в сон: sleep(msecCount). Гарантированно прекращает выполнение текущего потока как минимум на указанный отрезок времени. Зачем: для принудительного выполнения потоков по очереди, для уменьшения трафика и т.п. По пробуждении поток не запустится сразу, а просто перейдет в состояние runnable. Метод sleep статический, может быть вызван из любого места программы, но в результате ляжет спать текущий поток</br>
• Метод yield пытается принудить планировщик выполнить другой поток, ожидающий своей очереди, посредством попытки перевода потока из running в runnable. Он может не возыметь эффекта</br>
• Вызов join(). Гарантированно останавливает выполнение текущего потока на заданное время или до завершения выполнения потока, метод join которого был вызван</br>
• Дать потоку закончить свое выполнение :)</br>
• Вызвать метод wait()</br>
• Поток не может получить блокировку на объект, метод которого пытается выполниться</br>
		Можно только приостановить выполнение потока, но не остановить полностью.</br>
</p>
<p align="justify">
Планировщик потоков является частью JVM (хотя некоторые JVM мапят Java-потоки на нативные потоки ОС) и решает, какой поток из пула потоков будет работать в определенный момент. Поток, переходящий в состояние runnable, помещается в runnable pool. Обычно используется планировщик на основе приоритетов. У класса Thread есть метод setPriority, куда можно отправить приоритет [1;10].</br>
</p>
<p align="justify">
<b>Написать и запустить поток, бесконечно печатающий в консоль строку</b></br>
Public CustomThread implements Runnable {</br>
Private final String str;</br>
Public CustomThread(String str) {</br>
	this.str = str;</br>
}</br>
@Override</br>
Public void run() {</br>
       while(true) { System.out.println(str); }</br>
}</br>
}</br>
…</br>
CustomThread work = new CustomThread(“Hello!”);</br>
Thread th = new Thread(work);</br>
Th.start();</br>
</p>
<p align="justify">
<b>Синхронизация, ее методы. Зачем нужна? Модификатор volatile. По каким объектам синхронизируются статические и нестатические методы? Что такое deadlock? Способы его избежать. Как на уровне ОС реализовано избавление от deadlock?</b></br>
Синхронизация необходима для решения проблем, возникающих при обращении разных потоков к одному ресурсу (т.н. состязание/гонка потоков).</br>
Ключевое слово synchronized метода/блока означает, что если один поток начал выполнение этого метода/блока, другой поток не сможет его выполнить, пока первый не закончит. Каждый объект в Java имеет встроенную блокировку, которая вступает в игру в том случае, если объект имеет синхронизированные методы. Когда входим в синхронизированный нестатический метод – автоматически получаем блокировку, связанную с текущим экземпляром класса (текущий – код которого выполняется в данный момент).</br>
• Только методы (или блоки) могут быть synchronized</br>
• Каждый объект имеет одну блокировку</br>
• Класс может иметь синхронизированные и несинхронизированные методы</br>
• Спящий поток удерживает все свои блокировки</br>
• Поток может захватить несколько блокировок (войти в синхронизированный метод, захватит блокировку, а затем сразу вызвать синхронизированный метод другого объекта, получив и его блокировку)</br>
• Можно синхронизировать не весь метод, а только  блок кода: syncronized(this) { ... }</br>
При синхронизации метода объект, используемый для вызова этого метода, получает блокировку. Но когда синхронизируется блок кода надо указать объект, используемый в качестве блокировки. Можно использовать некий сторонний объект в качестве блокировки для этого куска кода, что дает возможномть иметь больше одной блокировки для синхронизированного кода в рамках одного объекта</br>
Нестатический метод класса в качестве блокировки использует экземпляр текущего класса, а статический метод – экземпляр класса java.lang.Class.</br>
	Если 2 нестатических метода объявлены как synchronized, то в каждый момент времени из разных потоков на одном объекте может быть вызван только один из них. Поток, который вызывает метод первым, захватит монитор, и второму потоку придется ждать. Важны 3  момента:</br>
• Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не создаст</br>
• Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст</br>
• В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.</br>
Замечание. Объекты класса Class существуют в единственном экземпляре только в пределах одного ClassLoader-а. Следовательно, если установить контекстный загрузчик классов потоку – у разных потоков могут быть разные экземпляры одного и того же класса Class и, следовательно, будет возможен одновременный вызов синхронизированных статических методов. Если эти методы используют одни и те же ресурсы – это может вызвать проблемы.</br>
</p>
<p align="justify">
Когда поток не может получить блокировку, он переходит в некий пул для конкретного объекта и находится там, пока блокировка не снимается. Из методов, приостанавливающих выполнение потока, отказывается от блокировок только метод wait. Методы wait, notify, notifyAll должны вызываться из синхронизированного контекста, иначе будет будет брошено исключение IllegalMonitorStateException.</br>
Какие объекты используются для блокировки:</br>
• Потоки, вызывающие нестатические синхронизированные методы в одном классе будут блокировать другие потоки, если они вызываются с помощью того же экземпляра класса</br>
• Потоки, вызывающие статические синхронизированные методы в одном классе будут всегда блокировать друг друга если все они используют один и тот же экземпляр Class</br>
• Статические синхронизированные методы и нестатические синхронизированные методы не будет блокировать друг друга, никогда. Статические методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу</br>
• При использовании синхронизированных блоков, необходимо обращать внимание на то, какой объект используется для блокирования. Потоки, которые синхронизируются на том же объекте будут блокировать друг друга. Потоки, которые синхронизируются на разных объектах, не будут блокировать друг друга</br>
Модификатор volatile актуален в многопоточных приложениях. Указывает, что операции записи и чтения, выполняемые потоками, происходят напрямую с основной памятью (для эффективности каждый поток может использовать свою «локальную память», т.н. кэш потока). Поэтому каждый поток имеет текущее, актуальное значение volatile-поля.</br>
Declaring a volatile Java variable means:</br>
• The value of this variable will never be cached thread-locally: all reads and writes will go straight to "main memory"</br>
• Access to the variable acts as though it is enclosed in a synchronized block, synchronized on itself</br>
Когда класс тщательно синхронизирован, он является потокобезопасным (thread-safe). StringBuffer – потокобезопасен, StringBuilder – нет.</br>
Deadlock – взаимная блокировка потоков: два потока блокируются, при этом каждый ждет освобождения блокировки, захваченной другим потоком. Это значит, что потоки не получат ожидаемых блокировок никогда. В Java нет встроенных средств предупреждения взаимных блокировок. Все зависит от качества кода. ОС борется с deadlocks следующими способами:</br>
• Игнорирование проблемы в целом (предполагается маловероятность возникновения, малый ущерб)</br>
• Предотвращение deadlocks (обеспечение условий, исключающих возможность возникновения взаимоблокировок (предотвращение возникновения одного из условий ее возникновения))</br>
• Обнаружение deadlocks (фиксация ситуации, выявление вовлеченных процессов)</br>
• Восстановление после deadlocks (после обнаружения DL, можно вывести из него систему, нарушив одно из условий существования DL)</br>
</p>
<p align="justify">
Ключевое слово synchronized скрывает реализацию синхронизации при помощи мониторов. Монитор – средство обеспечения контроля за доступом к ресурсу. У монитора есть максимум один владелец в каждый текущий момент времени. У каждого экземпляра объекта есть монитор. Любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (сможет – метод исполняется, нет – поток останавливается и ждет, пока монитор будет отпущен). Компилятор и интерпретатор вставляет код блокировки-разблокировки в соответствующим образом оформленные процедуры, избавляя программиста от явного обращения к примитивам синхронизации.</br>
Семафор - объект, позволяющий войти в заданный участок кода не более чем n потокам. Имеет методы:</br>
• init(n) – счетчик:= n</br>
• enter() – ждать, пока счетчик станет >0; после этого уменьшить его на единицу</br>
• leave() – увеличить счетчик на единицу</br>
Применяется для запрета одновременного выполнения заданных участков кода или поочередного доступа к критическому ресурсу.</br>
Проблемы семафоров:</br>
• Утечка семафора (забыть вызвать leave)</br>
• Лишний вызов leave</br>
• Возможность взаимной блокировки потоков</br>
</p>
<p align="justify">
<b>Есть код:</b></br>
Public class A {</br>
       public void method1() {}</br>
       public synchronized void method2() {}</br>
       public synchronized void method3() {}</br>
       public static synchronized void method4() {}</br>
}</br>
4 потока одновременно обращаются каждый к своему методу, в каком порядке выполнятся методы и почему?</br>
Одновременно начнут выполняться 3 метода: 1й, 4й и один из двух: 2й или 3й (какой именно – неизвестно заранее). Когда 2й (или 3й) метод выполнится до конца, начнет выполнение 3й (2й). Почему – см. вопрос Синхронизация.</br>
Получил другой ответ: если чуть раньше начал выполняться 1й метод, то сценарий тот же. Но если первым начал выполняться 2й или 3й – то 1й будет ждать. Потом, после окончания 2го (или 3го) – если 1й успеет запуститься – то будет выполняться параллельно с 3м, иначе – 1й будет ждать окончания 3го. На 4й это все не повлияет.</br>
</p>
<p align="justify">
<b>Что такое сериализация, для чего нужна, когда применяется? Ключевое слово transient, для чего нужно. Что такое UnmarshalException, когда выбрасывается?</b></br>
Сериализация объектов Java позволяет взять любой объект, реализующий интерфейс Serializable, и превратить его в последовательность байтов, из которой он потом может быть восстановлен. Так реализуется легковесное долговременное хранение. В основном применяется для:</br>
• удаленного вызова методов Java (RMI) (для работы с объектами, находящимися на других компьютерах)</br>
• визуальных компонентов JavaBean (для сохранения их состояний)</br>
Возможна “частичная” сериализация при помощи интерфейса Externalizable, который добавляет два метода: writeExternal, readExternal, позволяя попутно выполнить специфические действия. В этих методах сохранение и загрузку надо самому прописать “руками” в отличие от Serializable.</br>
Чтобы пометить поле класса, как несериализуемое, используется ключевое слово transient.</br>
Исключение UnmarshalException выбрасывается, когда RMI сервер не может восстановить сериализованный объект.</br>
Serializable класс содержит поле static final long serialVersioUID, обычно вычисляемое автоматически. Если мы изменили описание класса, значение автоматически рассчитываемого поля изменится. Хорошим тоном является объявление своего такого поля с заданием его значения.</br>
</p>
<p align="justify">
<b>Транзакции. Распределенные транзакции. Уровень изоляции транзакции. Свойства и модель транзакции. Привести примеры использования.</b></br>
= Транзакция – группа последовательных операций, представляющая логическую единицу работы с данными. Т может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще.</br>
</p>
<p align="justify">
= Распределенная транзакция включает в себя несколько локальных транзакций, каждая из которых либо фиксируется, либо прерывается. Распределенная транзакция фиксируется только в том случае, когда зафиксированы все локальные транзакции, ее составляющие. Если хотя бы одна из них была прервана, то должна быть прервана и распределенная транзакция.</br>
</p>
<p align="justify">
= Уровни изоляции транзакций:</br>
0 — Неподтверждённое чтение (Read Uncommitted, Dirty Read, грязное чтение) — чтение незафиксированных изменений своей транзакции и параллельных транзакций, возможны потерянные обновления, нечистые, неповторяемые чтения и фантомы</br>
1 — Подтверждённое чтение (Read Committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций, нечистые чтения невозможны, возможны неповторяемые чтения и фантомы;</br>
2 — Повторяемое чтение (Repeatable Read, Snapshot) — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны, нечистые и неповторяемые чтения невозможны, возможны фантомы;</br>
3 — Упорядоченный (Serializable, сериализуемый) — упорядоченные (сериализуемые) транзакции. Идентичен ситуации, при которой транзакции выполняются строго последовательно, одна после другой, то есть результат действия которых не зависит от порядка выполнения шагов транзакции (запрещено чтение всех данных, изменённых с начала транзакции, в том числе и своей транзакцией). Фантомы невозможны.</br>
Чем выше уровень изоляции, тем больше требуется ресурсов, чтобы их поддерживать.</br>
Кратко:</br>
	• Потерянное обновление: 2 транзакции начинаются одновременно, теряются изменения транзакции, законченной раньше</br>
	• Грязное чтение: начали 1 транзакцию, после изменений (но до коммита) 2я транзакция выполнила чтение, после чего 1я – отменила свои действия</br>
	• Неповторяющееся чтение: транзакция 1я считывает данные, 2я – меняет содержимое базы, теперь повторение 1й транзакцией считывания дает другой результат</br>
	• Фантомное чтение:  от неповторяющегося чтения отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных</br>
</p>
<p align="justify">
= Модели транзакций классифицируются на основании различных св-в:</br>
	• Структура транзакции</br>
	• Параллельность внутри транзакции</br>
	• Продолжительность</br>
</p>
<p align="justify">
= Выделяют следующие типы транзакций:</br>
1. Плоские (классические)</br>
2. Цепочечные</br>
3. Вложенные</br>
Плоские транзакции характеризуются 4 классическими св-вами:</br>
	• Атомарность - транзакция должна быть выполнена в целом или не выполнена вовсе</br>
	• Согласованность - гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, т. е. транзакция не разрушает взаимной согласованности данных</br>
	• Изолированность – означает, что конкурирующие за доступ к БД транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит так, как будто они выполняются параллельно</br>
	• Долговечность (прочность) – если транзакция завершена успешно, то те изменения, в данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах</br>
Иногда данные транзакции называются ACID-транзакциями (Atomicity, Consistency, Isolation, Durability).</br>
</p>
<p align="justify">
= Пример транзакции:</br>
• Начать транзакцию</br>
	= прочесть баланс на счету номер N1</br>
	= уменьшить баланс на M денежных единиц</br>
	= сохранить новый баланс счёта номер N1</br>
	= прочесть баланс на счету номер N2</br>
	= увеличить баланс на M денежных единиц</br>
	= сохранить новый баланс счёта номер N2</br>
• Окончить транзакцию</br>
</p>
<p align="justify">
<b>JDBC. Написать код подключения к базе данных. Откуда DriverManager знает, какой драйвер использовать?</b></br>
Подключение Java-программы к реляционной СУБД с помощью JDBC (Java DB Connectivity) выполняется в 3 этапа:</br>
• Установка связи между Java-программой и диспетчером БД</br>
• Передача SQL-команды в БД с помощью объекта Statement</br>
• Чтение полученных результатов из БД и использование их в программе</br>
Драйвер JDBC обычно создается поставщиками СУБД. Их работа заключается в обработке JDBC-подключений и команд, поступающих от Java-приложения, и в генерации машинно-зависимых вызовов по отношению к БД.</br>
Драйвер должен быть загружен, при этом он регистрируется. Способы загрузки:</br>
• из командной строки: java –D jdbc.drivers=mysql.Driver <appClassName></br>
• из программы: Class.forName(“mysql.Driver”)</br>
Т.е. мы явно указываем менеджеру драйверов, какой драйвер загружать. При этом jar с драйвером должен быть в classpath, либо явно указываться путь к jar. После загрузки драйвера можно работать с БД. Весь код работы с БД:</br>
       Class.forName(“mysql.Driver”)</br>
Connection connection = DriverManager.getConnection(<dbUrl>,<login>,<password>);</br>
Statement st = connection.createStatement();</br>
ResultSet rs = st.executeQuery(...);</br>
While (rs.next()) {</br>
...</br>
}</br>
Rs.close();</br>
St.close();</br>
</p>
<p align="justify">
<b>Три вида Statement. Чем отличается Statement от PreparedStatement? Где сохраняется запрос после первого вызова PreparedStatement? Зачем нужен CallableStatement?</b></br>
PreparedStatement используется для вызова параметризованного запроса. После первого вызова PreparedStatement, DBMS (Database Management System) прекомпилирует запрос и сохраняет его access plan в БД. После этого DBMS может запускать запрос без предварительной компиляции, поэтому PreparedStatement намного быстрее обычного Statement. Преимущества PreparedStatement:</br>
1. Позволяет писать динамические и параметрические запросы</br>
2. Быстрее обычного Statement</br>
3. Предотвращает SQL injection</br>
4. Лучше читаем</br>
Примечание: PreparedStatement возвращает FORWARD_ONLY ResultSet.</br>
</p>
<p align="justify">
CallableStatement используется для запуска хранимых процедур - объекта базы данных, представляющего собой набор SQL-инструкций, который компилируется 1 раз (при ее первом запуске) и хранится на сервере БД. Хранимая процедура позволяет повысить производительность, расширяет возможности программирования, обеспечивает целостность и надежность БД.</br>
</p>
<p align="justify">
<b>Оценка собственного уровня знания английского? Рассказать на английском про любой фреймворк, изученный в лабе</b></br>
</p>
<p align="justify">
<b>В чём отличие Exception от RuntimeException?</b></br>
Исключение – проблема, которая не может быть решена в текущем контексте, необходим переход на другой, более высокий уровень контекста.</br>
В Java исключения делятся на три типа: контролируемые (проверяемые), ошибки и исключения времени выполнения; последние две объединяют в категорию неконтролируемых (непроверяемых) исключений. Контролируемые должны быть обработаны в ходе выполнения программы, включением в блок try-catch или объявлением в сигнатуре метода. Неконтролируемые исключения не требуют обязательной обработки, наличие их обработчика Java не проверяет.</br>
Ловить RuntimeException – скорее дурной тон: вместо устранения причины мы нейтрализуем последствия.</br>
При выборе обрабатывать или объявлять исключение следует придерживаться следующей стратегии: обрабатывайте исключение, когда вы можете это сделать, объявляйте исключение, когда вы вынуждены так поступить.</br>
</p>
<p align="justify">
<b>Error – в каких случая возникает? Перехват Error: можно ли, есть ли смысл?</b></br>
При возникновении Error чаще всего продолжение программы невозможно (например OutOfMemoryError, StackOverflowError). Перехват Error возможен, это стоит делать, когда можно изменить на лету логику программы и использовать другой подход (например, выделить меньше памяти, использовать другой алгоритм).</br>
</p>
<p align="justify">
<b>Напишите класс, который будет принимать аргумент (имя файла) и выводить строчки из этого файла в консоль. Если не будет введён аргумент (имя файла), как поведёт себя написанный класс?</b></br>
Public class Main {</br>
    public static String read(String fileName) throws FileNotFoundException {</br>
        StringBuilder sb = new StringBuilder();</br>
        try {</br>
            BufferedReader in = new BufferedReader(new FileReader(fileName));</br>
            String s;</br>
            while ((s = in.readLine()) != null) {</br>
                sb.append(s);</br>
                sb.append("\n");</br>
            }</br>
            in.close();        </br>
        } catch (IOException ex) {</br>
            System.out.println("IOException!");</br>
        }</br>
        return sb.toString();</br>
    }</br>
</p>
<p align="justify">
    public static void main(String[] args) {</br>
        try {</br>
            System.out.println( read(args[0]) );</br>
        } catch (FileNotFoundException ex){</br>
            System.out.println("FileNotFoundException");</br>
        } catch (ArrayIndexOutOfBoundsException ex) {</br>
            System.out.println("No argument");</br>
        }</br>
    }</br>
}</br>
Если не будет введен аргумент (имя файла), еще при получении элемента массива по индексу будет брошено исключение ArrayIndexOutOfBoundsException.</br>
</p>
<p align="justify">
<b>Есть такой блок кода:</b></br>
Try {</br>
    throw new Exception1();</br>
} catch (Exception ex) {</br>
	throw new Exception2();</br>
} finally {</br>
	throw new Exception3();</br>
}</br>
Какую из трёх исключительных ситуаций мы получим на выходе? Почему?</br>
</p>
<p align="justify">
Try {</br>
       return 1;</br>
} catch(Exception e) {</br>
       return 2;</br>
} finally {</br>
       return 3;</br>
}</br>
Что будет возвращено? Почему?</br>
</p>
<p align="justify">
• Секция finally может быть не выполнена только в случае использования потоков-демонов (они завершают выполнение метода run без использования секции finally). Блок finally может вызвать потерю исключений, поэтому: в приведенном примере Exception1 - перехватывается, Exception2 – теряется, Exception3 – бросается</br>
• Будет возвращено значение 3 (см. предыдущий ответ)</br>
</p>
<p align="justify">
<b>Перегрузка и переопределение, в чем отличие? Является ли это перегрузкой, если в классе есть 2 метода, отличающихся только возвращаемым параметром?</b></br>
Перегрузка (overloading) – возможность делать разные действия единообразным способом. Перегруженные методы:</br>
• могут быть как в классе, так и в подклассах</br>
• имеют то же имя, но различаются списком параметров</br>
• могут различаться типом возвращаемого значения</br>
Переопределение (overriding) – переопределение родительского метода. Переопределенные методы:</br>
• появляются в подклассах</br>
• имеют то же имя, что и метод суперкласса</br>
• имеют тот же список параметров и тот же тип возвращаемого значения, что и метод суперкласса</br>
• модификатор доступа метода не может быть уже, чем модификатор метода суперкласса</br>
</p>
<p align="justify">
Ответ на вопрос: это не является перегрузкой, класс не будет откомпилирован.</br>
</p>
<p align="justify">
<b>Каким требованиям должен отвечать xml-документ, чтобы называться well-formed? В чём отличие между понятиями well-formed и valid? Xml namespace.</b></br>
Well-formed xml-документ соответствует всем правилам синтаксиса XML. Не well-formed не может считаться xml-документом. Правила well-formed документа:</br>
• Первая строка документа: <?xml version="1.0(1.1)" encoding="UTF-8"?></br>
• Документ имеет один корневой элемент</br>
• Открывающему тегу соответствует закрывающий</br>
• Тег без тела: <tag><tag/> или <tag /> или <tag/></br>
• Спецсимволы определяются как ссылки по номеру символа в Юникод: &#160 = &nbsp;</br>
</p>
<p align="justify">
Valid xml-документ – соответствует заранее определенным, но уже внешним правилам. Дополнительные правила нужны для минимизации кол-ва ошибок структуры и состава xml-документа. Правила хранятся в схемах; проверяет соответствие схеме - валидатор.</br>
Xml namespace – пространство имен xml. Синтаксис объявления: xmlns:prefix=”...”, где prefix – название пространства имен. Возможно объявление пространства имен по умолчанию: xmlns=”...”. Нельзя использовать зарезервированые пространства имен, начинающиеся с “xml”.</br>
</p>
<p align="justify">
<b>Напишите well-formed xml-документ, содержащий информацию о трёх user’ах (ID user’а – атрибут, имя и отдел – вложенные элементы).</b></br>
<?xml version="1.0" encoding="UTF-8"?></br>
<users></br>
<user id=”id1”></br>
       <name>asdasdsd</name></br>
       <department>adasd</department></br>
</user></br>
...</br>
</users></br>
</p>
<p align="justify">
<b>Сколько строк будет получено в результате запроса SELECT * FROM TABLE_A, TABLE_B?</b></br>
A. +------------+   +------------+</br>
B. | TABLE_A |    | TABLE_B |</br>
C. +------------+   +------------+</br>
D. | 1            |   | 4            |</br>
E. | 2            |   | 5            |</br>
F. | 3            |   +------------+</br>
G. +------------+</br>
Будет получено 6 строк: все комбинации пар строк из двух таблиц (их кол-во 3*2=6).</br>
</p>
<p align="justify">
<b>Написать метод equals для класса, содержащего одно поле типа String.</b></br>
Public boolean equals(Object obj) {</br>
       if(obj == this) return true; // obj равен самому себе</br>
       if(obj == null) return false;</br>
</p>
<p align="justify">
       /* Удостоверимся, что ссылки имеют тот же самый тип */</br>
       if(!(getClass() == obj.getClass())) return false;</br>
       else {</br>
       MyClass tmp = (MyClass)obj;</br>
       if(tmp.fieldName == this.fieldName) return true;</br>
       else return false;</br>
        }</br>
   }</br>
• Проверяем равенство экземпляра класса самому себе и неравенство null</br>
• Выясняем, является ли сравниваемый объект экземпляром класса, к которому должен принадлежать. Если нет - автоматически предполагаем, что они не равны</br>
• Выясняем, одинаковы ли поля fieldName в обоих экземплярах</br>
</p>
<p align="justify">
<b>OOP abstraction.</b></br>
Абстракция дает возможность сделать класс абстрактным (АК). Экземпляр АК не может быть создан. Вся остальная функциональность класса может существовать.</br>
</p>
<p align="justify">
<b>Чем отличается абстрактный класс от интерфейса?</b></br>
• Класс может реализовывать несколько интерфейсов, но наследоваться только от одного абстрактного класса</br>
• Интерфейс не содержит реализации; абстрактный класс – может содержать</br>
• Интерфейс часто используется для описания внешних возможностей класса, а не его главного назначения (-able (например Runnable) или can-do); абстрактный класс идентифицирует (is-a) класс и его потомков</br>
• Все методы интерфейса public abstract по умолчанию, константы могут быть только static final, нельзя вычислять константы (их начальное значение); в абстрактных классах можно использовать скрытый код и вычислять константы</br>
</p>
<p align="justify">
<b>Наследование. Переопределение (сужение/расширение) уровней доступа полей/методов</b></br>
Наследование – включение поведения (т.е. методов) и состояния (т.е. полей) базового класса в наследуемый класс. Наследуются поля и методы public, protected. Если подкласс находится в том же пакете, что и суперкласс, - наследуются члены класса с уровнем доступа package.</br>
Можно в подклассе:</br>
• объявить такое же поле, как и суперклассе, скрыв его (не рекомендуется)</br>
• объявить новую реализацию метода с той же сигнатурой, что и суперклассе, таким образом переопределив его</br>
• объявить новый static метод с той же сигнатурой, что и суперклассе, скрыв оригинальный метод</br>
• объявить новые поля и методы, которых нет в суперклассе</br>
• написать собственный конструктор, который вызывает конструктор суперкласса ключевым словом super</br>
Хотя private члены суперкласса не наследуются, но, если суперкласс имеет public или protected методы, для получения доступа к private полям, они также могут использоваться и в подклассе.</br>
Nested-класс (содержащийся в другом классе), имеет доступ ко всем private членам содержащего его класса. Таким образом, public или protected nested-класс, наследуемый подклассом, имеет косвенный доступ ко всем private членам суперкласса.</br>
Проверка класса объекта: if(obj instanceof ClassName) { ... }.</br>
</p>
<p align="justify">
							non-static метод суперкласса	static метод суперкласса</br>
Non-static метод подкласса	Переопределение					Ошибка компиляции</br>
Static метод подкласса		Ошибка компиляции				Скрытие</br>
</p>
<p align="justify">
При наследовании можно только расширять область видимости метода. Для поля изменение области видимости приводит к тому, что используется поле потомка (поле предка скрывается).</br>
</p>
<p align="justify">
<b>Полиморфизм. Участвуют ли статические/приватные методы в полиморфизме? Вызов методов этого/базового класса из конструктора.</b></br>
Полиморфизм - возможность работы с подклассом, используя ссылку на суперкласс или возможность объектов с одинаковой спецификацией иметь различную реализацию. Кратко: один интерфейс, множество реализаций. Позволяет писать более абстрактные программы, повысить коэффициент повторного использования кода. В статическом полиморфизме смысл фрагмента зависит от окружающего его кода, а в динамическом – смысл фрагмента определяется только на этапе исполнения.</br>
Приватные методы в полиморфизме не участвуют, т.к. не видны в подклассе.</br>
Статические методы в полиморфизме не участвуют, т.к. к ним не применимы принципы позднего связывания.</br>
При полиморфизме используются восходящее и нисходящее преобразования: восходящее– преобразование к базовому классу (автоматически), нисходящее – к потомку (принудительно).</br>
Ковариантность возвращаемых типов - начиная с Java 5, появилась возможность возвращения переопределенным методом значения с типом, отличным от типа у метода базового класса.</br>
Из конструктора вызывать стоит только final-методы базового класса и private-методы своего класса (т.к. они автоматически считаются final). Иначе (из-за полиморфизма) поведение может быть неожиданным.</br>
Throws в методах:</br>
• Переопределяемый метод в подклассе не может содержать в throws исключений, не обрабатываемых в соответствующем методе суперкласса. Если же при объявлении метода суперкласса инструкция throws присутствует, то в подклассе эта инструкция может вообще отсутствовать или в ней могут быть объявлены любые исключения, являющееся подклассами исключения из блока throws метода суперкласса</br>
• Конструктор подкласса должен включить в свой throws все классы исключений или их суперклассы из блока throws конструктора суперкласса, к которому он обращается при создании объекта</br>
</p>

<p align="justify">
<b>Даны две таблицы: 1. Employee (id_employee, salary,  department_id_fk); 2. Department (id_department, department_name). Написать sql-запрос, который выберет все названия отделов, суммарная зарплата сотрудников в которых больше тысячи.</b></br>
SELECT DPT.department_name FROM Department DPT WHERE DPT.id_department in (SELECT department_id_fk FROM Employee GROUP BY department_id_fk HAVING SUM(salary)>1000)</br>
</p>
<p align="justify">
<b>Переложить на БД файловую систему (есть папки, в них могут быть другие папки и файлы), свести всё в одну таблицу, составить запрос на получение всех папок 2ого уровня вложенности (находящихся в корневой директории).</b></br>
С точки зрения файловой системы файлы и папки идентичны: они имеют некоторое имя и сами могут содержаться в некоторой папке. Корневая директория имеет нулевую вложенность, PARENT_ID=0.</br>
CREATE TABLE "FS" (</br>
       "ID" NUMBER NOT NULL ENABLE, </br>
       "NAME" VARCHAR2(255), </br>
       "PARENT_ID" NUMBER</br>
)</br>
SELECT fs2.name from fs fs2 where fs2.parent_id in (SELECT fs1.id as id1 from fs fs1 where fs1.parent_id in (SELECT fs0.id as id0 FROM fs fs0 where fs0.parent_id=0)), или, кратче:</br>
SELECT name from fs where parent_id in (SELECT id from fs where parent_id in (SELECT id FROM fs where parent_id=0))</br>
</p>
<p align="justify">
<b>SQL statements: SELECT, INSERT, UPDATE, DELETE.</b></br>
SELECT</br>
   [DISTINCT | DISTINCTROW | ALL] select_expression,...</br>
   [FROM table_references]</br>
     [WHERE where_definition]</br>
     [GROUP BY {unsigned_integer | col_name | formula}]</br>
     [HAVING where_definition]</br>
     [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC], ...]</br>
Где</br>
WHERE - определение, какие строки должны быть выбраны или включены в GROUP BY</br>
GROUP BY - объединение строк с общими значениями в элементы меньшего набора строк</br>
HAVING - определение, какие строки после GROUP BY должны быть выбраны</br>
ORDER BY - определение, какие столбцы используются для сортировки итогового набора данных</br>
Для ограничения кол-ва возвращаемых строк используются оконные функции ROW_NUMBER() и RANK()</br>
</p>
<p align="justify">
INSERT</br>
• Используя перечисление значений, с указанием столбцов:</br>
   INSERT INTO <название таблицы> ([<Имя столбца>, ... ]) VALUES (<Значение>,...)</br>
• Используя перечисление значений, без указания столбцов:</br>
   INSERT INTO <название таблицы> VALUES (<Значение>,...)</br>
• Используя SELECT:</br>
   INSERT INTO <название таблицы> SELECT <имя столбца>,... FROM <название таблицы></br>
   В последнем случае, в таблицу может вставиться более одной записи.</br>
</p>
<p align="justify">
UPDATE [top(x)] <объект (таблица или представление)> </br>
SET <присваивание1 [, присваивание2, ...]> </br>
[WHERE <условие>]</br>
[OPTION <хинт1 [, хинт2, ...]>]</br>
Команда выполнится только x раз.</br>
</p>
<p align="justify">
DELETE</br>
• Удаление из одной таблицы:</br>
   DELETE FROM <Имя Таблицы> WHERE <Условие отбора записей></br>
• Удаление сразу из нескольких таблиц:</br>
DELETE <Имя записи для удаления> FROM <Имя Таблицы1> JOIN <Имя Таблицы2> ON <условие объединения></br>
</p>
<p align="justify">
<b>SQL-запросы с использованием INNER JOIN, GROUP BY, HAVING. Виды JOIN, отличие OUTER от INNER. Уметь сходу писать запросы.</b></br>
JOIN – SQL оператор, позволяющий соединять записи из двух таблиц БД. Входит в раздел FROM оператора SELECT и отдельно от него не используется.</br>
Синтаксис: SELECT FIELD [,...n] FROM Table1 {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN Table2 ON <condition>.</br>
В большинстве СУБД можно опустить:</br>
• слово INNER (т.е. по умолчанию join = inner join)</br>
• слово OUTER при указании LEFT,RIGHT,FULL</br>
В общем случае СУБД при выполнении join проверяет условие condition. Для CROSS JOIN условие не указывается. Для CROSS JOIN в некоторых реализациях SQL используется оператор «запятая» (,): SELECT ... FROM TABLE1,TABLE2.</br>
Различия JOIN:</br>
• INNER JOIN – объединяет 2 таблицы, где каждая строка обеих таблиц в точности соответствует условию. Если для строки одной таблицы не найдено соответствия в другой таблице, строка не включается в набор</br>
• OUTER JOIN – присоединение таблицы с необязательным присутствием записи в таблице</br>
O LEFT OUTER JOIN. К левой таблице присоединяются все записи из правой, соответствующие условию (по правилам inner join), плюс все не вошедшие записи из левой таблицы, поля правой таблицы заполняются значениями NULL</br>
O RIGHT OUTER JOIN. Аналогично left outer join, но применяется для правой таблицы. К правой таблице присоединяются все записи из левой, соответствующие условию (по правилам inner join), плюс все не вошедшие записи из правой таблицы, поля левой таблицы заполняются значениями NULL</br>
O FULL OUTER JOIN. К левой таблице присоединяются все записи из правой, соответствующие условию (по правилам inner join), плюс все не вошедшие записи из правой таблицы, поля левой таблицы заполняются значениями NULL и плюс все не вошедшие записи из левой таблицы, поля правой таблицы заполняются значениями NULL</br>
O CROSS JOIN. Все возможные сочетания из обеих таблиц. Как уже говорилось выше, условие для этого типа оператора JOIN не указывается</br>
</p>
<p align="justify">
Агрегатные функции: MIN, MAX, SUM, AVG, COUNT.</br>
GROUP BY – указывает подмножество, для которого применяется агрегатная функция.</br>
HAVING – необязательный параметр оператора SELECT для указания условия на результат агрегатных функций. HAVING <условия> аналогичен WHERE <условия> но строки отбираются не по значениям столбцов, а строятся из значений столбцов указанных в GROUP BY и значений агрегатных функций, вычисленных для каждой группы, образованной GROUP BY.</br>
Необходимо, чтобы в SELECT были заданы только требуемые в выходном потоке столбцы, перечисленные в GROUP BY и/или агрегированные значения. Распространённая ошибка — указание в SELECT столбца, пропущенного в GROUP BY.</br>
Если параметр GROUP BY в SELECT не задан, HAVING применяется к «группе» всех строк таблицы, полностью дублируя WHERE (допускается не во всех реализациях стандарта SQL).</br>
Объяснение формирования результата JOIN-ов другими словами (по википедии):</br>
• INNER JOIN (симметричный оператор) – Каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы, после чего для полученной «соединённой» строки проверяется условие соединения (вычисляется предикат соединения). Если условие истинно, в таблицу-результат добавляется соответствующая «соединённая» строка</br>
• OUTER JOIN - Соединение двух таблиц, в результат которого в обязательном порядке входят строки либо одной, либо обеих таблиц</br>
• LEFT OUTER JOIN (асимметричный оператор) – 1.В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату p. 2.Затем в результат добавляются те записи левой таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких записей поля, соответствующие правой таблице, заполняются значениями NULL</br>
• RIGHT OUTER JOIN (асимметричный оператор) - 1.В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату p. 2.Затем в результат добавляются те записи правой таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких записей поля, соответствующие левой таблице, заполняются значениями NULL</br>
• FULL OUTER JOIN (симметричный оператор) - 1.В результат включается внутреннее соединение (INNER JOIN) первой и второй таблиц по предикату p. 2.В результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких записей поля, соответствующие второй таблице, заполняются значениями NULL. 3.В результат добавляются те записи второй таблицы, которые не вошли во внутреннее соединение на шаге 1. Для таких записей поля, соответствующие первой таблице, заполняются значениями NULL</br>
• CROSS JOIN (симметричный оператор) - Тело результата логически формируется следующим образом. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц</br>
</p>
<p align="justify">
<b>Объяснить модель MVC. Что в Struts является контроллером?</b></br>
Модель - предоставляет знания: данные и методы работы с этими данными, реагирует на запросы, изменяя своё состояние. Не содержит информации, как эти знания можно визуализировать.</br>
Представление - отвечает за отображение информации (визуализацию). Часто в качестве представления выступает форма (окно) с графическими элементами.</br>
Контроллер - обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и представление для реализации необходимой реакции. </br>
MVC – патерн проектирования, с помощью которого модель данных приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на 3 отдельных компонента, поэтому модификация одного из компонентов оказывает минимальное воздействие на остальные. Различают 2 основные модификации:</br>
• Пассивная модель. Модель не имеет никаких способов воздействовать на представление или контроллер, и используется ими в качестве источника данных для отображения. Изменения модели отслеживаются контроллером, и он же отвечает за прорисовку представления, если необходимо. В это случае модель представляет просто структуру данных, без методов их обрабатывающих.</br>
• Активная модель. Модель оповещает представление о том, что в ней произошли изменения, а представления, которые заинтересованы в оповещении, подписываются на эти сообщения. Это позволяет сохранить независимость модели как от контроллера, так и от представления.</br>
За счет разделения модели и представления повышается возможность повторного использования кода.</br>
В Struts входит сервлет-контроллер, который перенаправляет (в соответствие с мэпингом в struts-config.xml) HTTP-запросы к другим объектам среды, поставляемым разработчиком приложения: JSP и наследникам класса Action.</br>
</p>
<p align="justify">
<b>Как работать с БД без Hibernate?</b></br>
Через JDBC или JPA (которое не Hibernate).</br>
</p>
<p align="justify">
<b>Какие в JDBC есть типы драйверов для соединения с СУБД?</b></br>
Jdbc-tutorial.com/jdbc-driver-types.htm</br>
В JDBC определяют четыре типа драйверов:</br>
• Драйвер, использующий другой прикладной интерфейс взаимодействия с СУБД, в частности ODBC (т.н. JDBC-ODBC мост) (ODBC = Open DB Connectivity, такой драйвер удовлетворяет стандарту Microsoft). Входит в JDK, не рекомендуется для промышленного использования</br>
• Драйвер, работающий через внешние (native) библиотеки (т.е. клиента СУБД)</br>
Обычно быстрее драйвера JDBC-ODBC, изменение типа БД требует смены драйвера, обычно не потокобезопасен, не может использоваться для Интернета, не полностью написан на Java (проблемы при портировании), считается устаревшим</br>
• Драйвер, работающий по сетевому и независимому от СУБД протоколу, с промежуточным Java-сервером, который уже подключается к СУБД</br>
Использования промежуточного сервера замедляет получение данных, требуется установка серверного приложения, гибок в плане получения доступа к различным БД при помощи одного драйвера. Обычно обеспечивает кэширование соединений, результатов запросов и т.д. Считается наиболее эффективным из 4 типов драйверов</br>
• Сетевой драйвер, работающий напрямую с нужной СУБД. Не требуется установка дополнительного ПО, драйвер можно быть загружен динамически, полностью написан на Java (т.е. независим от платформы), при смене БД нужна смена драйвера</br>
</p>
<p align="justify">
<b>С какими технологиями знаком? Отдельно перечислить технологии для веба, сравнить их, в чем преимущества и недостатки.</b></br>
Знаком с:</br>
• Языками программирования: Pascal, Basic, C, Java</br>
• Языками разметки HTML/XML, схемами DTD/XSD</br>
• Библиотеками вывода графики DirectX, OpenGL</br>
• Языком запросов к БД SQL</br>
• Технологией асинхронного обмена данными Ajax</br>
• Фреймворками Struts, Spring, Hibernate, JSF</br>
Выделены технологии для веба. Сравнение преимуществ/недостатков – устно.</br>
</p>
<p align="justify">
<b>XML парсеры (DOM, SAX, StAX).</b></br>
DOM (Document Object Model) парсер обеспечивает очень гибкое API для создания, чтения, редактирования и удаления узлов дерева. Парсер создает XML-дерево в памяти; при этом загружается сразу весь XML-документ, что снижает производительность.</br>
SAX (Simple API for XML) парсер предоставляет интерфейс обратных вызовов. Предназначен только для чтения. Парсер ожидает, что весь XML-документ будет прочтен, но не требует содержания всего документа в памяти во все моменты времени. Хороший выбор для парсинга больших документов.</br>
StAX (Streaming API for XML) похож на SAX, но позволяет читать и писать в документ, имеет курсор и итератор. Не требуется содержать весь документ в памяти, не требуется читать весь документ (некоторые части могут быть пропущены).</br>
TrAX парсер использует XSLT-трансформацию для преобразования исходного документа в результирующий. Источник для TrAX может быть создан при помощи SAX или DOM.</br>
Краткое резюме:</br>
• SAX и StAX лучше по производительности и использованию памяти. Для случаев DOM и TrAX это зависит от того, насколько велик документ и какие ставятся цели</br>
• DOM и StAX поддерживают CRUD</br>
• SAX и StAX двигаются только вперед, тогда как DOM и TrAX позволяют двигаться в обоих направлениях</br>
При использовании StAX приложение “тянет” информацию из парсера, когда это необходимо, тогда как в событийном API SAX парсер “толкает” данные в приложение, ожидая, что приложение сохраняет состояние между событиями и отслеживает положение внутри документа.</br>
</p>
<p align="justify">
<b>Применение классов HttpServletRequestWrapper и HttpServletResponseWrapper.</b></br>
Классы реализуют паттерн Wrapper (или Decorator) и позволяют «обертывать» запрос и ответ, соответственно (можно менять HTTP-заголовок). Применение – например шифрование HTTP-контента.</br>
</p>
<p align="justify">
<b>Почему в Singleton не работает двойная блокировка?</b></br>
Двойная блокировка: сначала проверяется условие блокировки без какой-либо синхронизации; поток делает попытку получить блокировку только, если результат проверки говорит о том, что ни один другой поток не владеет блокировкой. Была придумана для ускорения инициализации, т.к. после инициализации синглтона уже нет необходимости в синхронизации. Считается антипаттерном.</br>
В отношении синглтона: дело в порядке создания объектов в Java:</br>
• Выделяется память под объект</br>
• Инициализируется указатель на объект</br>
• Конструируется объект (инициализируются поля)</br>
Поэтому между вторым и третьим этапом возникает ситуация, при которой другой поток может получить и начать использовать (если указатель !=null) не полностью сконструированный объект.</br>
</p>
<p align="justify">
<b>В какой последовательности выполняются сервлетные фильтры?</b></br>
Сервлетный фильтр (СФ) – Java-код, позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. СФ занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета. СФ могут:</br>
• Перехватывать инициацию сервлета прежде, чем сервлет будет инициирован</br>
• Определить содержание запроса прежде, чем сервлет будет инициирован</br>
• Модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос</br>
• Модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ</br>
• Перехватывать инициацию сервлета после обращения к сервлету</br>
Имеет 3 метода:</br>
• init – вызывается (единожды) прежде, чем фильтр начинает работать, настраивает конфигурационный объект фильтра</br>
• doFilter – выполняет непосредственно работу фильтра (вызывается столько раз, сколько нужно)</br>
• destroy – вызывается после того, как фильтр заканчивает свою работу</br>
Контейнер сервлетов запускает фильтры в том порядке, в котором они указаны в deployment descriptor (в web.xml).</br>
</p>
<p align="justify">
<b>Как обрабатывается тег с телом?</b></br>
• Вызываются сеттеры для атрибутов</br>
• Вызывается метод doStartTag(). Уже известны значения атрибутов, но неизвестно содержимое тела тега</br>
• Вызывается метод doEndTag(). Содержимое тела тега уже известно: getBodyContent().getString()</br>
Для работы с библиотекой тегов ей в tld-файле должен быть поставлен в соответствие uri и быть выполнено описание тега, а в заголовок JSP-страницы должна быть включена директива taglib с указанием выбранного uri.</br>
</p>
<p align="justify">
<b>Работа с JSTL тегами.</b></br>
JSTL – стандартная библиотека тегов JSP. Расширяет спецификацию JSP, является альтернативой встроенной в JSP логики (скриптлетам). Использование стандартизированного множества тегов предпочтительнее, т.к. код легче поддерживать и проще отделять бизнес-логику от логики отображения. JSTL породила технологию EL (Expression Language). JSTL включает теги, которые:</br>
• Устанавливают атрибуты объектов web-приложений (c:set)</br>
• Выводят текст на web-страницы (c:out x:out)</br>
• Перебирают элементы набора данных (c:forEach и x:forEach)</br>
• Форматируют числа, даты, валюты, используя интернациональные стили (fmt:formatDate, fmt:formatNumber)</br>
• Выполняют преобразование XML (x:transform)</br>
• Взаимодействуют с БД, используя SQL (sql:query, sql:update)</br>
• Позволяют вставлять вызовы функций в код JSP</br>
Для подключения:</br>
<%@ taglib uri=”http://java.sun.com/jstl/core” prefix=”c” %></br>
<%@ taglib uri=”http://java.sun.com/jstl/xml” prefix=”x” %> и т.д.</br>
</p>
<p align="justify">
<b>Что происходит при добавлении в ArrayList нового элемента и как бы ты это реализовал?</b></br>
ArrayList реализует интерфейс List. Только что созданный объект list содержит св-ва elementData (массив определенного типа, указанного в generic, или просто Object) и size. Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется). При добавлении элемента:</br>
• Проверяется, достаточно ли места в массиве для вставки нового элемента. Если нет – создается новый массив размером (oldCapacity*3)/2+1, и в него функцией System.arraycopy() копируется содержимое исходного массива</br>
• Добавляется элемент в конец (согласно значению size) массива</br>
При добавлении в “середину” списка:</br>
• проверяется, достаточно ли места в массиве для вставки нового элемента</br>
• подготавливается место для нового элемента с помощью System.arraycopy()</br>
• перезаписывается значение у элемента с указанным индексом</br>
В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод addAll(index, Collection).</br>
Удалять элементы можно 2 способами: по индексу remove(index), по значению remove(value). При удалении элемента:</br>
• Определяется, какое количество элементов надо скопировать</br>
• Копируются элементы, используя System.arraycopy()</br>
• Уменьшаем размер массива и забываем про последний элемент</br>
При удалении по значению, в цикле просматриваются все элементы списка, до тех пор пока не будет найдено соответствие. Удален будет лишь первый найденный элемент.</br>
Итоги:</br>
— Быстрый доступ к элементам по индексу за время O(1)</br>
— Доступ к элементам по значению за линейное время O(n)</br>
— Медленный, когда вставляются и удаляются элементы из «середины» списка</br>
— Позволяет хранить любые значения в том числе и null</br>
— Не синхронизирован (синхронизирован Vector)</br>
</p>
<p align="justify">
<b>Операции сдвига >>, <<, >>>.</b></br>
В случае сдвига влево << и беззнакового сдвига вправо >>> новые биты просто устанавливаются в ноль. В случае сдвига вправо со знаком >> новые биты принимают значение старшего (самого левого) бита перед сдвигом.</br>
</p>
<p align="justify">
<b>Реализация HashMap.</b></br>
Объект HashMap содержит ряд св-в:</br>
• table – массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений</br>
• loadFactor – коэфф-т загрузки, по умолчанию =0.75</br>
• threshold – предельное кол-во эл-тов, при достижению которого размер хэш-таблицы увеличивается вдвое; =(capacity * loadFactor)</br>
• size – кол-во эл-тов HashMap-а</br>
Можно указать свои емкость и коэфф-т загрузки конструкторами HashMap(capacity) и HashMap(capacity, loadFactor). Максимальная емкость равна половине макс. значения int.</br>
• При добавлении эл-та ключ проверяется на null (если ==null, то просматривается цепочка, привязанная к table[0]; при нахождении эл-та с ключом null его значение перезаписывается; при ненахождении - добавляется в цепочку, привязанную к table[0]).</br>
• Рассчитывается хэш ключа и позиция в массиве, куда будет помещен элемент. Перезапись происходит только если хэш и ключ нового элемента совпадают с хэшем и ключом существующего элемента, в обратном случае – происходит добавление эл-та в цепочку, соответствующую расчетной позиции в массиве.</br>
Когда массив table[] заполняется до предельного значения, его размер увеличивается вдвое и происходит перераспределение эл-тов. При удалении эл-тов размер массива table[] не уменьшается (можно пересоздать HashMap конструктором копирования). </br>
</p>
<p align="justify">
<b>Внутренние классы, цели использования. Области видимости данных при определенных ситуациях.</b></br>
Внутренний класс не может существовать без внешнего класса. Есть 4 типа:</br>
• Статические внутренние классы. Декларируются внутри основного класса и обозначаются ключевым словом static. Не имеют доступа к членам внешнего класса за исключением статических. Может содержать статические поля, методы и классы, в отличие от других типов внутренних классов</br>
• Внутренние классы. Декларируются внутри основного класса. В отличие от статических внутренних классов, имеют доступ к членам внешнего класса. </br>
• Локальные классы. Декларируются внутри методов основного класса. Могут быть использованы только внутри этих методов. Имеют доступ к членам внешнего класса. Имеют доступ как к локальным переменным, так и к параметрам метода при одном условии - переменные и параметры, используемые локальным классом, должны быть задекларированы final</br>
• Анонимные (безымянные классы). Декларируются внутри методов основного класса. Могут быть использованы только внутри этих методов. В отличие от локальных классов, анонимные классы не имеют названия. Главное требование к анонимному классу - он должен наследовать существующий класс или реализовывать существующий интерфейс</br>
Последние 3 – не могут содержать определение (но могут наследовать) статических полей, методов и классов (кроме констант).</br>
</p>
<p align="justify">
<b>Autoboxing  и unboxing. Принцип действия на примерах.</b></br>
Autoboxing  - автоматическое преобразование примитивных типов (int, double, float и т.д.) к их объектным эквивалентам (Integer, Float, Double и т.д.) при присваивании и вызове методов/конструкторов.</br>
Unboxing – wrapper-типы автоматически преобразуются в их примитивные эквиваленты, если это необходимо для присваивания или вызова конструктора/метода.</br>
Примеры:</br>
Integer i2 = 5;		// autoboxing</br>
Int i = 0;</br>
I = new Integer(5);	// auto-unboxing</br>
</p>
<p align="justify">
<b>Generics - что такое и для чего применяются? Во что превращается во время выполнения ? Использование wildcards.</b></br>
Generics являются средством выражения ограничений поведения классов или методов для исходно неизвестных типов: «какой бы тип не использовался для переменной X, он должен совпадать с типом переменной Y».</br>
Пример:	ArrayList<T> tArray.</br>
Wildcards позволяют задать границы для семейства типов, определенных каким-нибудь generic-классом.</br>
Пример:</br>
   ArrayList<? extends Number> numArray</br>
	ArrayList<T super ?> numArray (T super Integer означает, что T может быть Integer или Number)</br>
</p>
<p align="justify">
Проверка корректности типов для generics происходит во время компиляции. При этом generic-информация о типе удаляется, что называется стиранием типа. В результате тип не может быть определен во время выполнения. JRE не нуждается в знании типов в generics, поэтому хранит только одну скомпилированную версию generic-класса или функции независимо от числа использованных параметризованных типов. Поэтому нельзя использовать generics в объявлении static переменных и static методов.</br>
</p>
<p align="justify">
<b>Какие принципы ООП используются CSS. Привести примеры.</b></br>
Наследование, переопределение. Пример:</br>
A:link {</br>
Color: blue;</br>
Font-weight:    bold;</br>
}</br>
A:link:hover {</br>
       color: black;</br>
}</br>
</p>
<p align="justify">
<b>Mutable и  Immutable объекты. Привести примеры. Написать класс, который будет immutable.</b></br>
Mutable объекты могут изменять свое состояние после создания. Примеры из JDK: StringBuilder, Date.</br>
Immutable называются объекты, чье состояние не изменяется после создания. Примеры из JDK: String, Integer. Достоинства:</br>
• Просты в создании, тестировании, использовании</br>
• Автоматически потокобезопасны, не нуждаются в синхронизации</br>
• Не нужны конструктор копирования, и имплементация клонирования</br>
• Значение hashCode может быть кэшировано</br>
• Хорошо подходят как ключи Map и элементы Set</br>
Чтобы сделать класс Immutable:</br>
• Запретить перегрузку класса - сделать его final или использовать статическую фабрику и сделать конструктор private</br>
• Поля должны быть private и final</br>
• Создавать объект за один шаг, в отличие от идеологии JavaBeans (используя конструктор без аргументов и последовательность вызовов сеттеров)</br>
• Не описывать никаких методов (даже сеттеров), которые изменяют состояние объекта любым способом</br>
• Если класс имеет любые mutable поля – они должны защищенно копироваться (defensive copying) при передаче между классом и вызывающим его</br>
</p>
<p align="justify">
Пример immutable класса:</br>
Public final class Planet {</br>
	private final Double mass;		//immutable field</br>
       private final String name;		//immutable field</br>
       private final Date dateOfDiscovery;	//mutable field</br>
</p>
<p align="justify">
	public Planet(Double mass, String name, Date dateOfDiscovery) {</br>
		this.mass = mass;</br>
		this.name = name;</br>
		//this.dateOfDiscovery = dateOfDiscovery; 			//this is NOT private copy</br>
   //this.dateOfDiscovery = dateOfDiscovery.clone();			//private copy</br>
		this.dateOfDiscovery = new Date(dateOfDiscovery.getTime());	//private copy</br>
       }</br>
       public Double getMass() { return mass; }</br>
       public String getName() { return name; }</br>
       public Date getDateOfDiscovery() {</br>
       	return new Date(dateOfDiscovery.getTime());	//defensive copy of field</br>
       }</br>
}</br>
</p>
<p align="justify">
<b>Архитектура КЭШа в Hibernate.</b></br>
• Кэш первого уровня: привязан к сессии, нельзя отключить. Методы сессии:</br>
Flush() — синхронизирует объекты сессии с БД и в то же время обновляет сам кэш сессии</br>
Evict() — нужен для удаления объекта из кэша cессии</br>
Contains() — определяет находится ли объект в кэше сессии или нет</br>
Clear() — очищает весь кеш</br>
• Кэш второго уровня: привязан к объекту Session Factory. В конфигурационном файле включается использование кэша и указывается его поставщик. Популярные реализации: EHCache, OSCache, SwarmCache. Также надо сконфигурировать сам кэш и указать Hibernate-у, что кэшировать. Зависимости класса не кэшируются по умолчанию и должны указываться отдельно. Чтение из кэша 2го уровня происходит, если объект не был найден в кэше первого уровня</br>
• Кэш запросов, также как и кэш 2го уровня по умолчанию отключен. Похож на кэш второго уровня: тоже реализован как Map, только у того ключом выступает идентификатор объекта, а у этого – совокупность параметров запроса. Сами данные – это идентификаторы объектов, соответствующих совокупности критериев запроса. Поэтому – кэш запросов рационально использовать с кэшем второго уровня</br>
Для контроля кэширования рекомендуется включать логгирование запросов.</br>
</p>
<p align="justify">
<b>JUnit. Что это такое? Принцип написания.</b></br>
Junit 3:</br>
Для создания теста нужно унаследовать тест-класс от TestCase, переопределить методы setUp и tearDown если надо, создать тестовые методы (должны начинаться с test). При запуске теста сначала создается экземпляр тест-класса (для каждого теста в классе отдельный экземпляр класса), затем выполняется метод setUp, запускается сам тест, ну и в завершение выполняется метод tearDown. Если какой-либо из методов выбрасывает исключение, тест считается провалившимся.</br>
Можно группировать тесты, вызывая их один за одним (класс TestSuite).</br>
Можно запустить один и тот же тест несколько раз (класс RepeatedTest).</br>
Наследуя тест-класс от ExceptionTestCase, можно проверить что-либо на выброс исключения.</br>
</p>
<p align="justify">
Junit 4:</br>
Добавлена поддержка возможностей Java 5, тесты могут быть объявлены с помощью аннотаций. Есть обратная совместимость, за исключением RepeatedTest.</br>
@Before обозначает public void методы, вызываемые до исполнения теста (его предустановки).</br>
@BeforeClass обозначает public static void методы, вызываемые до создания экземпляра тест-класса.</br>
@After обозначает public void методы, вызываемые после выполнения теста. Здесь размещаются операции освобождения ресурсов после теста.</br>
@AfterClass связана по смыслу с @BeforeClass, но выполняет public static void методы после теста, как и в случае с @BeforeClass.</br>
@Test обозначает тестовые public void методы. Здесь размещаются сами проверки. Есть 2 параметра: expected — задает ожидаемое исключение и timeout — задает время, по истечению которого тест считается провалившимся.</br>
Также есть правила - некое подобие утилит для тестов, которые добавляют функционал до и после выполнения теста. Например, встроенные правила для задания таймаута для теста (Timeout), для задания ожидаемых исключений (ExpectedException), для работы с временными файлами (TemporaryFolder) и др. Для объявления правила необходимо создать public не static поле типа, производного от MethodRule и зааннотировать его с помощью @Rule.</br>
</p>
<p align="justify">
<b>Пакеты в java. Зачем применяются? Принцип именования пакетов.</b></br>
Пакет содержит группу классов, объединенных в одном пространстве имен (пакеты помогают разрешить конфликт имен, когда различные классы содержат одинаковые имена). Создание пакета всегда неявно сопряжено с определением структуры каталогов. Пакет обязан находится в одноименном каталоге.</br>
Применяются для создания библиотек классов для их повторного использования и для защиты данных от использования посторонними классами.</br>
Принцип именования пакетов: компоненты доменного имени перечисляются в обратном порядке. Последним указывается слово, соответствующее назначению классов в этом пакете.</br>
</p>
<p align="justify">
<b>Индексы в БД. Первичный и внешний ключи. Каков будет результат запроса по получению среднего значения по колонке, если в ней существует ячейка с null-значением?</b></br>
Индекс – объект БД, создаваемый с целью повышения производительности поиска данных. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.</br>
Первичный ключ (ПК) не позволяет вносить в таблицу дубли. Т.е. кандидат в первичные ключи - перечень полей, по которому 2 записи гарантированно отличаются. В качестве ПК обычно выбирается тот потенциальный ключ, у которого меньше размер физического хранения.</br>
Внешний ключ не позволяет, чтобы в подчиненной таблице какие-то записи ссылались на несуществующие записи главной таблицы, т.е. отвечает за целостность БД. Создавая внешний ключ, мы говорим серверу, что некоторое поле в таблице будет содержать значение первичного ключа записи из другой или этой же таблицы (или поле с ограничением UNIQUE).</br>
Например: нельзя, чтобы в заказе №5 была строка "карандаши 8 шт", если заказа №5 не существует.</br>
Получение среднего по колонке: select avg(rowa) from table_a. При наличии ячейки с null-значением будет выведено среднее, как будто этой ячейки нет.</br>
</p>
<p align="justify">
<b>Web-сервисы: что это и для чего применяются? Основные положения модели веб-сервисов. Можно ли веб-сервис запустить на Томкате? Как, кроме как через xml, может быть налажено взаимодействие с помощью веб-сервисов?</b></br>
Веб-сервис/веб-служба – идентифицируемая веб-адресом программная система со стандартизированными интерфейсами. Веб-служба является единицей модульности при использовании сервис-ориентированной архитектуры приложения. Недостатки: больший размер сетевого трафика.</br>
Веб-сервисы – это технология. По сути – это реализация интерфейсов обмена данными между различными приложениями, написанными на разных языках и распределенными на разных узлах сети. Наиболее распостранены 3 протокола реализации веб-сервисов:</br>
• SOAP (Simple Object Access Protocol), произошел от XML-RPC, более надежен и безопасен</br>
• REST (Representational State Transfer – передача состояния представления). Применяется, когда нужен только CRUD, более производителен. Данные передаются в виде небольшого кол-ва стандартных форматов (HTML, XML, JSON), сетевой протокол (как и HTTP) не должен сохранять информацию о состоянии между парами “запрос-ответ”. WWW соответствует архитектуре REST</br>
• XML-RPC (XML Remote Procedure Call) – немного устарел</br>
Существует много уже готовых веб-сервисов (в каталогах веб-сервисов).</br>
• лицо, ответственное за веб-сервис, определяет формат запросов к своему веб-сервису и его ответов</br>
• любой компьютер в сети делает запрос к веб-сервису</br>
• веб-сервис обрабатывает запрос, выполняет какое-либо действие, затем отправляет ответ</br>
Веб-сервис можно запустить на Томкате. Взаимодействие с помощью веб-сервисов может осуществляться через xml, json (текстовый формат, основанный на JavaScript, строится на двух структурах: набор пар ключ-значение и пронумерованный набор значений).</br>
Структура сообщения SOAP:</br>
SOAP-конверт</br>
	SOAP-заголовок</br>
	   Элемент заголовка 1</br>
      Элемент заголовка 2</br>
      ...</br>
      Элемент заголовка N</br>
   Тело SOAP</br>
      Элемент тела N</br>
      ...</br>
      Элемент тела 2</br>
      Элемент тела 1</br>
SOAP является протоколом обмена структурированными сообщениями в распределенной вычислительной среде. Недостатки: увеличивает объем сообщений, замедляет обработку, некоторый программы генерируют сообщения в несовместимом формате.</br>
</p>
<p align="justify">
<b>Где используются http методы PUT, DELETE, GET, POST? </b></br>
В веб-сервисах, реализованных с помощью протокола REST. </br>
</p>
<p align="justify">
<b>Чем отличается OutOfMemoryError от StackOverflowError? Как их избежать?</b></br>
OutOfMemoryError выбрасывается, когда JVM не может выделить память в куче для создания объекта. Как избежать: увеличить максимальный размер кучи (параметр JVM).</br>
Пространство стека расположено в верхней части адресного пространства, а кучи – в нижней части. Когда размер стека увеличивается, он растет вниз (по пространству адресов). Когда растет куча, она растет вверх. Когда они “сталкиваются” - происходит StackOverflowError. Обычно это происходит при рекурсии. Как избежать: писать оптимальнее.</br>
</p>
<p align="justify">
<b>На сервере лежит pdf документ. Как при запросе пользователя предложить сохранить документ, а как открыть в браузере?</b></br>
Надо добавить заголовки HTTP-ответа, помогающие удержать браузер от попытки отобразить посылаемые байты в своем окне:</br>
Response.setContentType("application/pdf");</br>
Response.addHeader("Content-Disposition", "attachment; filename=" + fileName);</br>
Response.setContentLength((int)pdf.length());</br>
Поле заголовка Content-Disposition предлагает клиенту рассматривать получаемое содержимое как вложение, а не как символы для отображения в браузере. Он сам предложит пользователю диалог открыть/сохранить.</br>
</p>
<p align="justify">
<b>Какие библиотеки javascript-овые использовал? Написать на jQuery что-нибудь.</b></br>
Использовал Ajax.</br>
</p>
<p align="justify">
<b>Что знаешь про Unicode? UTF-8: описание кодировки. Чем отличается UTF-8 от UTF-16?</b></br>
Unicode – стандарт кодирования символов, позволяющий представить знаки практически всех письменных языков.</br>
UTF-8 – представление Юникода, обеспечивающее наилучшую совместимость со старыми системами, использовавшими 8-битные символы. Текст из символов с кодом <128 при записи в UTF-8 превращается в обычный ASCII текст (это приводит к тому, что даже если программа не распознает Unicode, то латинские буквы, арабские цифры и знаки препинания буду отображаться правильно). Остальные символы Юникода изображаются последовательностями длиной от 2 до 4 байт.</br>
UTF-16 – представление Юникода (в виде последовательности 16-битных слов), в котором символы кодируются 2 или 4 байтами. UTF-8 дает выигрыш по объему.</br>
В отличие от UTF-16, UTF-8 является самосинхронизирующейся кодировкой (при потере байта последующие будут раскодированы верно).</br>
</p>
<p align="justify">
<b>Что такое classloader? Если изменить static переменную в классе, загруженном одним classloader, что будет видно в том же классе, загруженном другим? А синглтоны так можно несколько раз делать?</b></br>
Classloader - загрузчик классов. Когда JVM запущена, используются 3 classloader-а:</br>
• Bootstrap – вершина иерархии Classloader-ов. Именно он загружает классы Core Java</br>
• Extensions – загружает библиотеки из lib/ext. Наследуется от Bootstrap</br>
• System – загружает классы из classpath. Наследуется от Extension</br>
Пользователь может написать собственный загрузчик, унаследовав его от java.lang.ClassLoader. Класс в JVM однозначно определяется своим полным именем и Classloader-ом, который его загрузил: изоляция ядра приложения.</br>
Classloader-наследник видит все свои классы и классы, загруженные родителем; классы потомков – не видит (более того: для JVM – это разные классы, при приведении даже выдаст ClassCastException). По умолчанию класс ищется сначала в родительском загрузчике, потом - в том, у которого он был запрошен. Загрузить один и тот же класс в одной ветке иерархии загрузчиков нельзя. Можно в разных ветках.</br>
Поэтому, если изменить static поле в классе, загруженном одним classloader, то в классе, загруженном другим, значение переменной не изменится. С синглтоном то же самое.</br>
Использовать класс из другого Classloader-а можно только при помощи reflection API.</br>
Статическая загрузка класса – загрузка при помощи оператора “new”.</br>
Динамическая загрузка класса – программный вызов функций classloader-а во время выполнения:</br>
Class vehicleClass = Class.forName(“com.epam.autoshop.Vehicle”);</br>
Jeep myJeep = (Jeep)vehicleClass.newInstance();</br>
</p>
<p align="justify">
<b>Команда в командной строке, чтобы просмотреть все открытые порты.</b></br>
• Win: netstat –b</br>
• *NIX: netstat -an</br>
</p>
<p align="justify">
<b>Как реализуется String, какие поля там есть? Принцип работы и реализация HashTable.</b></br>
Класс String содержит 3 основные final поля: массив символов, длина строки и сдвиг в массиве. При помощи сдвига реализуется метод substring, который не копирует содержимое массива, а использует ссылку на оригинальный массив и выставляет соответствующие поля длины строки и сдвига.</br>
Сравнение объектов в java осуществляется оператором == (сравнивает ссылки на один и тот же объект) или методом equals(), который сравнивает, содержат ли объекты одни и те же данные. Для сравнения String можно использовать оператор == в таком синтаксисе:</br>
If(s1.intern() == s2.intern()) {...} //производительность выше, чем с equals</br>
При вызове intern() строка помещается в пул строк, если такой там еще нет. Пул располагается в PermGen, реализуется через HashTable (см. п.Коллекции).</br>
</p>
<p align="justify">
<b>Что входит в J2EE?</b></br>
Кратко: J2SE используется для разработки настольных приложений, J2EE - для серверных.</br>
JRE (Java Runtime Environment) - cреда выполнения Java-приложений.</br>
J2SE - стандартный JDK, включающий JRE, транслятор языка, стандартные библиотеки классов и некоторые важные утилиты.</br>
J2EE - надстройка над J2SE, включающая библиотеки и утилиты для разработки в основном связанной с построением серверных приложений. В состав J2EE входят EJB (Enterprise Java Beans), сервлеты, JSP, JMS (Java Message Service), etc.</br>
Хотя такие фреймворки как hibernate, spring вместе с J2SE позволяют реализовать ту же функциональность без использования J2EE.</br>
</p>
<p align="justify">
<b>Что такое two-phase commit?</b></br>
Когда транзакция подразумевает изменения сразу в нескольких БД, используется two-phase commit: изменения, соответствующие транзакции, сохраняются временно в каждой БД. Монитор транзакций посылает “pre-commit” команду каждой БД, и ожидает подтверждения. Если монитор получает соответствующий ответ от каждой БД, он посылает “commit” команду, после чего все БД делают транзакционные изменения постоянными.</br>
</p>
<p align="justify">
<b>В чём отличия Statement от PrepareStatement? Будет ли тот же эффект как и от PrepareStatement, если формировать запрос просто в строке и отправлять его в  Statement? В чем отличия executeUpdate от executeQuery?</b></br>
PreparedStatement содержит прекомпилированный SQL-запрос. Он используется для эффективного запуска запроса многократно. Параметры устанавливаются set-методами.</br>
PreparedStatement имеет методы:</br>
• executeQuery() – выполняет SQL-запрос; возвращает объект ResultSet. Обычно используется для чтения содержимого БД, вместе с SELECT</br>
• executeUpdate() – выполняет SQL-запрос, который должен быть одним из: INSERT, UPDATE, DELETE или быть запросом, который не возвращает ничего, как, например, DDL-запрос. Обычно используется для модификации содержимого БД. Возвращает число строк, подвергнутых действию запроса</br>
• execute() – выполняет SQL-запрос; может быть любым SQL-запросом. Возвращает TRUE, если запрос вернул ResultSet</br>
	Если формировать запрос в строке и отправлять в Statement, того же эффекта, как от использования PreparedStatement  не будет.</br>
</p>
<p align="justify">
<b>Какие есть SQLException?</b></br>
SQLException предоставляет информацию об ошибках доступа к БД или других ошибках. Каждое SQLException предоставляет информацию:</br>
• Строка, описывающая ошибку (доступна через метод getMessage)</br>
• Строка SQLstate, описывающая ошибку в соответствие с конвенцией. Тип конвенции (XOPEN SQLstate или SQL:2003) можно получить: DatabaseMetaData.getSQLStateType()</br>
• Integer код ошибки, обычно соответствующий коду, возвращенному из самой БД</br>
• Цепочка (chain) к следующему Exception. Используется для получения дополнительной информации об ошибке</br>
Виды SQLException: BatchUpdateException, RowSetWarning, SerialException, SQLClientInfoException, SQLNonTransientException, SQLRecoverableException, SQLTransientException, SQLWarning, SyncFactoryException, SyncProviderException.</br>
</p>
<p align="justify">
<b>Можно ли вернуться в ResultSet предыдущую строку, как? Всегда ли это можно сделать?</b></br>
Класс ResultSet содержит курсор, указывающий на текущую строку в таблице данных, полученную в результате запроса к БД. Изначально курсор установлен до первой строки. Методы next() и previous() осуществляют навигацию по строкам таблицы, возвращают false – если “уперлись” в край таблицы. Любое использование у ResultSet метода, которому необходима текущая строка, приводит к SQLException.</br>
Типы ResultSet:</br>
• ResultSet.TYPE_FORWARD_ONLY – по умолчанию. Курсор может двигаться только вперед</br>
• ResultSet.TYPE_SCROLL_INSENSITIVE – курсор может двигаться в обе стороны, но ResultSet нечувствителен к изменениям, вносимым в БД другими</br>
• ResultSet.TYPE_SCROLL_SENSITIVE – то же, но ResultSet чувствителен к изменениям, вносимым в БД другими</br>
Многопоточность ResultSet:</br>
• ResultSet.CONCUR_READ_ONLY, по умолчанию</br>
• ResultSet.CONCUR_UPDATABLE</br>
</p>
<p align="justify">
Пример:</br>
Statement stmt = connection.createStatement(</br>
			      ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);</br>
ResultSet rs = stmt.executeQuery(sqlQuery);</br>
Rs.last();			// Set cursor after last element</br>
While (rs.previous()) {      	// Move the cursor backwards through the ResultSet</br>
	...</br>
}</br>
</p>
<p align="justify">
<b>Static поле - что такое? Что будет, если его изменить через объект класса? Всегда ли static поле содержит одинаковые значения для всех его объектов?</b></br>
Поле static имеет одно и то же значение для всех экземпляров класса. Изменение значения через объект класса ведет к изменению значения у всех экземпляров класса. Значение static поля может (временно) различаться у экземпляров класса в многопоточной среде: см. volatile.</br>
</p>
<p align="justify">
<b>Можно ли запустить Tomcat на 22 порту?</b></br>
Да, но порт может быть занят под SSH (Secure Shell)</br>
</p>
<p align="justify">
<b>Найти js'ом параграф с заданным id и изменить его цвет.</b></br>
Document.getElementById(id).setAttribute(“style”,”color:red”);</br>
</p>
<p align="justify">
<b>Из чего состоит url?</b></br>
В www для задания местоположения файлов на других серверах сети Internet используется URL (Uniform Resource Locator / единообразный локатор ресурса). Он включает в себя:</br>
• метод доступа к ресурсу (т.е. протокол доступа (http, ftp, file,…))</br>
• сетевой адрес ресурса (имя хост-машины и домена или IP-адрес хоста)</br>
• полный путь к файлу на сервере</br>
В общем виде формат URL выглядит так:</br>
Method://[login:password@]host.domain[:port]/path/filename?parametres</br>
URI — это символьная строка, позволяющая идентифицировать какой-либо ресурс.</br>
</p>
<p align="justify">
<b>Есть 2 класса css. В одном font-size в поинтах, другой в пикселях. Всегда ли они будут отображаться одинаково?</b></br>
Имеется 4 единицы для font-size: em, px, pt, percent:</br>
• em – масштабируемая единица, равна текущему font-size</br>
• px – фиксированный размер единиц, 1px = размеру пикселя экрана</br>
• pt – фиксированный размер единиц, 1pt = 1/72 дюйма (реальных, а не на экране); обычно используется в печатных СМИ для “print CSS”</br>
• % - похож на em, текущий font-size = 100%</br>
Ответ на вопрос: в общем случае – нет, не всегда (размер пикселя может различаться).</br>
</p>
<p align="justify">
<b>ORM, JPA features. POJO-класс.</b></br>
ORM (Object Relational Mapping – объектно-реляционное отображение (проекция)) – технология программирования, связывающая БД с концепциями ООП (с объектными структурами в памяти приложения), создавая “виртуальную объектную БД”.</br>
Реляционная модель ориентирована на организацию данных в виде двумерных таблиц. Каждая реляционная маблица – двумерный массив.</br>
По сравнению с традиционными подходами к обмену между ОО языком и реляционной БД, ORM уменьшает кол-во кода, которое необходимо написать. Недостатки ORM в том, что большинство O/R инструментов проприетарны. Большинство O/R инструментов не обеспечивают быстрое одновременное удаление больших порций данных и связей (joins). Хранимые процедуры имеют лучшую производительность, но не портируемы. Также, большое доверие к ORM-софту является основным фактором при производстве плохо спроектированных БД.</br>
Альтернативные виды БД - noSQL БД: ООСУБД (объектно-оиентиованные СУБД), ДОБД (документоориентированные БД (XML БД)).</br>
JPA (Java Persistence API) – API для объектно-реляционного мэпинга. Часть Java EE платформы, также может использоваться в Java SE.</br>
Преимущества JPA:</br>
• Аннотации объявляются прямо в классах модели, что экономит много времени разработчика</br>
• Поддерживают наследование, полиморфизм, полиморфные запросы</br>
• JPA является спецификацией; могут 	использоваться различные ее реализации (Hibernate, TopLink)</br>
• Поддерживает платформенно-независимый язык запросов (JPQL)</br>
• Генерация DDL (Data Definition Language) для сущностей</br>
POJO (Plain Old Java Object) – простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий интерфейсов больше тех, что нужны для бизнес-модели. Термин был придуман, как противопоставление EJB (Enterprise JavaBeans). Концепция POJO появилась как результат поиска путей облегчения и упрощения методов программирования. Класс POJO должен:</br>
• Должен иметь (хотя бы) пустой конструктор (public или protected)</br>
• Не может быть вложенным, интерфейсом или enum</br>
• Не может быть final и не должен содержать final поля/св-ва</br>
• Содержать хотя бы одно @Id поле</br>
</p>
<p align="justify">
<b>Различия интерфейсов Transformer и Templates.</b></br>
Для выполнения XSLT преобразований может быть использовано 2 подхода:</br>
• Получить экземпляр Transformer у TransformerFactory:</br>
TransformerFactory factory = TransformerFactory.newInstance(); </br>
Transformer transformer = factory.newTransformer(inputXSL); </br>
При таком подходе:</br>
	= объект Transformer обрабатывает таблицу стилей XSL каждый раз при вызове transform()</br>
	= экземпляры Transformer не являются потокобезопасными. Нельзя использовать один и тот же материал в разных потоках</br>
Решением этих проблем является второй подход:</br>
•  Использование интерфейса Templates, который потокобезопасен и представляет компилированную таблицу стилей</br>
TransformerFactory factory = TransformerFactory.newInstance();</br>
Templates templates = factory.newTemplates(inputXSL);	// Предкомпиляция команд</br>
Transformer transformer = templates.newTransformer();</br>
	Т.е. основные отличия: Templates прекомпилирует XSL и потокобезопасен.</br>
</p>
<p align="justify">
<b>Что такое представление БД (database VIEW)?</b></br>
Представление БД (database VIEW) – виртуальная таблица, представляющая собой именованный запрос, который будет подставлен как подзапрос при использовании представления. В отличие от обычных таблиц БД, представление не является самостоятельной частью набора данных, хранящегося в базе. Содержимое представления динамически вычисляется на основании данных, находящихся в реальных таблицах. Изменение данных в реальной таблице БД немедленно отражается в содержимом всех представлений, построенных на основании этой таблицы. Представление может содержать все содержимое БД или его часть, результат обработки данных определенными операциями, данные из нескольких таблиц или практически любую комбинацию перечисленных вариантов.</br>
Представление используется в рамках запроса к БД как обычная таблица.</br>
В ORM представлением является хранимый запрос, доступный как виртуальная таблица.</br>
</p>
<p align="justify">
<b>Требования к JavaBeans-классам.</b></br>
JavaBeans – повторно используемые программные компоненты. Используются для объединения несколько объектов в 1 (bean – фасоль, кофейное зерно) для удобной передачи данных. JavaBeans – Java-классы, написанные по определенным правилам:</br>
= Класс должен иметь public конструктор без параметров</br>
= Св-ва класса должны быть доступны через get, set и другие методы, которые должны подчиняться стандартному соглашению об именах</br>
= Класс должен быть сериализуем, чтобы надежно сохранять, хранить и восстанавливать состояние bean независимо от платформы и виртуальной машины</br>
Некоторые разработчики рассматривают JavaBeans, как POJO.</br>
</p>
<p align="justify">
<b>Что будет, если скомпилировать и запустить этот код ((SomeClassType)null).staticMethod() ?</b></br>
При вызове статического метода через экземпляр класса все равно вызывается метод класса. Метод выполнится без проблем.</br>
</p>
<p align="justify">
<b>XSD vs DTD. Основные директивы XSD</b></br>
Для описания схемы документа XML можно использовать DTD (Document Type Definition) или схемы XML. Схемы XML создаются на одном из языков описания схем XML, например XSD (XML Schema Definition (by W3C)) или XDR (XML-Data Reduced (by Microsoft)).</br>
Идет отказ от использования DTD в XML-технологии, т.к. в DTD:</br>
1. Используется отличный от XML синтаксис</br>
2. Отсутствует типизация узлов</br>
3. Отсутствует поддержка пространства имен</br>
Схема XML документа содержит:</br>
1. Словарь (названия эл-тов и атрибутов)</br>
2. Модель содержания (отношения между эл-тами и атрибутами и их структура)</br>
3. Типы данных</br>
Также удобством XML схемы является то, что один словарь может ссылаться на другой, т.е. можно использовать уже существующие словари.</br>
Основные директивы XSD: xs:schema, xs:element, xs:annotation, xs:simpleType, xs:simpleContent, xs:complexType.</br>
</p>
<p align="justify">
<b>SQL-injection.</b></br>
SQL-инъекция (внедрение SQL-кода) – один из распространенных способов взлома сайтов и программ, работающих с БД. Основан на внедрении в запрос инородного SQL-кода, что может дать атакующему выполнить произвольный запрос к БД, получить возможность чтения и/или записи локальных файлов и выполнения произвольных команд на атакуемом сервере.</br>
Примеры инъекций:</br>
• Внедрение в строковые параметры</br>
• Использование UNION (для объединения результатов запросов)</br>
• Использование UNION+group_concat() (для объединения нескольких колонок в одну)</br>
• Экранирование части запроса (при помощи символа комментария)</br>
• Расщепление SQL-запроса, т.е. выполнение нескольких команд в одном запросе (разделение команд символом ;)</br>
Способы защиты от инъекций:</br>
• Фильтрация строковых параметров (кавычками)</br>
• Фильтрация целочисленных параметров (проверкой типа)</br>
• Усечение длины входных параметров запроса перед вызовом SQL-запроса</br>
• Использование параметризованных запросов (PreparedStatement)</br>
</p>
<p align="justify">
<b>Access plan.</b></br>
Access plan (план выполнения запроса) – упорядоченная последовательность операций, необходимых для получения результата SQL-запроса в реляционной СУБД. Обусловлено декларативной природой SQL (указывается логика вычислений без описания порядка выполнения). Это приводит к тому, что существует обычно большое кол-во альтернативных путей выполнения заданного запроса с различной производительностью.</br>
Оптимизатор запросов (компонент СУБД) использует хранящуюся в БД статистическую информацию, на основе которой оценивает альтернативные способы формирования результатов запроса для выбора наиболее эффективного. Изучение планов выполнения запросов, созданных оптимизатором, позволяет решить, как ускорить выполнение запроса – изменить сам запрос или создать в базе дополнительный индексы.</br>
</p>
<p align="justify">
<b>Connection pool (преимущества использования).</b></br>
Connection pool – кэш/набор соединений с БД; может использоваться вновь в будущих запросах к БД для улучшения производительности. Когда необходим доступ к БД, выдается уже открытое соединение из пула. Если все открытые соединения уже заняты – создается новое. Освобожденное соединение возвращается в пул. Если соединение не используется заданное время – оно закрывается. </br>
Создание нового соединения с БД – ресурсоемкая операция, поэтому использование пула соединений экономит ресурсы.</br>
</p>
<p align="justify">
<b>Отличия одиночных и сдвоенных операндов (например, & и &&).</b></br>
В случае использования одиночных операндов в логическом выражении, будут вычисляться все выражения; в случае использования сдвоенных – только те, что необходимы для принятия решения. Пример: String a=null; if (a!=null && a.length()>10) {...}</br>
Единичный амперсанд вызовет NullPointerException.</br>
</p>
<p align="justify">
<b>Поверхностное и глубокое копирование (shallow & deep copy)</b></br>
При поверхностном копировании не копируются внутренние объекты класса. Для легкого и быстрого глубокого копирования может использоваться сериализация.</br>
</p>
<p align="justify">
<b>Композиция и агрегация.</b></br>
Композиция и агрегация обе есть ассоциация, в которой один класс принадлежит набору. Композиция имеет сильную связь (удаляем целое и его части не могут существовать самостоятельно), агрегация – слабую (части могут существовать самостоятельно).</br>
</p>
<p align="justify">
<b>В Java используется передача по ссылке или по значению?</b></br>
Всегда используется передача по значению (т.е. передается копия). Но: если переданный параметр сам является ссылкой, - передается копия ссылки, указывающей на те же данные (который таким образом могут быть изменены).</br>
</p>
<p align="justify">
<b>Enum</b></br>
Enum – перечисления. Пример: enum Season { WINTER, SPRING, SUMMER, AUTUMN }.</br>
Перечисление – это класс, (неявно) производный от java.lang.Enum (явно унаследоваться нельзя).</br>
Элементы перечисления – экземпляры enum-класса, доступные статически. Можно получить имя эл-та, его номер (с 0), элемент по его строковому представлению, все эл-ты сразу функциями соответственно: name, ordinal, valueOf, values.</br>
В enum можно добавить свои методы. Использование generics в enum – запрещено, т.е. enum Type<T> {} – не скомпилируется.</br>
</p>
<p align="justify">
<b>Регулярные выражения</b></br>
Формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров).</br>
Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться:</br>
{n} – ровно n раз,</br>
{m,n} – от m до n раз включительно,</br>
{m,} – не менее m</br>
{,n} – не более n</br>
Группы выделяются круглыми скобками для определения области действия и приоритета операций.</br>
Диапазон указывается квадратными скобками:</br>
[0-7a-z] – цифра от 0 до 7 и буква из диапазона a-z,</br>
[abc] – a или b или c,</br>
[^abc] – не один из (a или b или c),</br>
</p>
<p align="justify">
<b>Алгоритмы сортировки, их устойчивость. Алгоритмы поиска (в списке эл-тов).</b></br>
</p>
<p align="justify">
<b>Есть телефонный справочник с полями (Имя, Адрес, Телефон). В какой структуре данных хранить данные, чтобы выполнялся быстрый поиск по телефонному номеру; по каждому из полей?</b></br>
</p>
<p align="justify">
<b>Использовал ли сборщики Ant, Maven? Какие системы SVС использовал? Для чего они?</b></br>
</p>
<p align="justify">
<b>Тестирование: есть последовательность действий, в том числе сон основного потока на длительное время. Как проверить данный класс (быстро)?</b></br>
</p>
<p align="justify">
<b>Можно ли передавать по JSON объекты?</b></br>
</p>
<p align="justify">
<b>Что такое хешкод? Почему хэшированные структуры данных быстрее?</b></br>
Хешкод - функция, сопоставляющая данному состоянию объекта - целое число.</br>
Хэшированные структуры данных быстрые, т.к. позволяют находить нужный элемент за О(1), т.е. скорость не зависит от размера структуры данных.</br>
</p>
<p align="justify">
<b>Выполняется статический метод. Можно ли сделать, чтобы одновременно выполнялась его вторая копия?</b></br>
</p>
<p align="justify">
<b>В куки пишет клиент или сервер?</b></br>
</p>
<p align="justify">
<b>Что возвращает Class.forName()? Зачем?</b></br>
</p>
<p align="justify">
<b>Чем занимался раньше? Был ли опыт программирования и на чем? Сколько лет пишешь именно на Java? Был ли опыт тестирования?</b></br>
</p>
<p align="justify">
<b>Два утверждения: “объекты равны” и “у них одинаковый хэш-код”. Какая связь между ними?</b></br>
Если объекты равны - то их хэшкоды одинаковы,</br>
Если хэшкоды одинаковы - объекты могут быть и не равны, т.к. есть коллизия кэша</br>
</p>
<p align="justify">
<b>2-way SSL, materialized view, хинты в БД, 4 основных блока wsdl файла</b></br>
</p>
<p align="justify">
<b>Как добавить аутентификацию soap-сервису? как она работает?</b></br>
</p>
<p align="justify">
<b>Для чего having в sql запросе?</b></br>
Where определяет предикат для фильтрации строк,</br>
Having определяет аналогичный предикат для фильтрации после группировки</br>
Порядок операторов в запросе: select ... from ... where ... [group by ... having ...] order by</br>
</p>
<p align="justify">
<b>Как используя jdbc работать с 2 базами одновременно / будут ли проблемы</b></br>
</p>
<p align="justify">
<b>Что нового в Java 7, 8?</b></br>
</p>
<p align="justify">
<b>Задача на "сдвинуть элементы внутри массива на 2 позиции (сдвинутые элементы должны появится слева)" - различные способы решения. можно ли использовать здесь Queue, Deque, FILO, FIFO, сложность каждого написанного алгоритма, какие еще есть алгоритмы и тп. тут же - Array.copy</b></br>
</p>
<p align="justify">
<b>Сложность поиска в дереве (log(n))</b></br>
</p>
<p align="justify">
<b>Equals, hashCode, как бы сам писал hashCode</b></br>
</p>
<p align="justify">
<b>Как работает HashMap (подробно вплоть до как вычисляется номер бАкета), TreeMap, какие интерфейсы имплементят</b></br>
</p>
<p align="justify">
<b>Приходилось ли чинить продакшн и как?</b></br>
</p>
<p align="justify">
<b>Какой самый распостраненный класс в жава приложении?</b></br>
String</br>
</p>
<p align="justify">
<b>Static final метод, его наследование</b></br>
</p>
<p align="justify">
<b>Итератор, его методы</b></br>
Итератор реализует методы next(), hasNext() и дополнительно может поддерживать метод remove()</br>
</p>
<p align="justify">
<b>Что произойдет, когда при итерировании в цикле удалим один из объектов коллекции?</b></br>
Получим ConcurrentModificationException</br>
Для того чтобы удалять корректно - надо итерироваться итератором и удалять при помощи его метода remove()</br>
</p>
<p align="justify">
<b>Что такое индекс в базе?</b></br>
Структура данных, позволяющая быстро (за время О(1) или О(log(n))) осуществлять поиск в данных</br>
Это может быть хэш-таблица либо дерево</br>
</p>
<p align="justify">
<b>Идемпотентность. методы get, delete, put. Когда для CRUD можно обойтись без POST?</b></br>
</p>
<p align="justify">
<b>Зачем string сделал immutable, что при этом декларировалось разработчиками</b></br>
</p>
<p align="justify">
<b>Детально что происходит при работе с PreparedStatement - на каком слое и что</b></br>
</p>
<p align="justify">
<b>Есть 2 таблицы: Books(id, name, year, auth_id), Authors(id, name). Написать запрос, чтобы вывести имена авторов, кто написал не более 3 книг в 2016 году отсортированными по имени</b></br>
Select a.id, a.name, count(a.id) from Authors a left join Books b on a.id=b.auth_id group by a.id having count(a.id) <=3 order by a.name;</br>
</p>
<p align="justify">
<b>Написать метод для вычисления чисел Фибоначчи. как его оптимизировать, какова сложность каждого метода</b></br>
</p>
<p align="justify">
<b>Назвать паттерны которые знаешь. какие проблемы решает каждый паттерн?</b></br>
</p>
<p align="justify">
<b>Зачем нам Spring, можно ли без него? как Hibernate реализует доставание lazy объектов?</b></br>
</p>
<p align="justify">
<b>Нарисовать архитектуру вашего приложения</b></br>
</p>
<p align="justify">
<b>У вас stateless сервисы? Почему?</b></br>
</p>
<p align="justify">
<b>Типы ссылок в Java</b></br>
</p>
<p align="justify">
<b>Что сделали в Java 8 с HashMap для улучшения перфоманса?</b></br>
</p>
<p align="justify">
<b>Перечислить и вкратце описать технологии стека J2EE</b></br>
Servlets, xml, jdbc, jta, jndi, jsp+jstl, jpa, jax-ws+jax-rs, jms</br>
</p>
<p align="justify">
IoC - привести пример</br>
IoC - важный принцип ООП, используемый для уменьшения зацепления.</br>
It's a design principle in which custom-written portions of a computer program receive the flow of control from a generic framework</br>
Has analogy with Hollywood Principle: "Don't call us, we'll call you"</br>
Критика IoC:</br>
<b>Логика взаимодействия программы разбросана по отдельным обработчикам событий или классам</b></br>
<b>Поток управления задан неявно и использует общее состояние (shared state) обработчиков событий</b></br>
IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the Service Locator pattern.</br>
Мартин Фаулер предложил переименовать принцип IoC в Dependency Injection, чтобы он имел имя соответствующее содержанию</br>
</p>
<p align="justify">
<b>Сервлетные фильтры</b></br>
</p>
<p align="justify">
<b>Какими св-вами должен обладать класс Spring-бина?</b></br>
</p>
<p align="justify">
<b>Какие есть теги jsp</b></br>
</p>
<p align="justify">
<b>Static method some_name() of class A, and static method with same signature in class B extends A. which method will run in next case: A a = new B(); a.some_name(); ?</b></br>
</p>
<p align="justify">
<b>Sax vs stax:</b></br>
The SAX push model means that it is the SAX parser that calls your handler, not your handler that calls the SAX parser. The SAX parser thus "pushes" events into your handler</br>
The StAX pull model means that it is your "handler" class that calls the parser, not the other way around. Thus your handler class controls when the parser is to move on to the next event in the input. In other words, your handler "pulls" the XML events out of the parser. Additionally, you can stop the parsing at any point</br>
</p>
<p align="justify">
<b>Написать сиквел на использование оконной функции</b></br>
</p>
<p align="justify">
<b>Как работает индекс в бд (какую структуру строит). композитный индекс</b></br>
</p>
<p align="justify">
<b>Ускоряет ли индекс работу с бд для запросов вида like?</b></br>
</p>
<p align="justify">
<b>Хэшкод и хэшмэп в жаве - как бы писал свои?</b></br>
</p>
<p align="justify">
<b>Как перемешать массив</b></br>
См. в другом файле с ответами (брать 2 случайных эл-та и менять их местами)</br>
</p>
<p align="justify">
<b>Описать жизненный цикл Spring-бина</b></br>
</p>
<p align="justify">
<b>Как запустить джоб после старта Spring-контекста?</b></br>
</p>
<p align="justify">
<b>Реализовать вручную функцию целочисленного деления int divide(int a, int b)</b></br>
</p>
<p align="justify">
<b>Ссылки на методы</b></br>
</p>
<p align="justify">
<b>В классе А определен метод а, в классе B extends A – такой же метод a, в классе C extends B – такой же метод a. Можно ли вызвать из класса C этот метод класса А?</b></br>
</p>
<p align="justify">
<b>Написать (двумя способами) sql-запрос, который выведет уникальные значения данного столбца</b></br>
</p>
<p align="justify">
<b>Методы класса Object</b></br>
ToString, hashCode, equals, getClass, notify, notifyAll, wait, wait(timeout), finalize, clone</br>
</p>
<p align="justify">
<b>Почему entity-класс не может быть final?</b></br>
</p>
<p align="justify">
<b>Каков размер объекта в JVM?</b></br>
<a href="https://topjava.ru/blog/how-to-get-the-size-of-an-object-in-java">https://topjava.ru/blog/how-to-get-the-size-of-an-object-in-java</a></br>
= Минимальный размер объекта для современного 64-битного JDK составляет 16 байт, так как объект имеет 12-байтовый заголовок, дополненный до размера, кратного 8-ми байтам. В 32-битной JDK, накладные расходы составляют 8 байт, дополненные до кратности 4-ем</br>
= Одним из способов получить размер объекта в Java является использование метода getObjectSize(Object) интерфейса Instrumentation, введенного в Java 5.</br>
Этот метод предоставляет приближенное значение размера объекта. Стоить отметить, что существует вероятность включения накладных расходов в размер. Значение размера конкретного объекта может изменяться во время работы JVM.</br>
Этот подход позволяет произвести только оценку рассматриваемого объекта, но не размеры объектов на которые он ссылается. Чтобы рассчитать полный размер объекта, нам необходим код, который пробежится по всем ссылкам и рассчитает примерный размер.</br>
</p>
<p align="justify">
<b>B-tree - что это такое?</b></br>
<a href="https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE</a></br>
B-tree - структура данных, дерево поиска. С точки зрения внешнего логического представления - сбалансированное, сильно ветвистое дерево. Часто используется для хранения данных во внешней памяти.</br>
Сбалансированность означает, что длина любых двух путей от корня до листьев различается не более, чем на единицу.</br>
Ветвистость дерева — это свойство каждого узла дерева ссылаться на большое число узлов-потомков. </br>
</p>
<p align="justify">
<b>Рассказать об утилите netstat</b></br>
<a href="https://ru.wikipedia.org/wiki/Netstat">https://ru.wikipedia.org/wiki/Netstat</a></br>
Netstat (network statistics) — утилита командной строки выводящая на дисплей состояние TCP-соединений (как входящих, так и исходящих), таблицы маршрутизации, число сетевых интерфейсов и сетевую статистику по протоколам. Она доступна на всех unix-подобных ОС, также существует и в основанных на Windows NT ОС</br>
</p>
<p align="justify">
<b>Рассказать об утилите tracert</b></br>
<a href="https://ru.wikipedia.org/wiki/Traceroute">https://ru.wikipedia.org/wiki/Traceroute</a></br>
Traceroute — служебная компьютерная программа, предназначенная для определения маршрутов следования данных в сетях TCP/IP. Traceroute может использовать разные протоколы передачи данных в зависимости от ОС устройства. Такими протоколами могут быть UDP, TCP, ICMP или GRE. Компьютеры с установленной ОС Windows используют ICMP-протокол, при этом ОС Linux и маршрутизаторы Cisco — протокол UDP.</br>
Traceroute входит в поставку большинства современных сетевых ОС. В системах Microsoft Windows эта программа носит название tracert, а в системах GNU/Linux, Cisco IOS и Mac OS — traceroute. </br>
</p>


<p align="justify">
<b>Как перемешать массив?</b></br>
<b>Дан набор строк вида "assa dfgg aga", найти 3й палиндром в строке / удалить все палиндромы</b></br>
<b>Реализовать бинарный серч</b></br>
See example in java-sandbox repo</br>
</p>
<p align="justify">
<b>Отличие хэштаблицы от хэшмапа</b></br>
<a href="https://www.geeksforgeeks.org/differences-between-hashmap-and-hashtable-in-java/">https://www.geeksforgeeks.org/differences-between-hashmap-and-hashtable-in-java/</a></br>
= HashMap is not synchronized, so not thread-safe; HashTable is syncronized</br>
= HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value</br>
= HashMap is generally preferred over HashTable if thread synchronization is not needed</br>
</p>
<p align="justify">
<b>Зачем -9 в kill</b></br>
<a href="https://linux.die.net/man/2/kill">https://linux.die.net/man/2/kill</a></br>
<a href="https://ru.wikipedia.org/wiki/SIGKILL">https://ru.wikipedia.org/wiki/SIGKILL</a></br>
Команде передается PID и сигнал. На большинстве платформ SIGKILL имеет значение 9; в отличие от SIGTERM или SIGINT этот сигнал не может быть перехвачен или проигнорирован, а процесс, получивший его не имеет возможности выполнить какие-либо действия перед своим завершением</br>
</p>
<p align="justify">
<b>LinkedHashSet</b></br>
<a href="http://developer.alexanderklimov.ru/android/java/set.php">http://developer.alexanderklimov.ru/android/java/set.php</a></br>
Если порядок хранения в множестве для вас важен, используйте контейнер TreeSet, в котором объекты хранятся отсортированными по возрастанию в порядке сравнения </br>
Или LinkedHashSet с хранением элементов в порядке добавления</br>
</p>
<p align="justify">
<b>Transient in Java</b></br>
Transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes. When an object is transferred through the network, the object needs to be 'serialized'. Serialization converts the object state to serial bytes</br>
</p>
<p align="justify">
<b>Git merge vs rebase (слияние или перемещение)</b></br>
<a href="https://git-scm.com/book/ru/v1/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5">https://git-scm.com/book/ru/v1/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5</a></br>
Это 2 способа включения изменений одной ветки в другую</br>
В случае слияния - создается новый снимок состояния на основе 2 других - ветки с коммитами и ветки куда мержим</br>
В случае перемещения - изменения в нашей ветке (дельта) применяются поверх ветки относительно которой выполняется перемещение</br>
Риски: "Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий"</br>
</p>
<p align="justify">
<b>Ты пришел на проект, где уже много всего написано, но еще нет тестов (trollface). какие тесты будешь писать первыми?</b></br>
Если почти нет разработки как таковой, а цель - зафиксировать тестами текущее состояние, то буду покрывать основные бизнес-кейсы. для этого привлеку BA, заодно можно написать или подправить имеющуюся документацию. общий подход - top-down, т.е. вначале покрывать самые высокоуровневые методы (видимо это будут методы бизнес логики), потом - спускаться ниже, к частностям</br>
Если ведется разработка - то буду точечно фиксировать состояние до ченжей и после; так постепенно покрытие будет увеличиваться.</br>
Также важно писать тесты в моменты фикса дефектов, причем для состояния "до фикса" они должны валиться, чтобы тесты были valuable</br>
</p>
<p align="justify">
<b>Как реализован compareAndSwap (CAS) под капотом</b></br>
<a href="https://dzone.com/articles/how-cas-compare-and-swap-java">https://dzone.com/articles/how-cas-compare-and-swap-java</a></br>
Смотрим, какое значение хранится в переменной. Если оно то, какое мы ожидаем, то меняем его на новое.</br>
Соответственно Atomic тип в цикле выполняет это действие</br>
</p>
<p align="justify">
<b>AtomicReference</b></br>
<a href="https://stackoverflow.com/questions/3964211/when-to-use-atomicreference-in-java">https://stackoverflow.com/questions/3964211/when-to-use-atomicreference-in-java</a></br>
An atomic reference is ideal to use when you need to share and change the state of an immutable object between multiple threads.</br>
Under the hood AtomicReference uses CAS algorithm, so we don't need to acquire lock before access to object</br>
</p>
<p align="justify">
<b>Хэшкод и хэшмэп в жаве - как бы писал свои?</b></br>
<a href="https://www.baeldung.com/java-hashcode">https://www.baeldung.com/java-hashcode</a></br>
Hashcode() - we could implement it by own hands (making math expression where fields hashcodes multiplied to prime numbers and summarized after that),</br>
Or generate by IDE, or use Apache Commons or Lombok annotation</br>
HashMap could be implemented using hastable based on buckets</br>
</p>
<p align="justify">
<b>Describe usage of dynamic proxy</b></br>
<a href="https://www.baeldung.com/java-dynamic-proxies">https://www.baeldung.com/java-dynamic-proxies</a></br>
Dynamic proxies allow one single class with one single method to service multiple method calls to arbitrary classes with an arbitrary number of methods. A dynamic proxy can be thought of as a kind of Facade, but one that can pretend to be an implementation of any interface. Under the cover, _it routes all method invocations to a single handler_ – the invoke() method</br>
</p>
<p align="justify">
<b>Польза использования простых чисел в хэшкод-related штуках</b></br>
Использование простых чисел в при вычислении хэшкода дает наилучшее распределение между бакетами, айтемы не кучкуются в одном месте</br>
</p>
<p align="justify">
<b>Агрегация vs композиция vs наследование</b></br>
<a href="https://habr.com/post/354046/">https://habr.com/post/354046/</a></br>
Агрегация - один класс содержит другой внутри себя (экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра)</br>
Композиция - когда составляющая часть не существует отдельно от целого (двигатель автомобиля создается при создании автомобиля и передается в его конструктор)</br>
Наследование - описывается словом "является"</br>
</p>
<p align="justify">
<b>Отличия и сходства adapter, decorator, wrapper, proxy</b></br>
<a href="https://ru.stackoverflow.com/questions/693654/%D0%92-%D1%87%D1%91%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%B8-%D1%81%D1%85%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D0%BE%D0%B2-adapter-decorator-wrapper-%D0%B8-proxy">https://ru.stackoverflow.com/questions/693654/%D0%92-%D1%87%D1%91%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%B8-%D1%81%D1%85%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D0%BE%D0%B2-adapter-decorator-wrapper-%D0%B8-proxy</a></br>
Wrapper - это синоним декоратора</br>
= Заместитель (proxy) оборачивает класс и предоставляет такой же интерфейс. Цель - "притвориться" оригинальным классом и скрыть от клиента детали. Типичные примеры использования - ленивая инициализация оборачиваемого класса или оборачивание вызовов стороннего сервиса</br>
= Декоратор также оборачивает класс и предоставляет такой же или расширенный интерфейс. Иногда декоратор называют "умным заместителем" (smart proxy). Т.е. декоратор может притворяться оригинальным классом и при этом расширять его функциональность. Пример: у вас есть заместитель, который прячет вызовы к стороннему сервису. Можно создать декоратор, который будет оборачивать и кэшировать результаты вызовов. Другой пример: нужно расширить функциональность оригинального класса, но он закрыт для наследования. Создается декоратор, который расширяет интерфейс оригинального класса</br>
= Адаптер также оборачивает класс, но при этом предоставляет другой интерфейс. Т.е. используется в случаях, когда есть класс с нужными данными и поведением, но с неподходящим интерфейсом</br>
---------------------------------------------------------------------------</br>
| Шаблон      | Что делает с интерфейсом | Что делает с функциональностью |</br>
---------------------------------------------------------------------------</br>
| Заместитель | Не изменяет              | Не изменяет                    |</br>
---------------------------------------------------------------------------</br>
| Декоратор   | Не изменяет/расширяет    | Расширяет                      |</br>
---------------------------------------------------------------------------</br>
| Адаптер     | Изменяет                 | Не изменяет                    |</br>
---------------------------------------------------------------------------</br>
</p>
<p align="justify">
<b>CAP-теорема (теорема Брюера) = consistency + availability + partitioning</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP">https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP</a></br>
= согласованность данных (consistency) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу</br>
= доступность (availability) — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают</br>
= устойчивость к разделению (partition tolerance) — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций</br>
</p>
<p align="justify">
= В системе класса CA во всех узлах данные согласованы и обеспечена доступность, при этом она жертвует устойчивостью к распаду на секции. Такие системы возможны на основе технологического программного обеспечения, поддерживающего транзакционность в смысле ACID, примерами таких систем могут быть решения на основе кластерных систем управления базами данных или распределённая служба каталогов LDAP</br>
= Система класса CP в каждый момент обеспечивает целостный результат и способна функционировать в условиях распада, но достигает этого в ущерб доступности: может не выдавать отклик на запрос. Устойчивость к распаду на секции требует обеспечения дублирования изменений во всех узлах системы, в связи с этим отмечается практическая целесообразность использования в таких системах распределённых пессимистических блокировок для сохранения целостности</br>
= В системе класса AP не гарантируется целостность, но при этом выполнены условия доступности и устойчивости к распаду на секции. Хотя системы такого рода известны задолго до формулировки принципа CAP (например, распределённые веб-кэши или DNS), рост популярности решений с этим набором свойств связывается именно с распространением теоремы CAP. Так, большинство NoSQL-систем принципиально не гарантируют целостности данных, и ссылаются на теорему CAP как на мотив такого ограничения. Задачей при построении AP-систем становится обеспечение некоторого практически целесообразного уровня целостности данных, в этом смысле про AP-системы говорят как о «целостных в конечном итоге» (eventually consistent) или как о «слабо целостных» (weak consistent)</br>
</p>
<p align="justify">
= BASE (Basically Available, Soft-state, Eventually consistent — базовая доступность, неустойчивое состояние, согласованность в конечном счёте)</br>
	= Под базовой доступностью подразумевается такой подход к проектированию приложения, чтобы сбой в некоторых узлах приводил к отказу в обслуживании только для незначительной части сессий при сохранении доступности в большинстве случаев.</br>
	= Неустойчивое состояние подразумевает возможность жертвовать долговременным хранением состояния сессий (таких как промежуточные результаты выборок, информация о навигации, контексте), при этом концентрируясь на фиксации обновлений только критичных операций.</br>
	= Согласованность в конечном счёте, трактуется как возможность противоречивости данных в некоторых случаях, но при обеспечении согласования в практически обозримое время.</br>
</p>
<p align="justify">
<b>Xss+Xmx<1Gb, приложение занимает 3Gb в памяти. почему так может быть?</b></br>
Данные ограничения - для одного потока, приложение занимало столько памяти, потому что несколько потоков потребили столько (up to 1Gb) памяти</br>
</p>
<p align="justify">
<b>Zipkin</b></br>
<a href="https://habr.com/post/187902/">https://habr.com/post/187902/</a></br>
Zipkin — это система распределенной трассировки, которая помогает нам собирать данные о времени выполнения всех разрозненных служб</br>
Сбор трассировок помогает разработчикам получить более глубокие знания о том, как определенные запросы выполняются в распределенной системе. Скажем, у нас возникли проблемы с запросами пользователей, допустим, превышение тайм-аута. Мы можем просмотреть трассировки запросов, которые отвалились и показать их в веб-интерфейсе. Мы сможем быстро найти службу, виновную за нежданную прибавку времени на ответ. Если служба была подробно проаннотирована, мы также сможем найти, в каком именно месте сервиса возникла проблема</br>
</p>
<p align="justify">
<b>Для чего HTTP метод OPTIONS?</b></br>
<a href="https://habr.com/post/342432/">https://habr.com/post/342432/</a></br>
Согласно стандарту HTTP/1.1 метод OPTIONS может быть использован клиентом для определения параметров или требований, связанных с ресурсом. Сервер также может отправлять документацию в удобочитаемом формате. Ответ на запрос OPTIONS может содержать список допустимых методов для данного ресурса в хедере Allow.</br>
То есть этот метод мог бы стать отличным средством для документирования наших REST-сервисов с одной стороны, и быть существенным дополнением к архитектурному ограничению HATEOAS с другой</br>
</p>
<p align="justify">
<b>Prometeus</b></br>
<a href="https://medium.com/southbridge/prometheus-monitoring-ba8fbda6e83">https://medium.com/southbridge/prometheus-monitoring-ba8fbda6e83</a></br>
Prometeus - система мониторинга состояния приложений и серверов, загрузку процессора, памяти, дисковую утилизацию и т.п. Когда что-то идет не так - шлются оповещения</br>
Визуализация - можно использовать Graphana</br>
</p>
<p align="justify">
<b>Dependency Injection – Field vs Constructor vs Method</b></br>
<a href="http://coders-kitchen.com/2015/01/05/dependency-injection-field-vs-constructor-vs-method/">http://coders-kitchen.com/2015/01/05/dependency-injection-field-vs-constructor-vs-method/</a></br>
"Mixing setter and constructor injection" is preferred, because could distinguish between mandatory dependencies and non-mandatory</br>
</p>
<p align="justify">
<b>IoC vs DI</b></br>
<a href="https://stackoverflow.com/questions/6550700/inversion-of-control-vs-dependency-injection">https://stackoverflow.com/questions/6550700/inversion-of-control-vs-dependency-injection</a></br>
IoC (Inversion of Control) - is generic term and implemented in several ways (events, delegates etc).</br>
Giving control to the container to get an instance of the object is called IoC, means instead of you are creating an object using the new operator, let the container do that for you</br>
DI (Dependency Injection) - DI is a sub-type of IoC and is implemented by constructor injection, setter injection or Interface injection.</br>
Spring supports only Constructor Injection and Setter/Getter Injection.</br>
</p>
<p align="justify">
<b>Приложение повисло (вроде бы), как убедиться в этом и что делать дальше?</b></br>
Посмотреть использование ресурсов (процессора, памяти) приложением, возможно где-то уперлось в ограничения</br>
Подключиться по JMX, посмотреть метрики JVM с этой же целью</br>
Снять хипдамп/треддамп, скачать его, потом проанализировать</br>
</p>
<p align="justify">
<b>CQRS-шаблон (command-query responsibility segregation)</b></br>
<a href="https://ru.wikipedia.org/wiki/CQRS">https://ru.wikipedia.org/wiki/CQRS</a></br>
Принцип императивного программирования, в котором метод должен быть либо командой, выполняющей действия, либо запросом, возвращающим данные, но не одновременно и тем и другим. Другими словами - "задавание вопроса не должно менять ответ"</br>
</p>
<p align="justify">
<b>Отличие ReentrantLock от synchronized</b></br>
<a href="https://stackoverflow.com/questions/11821801/why-use-a-reentrantlock-if-one-can-use-synchronizedthis">https://stackoverflow.com/questions/11821801/why-use-a-reentrantlock-if-one-can-use-synchronizedthis</a></br>
A ReentrantLock is unstructured, unlike synchronized constructs - so you don't need to use a block structure for locking and can even hold a lock across methods. </br>
Aside from that, ReentrantLock supports lock polling and interruptible lock waits that support time-out, and support for configurable fairness policy, allowing more flexible thread scheduling.</br>
When should you use ReentrantLocks? The answer is pretty simple - use it when you actually need something it provides that synchronized doesn't, like timed lock waits, interruptible lock waits, non-block-structured locks, multiple condition variables, or lock polling.</br>
</p>
<p align="justify">
<b>Цикл жизни спринг-бина, как встроиться в него?</b></br>
<a href="https://www.journaldev.com/2637/spring-bean-life-cycle">https://www.journaldev.com/2637/spring-bean-life-cycle</a></br>
= By implementing InitializingBean and DisposableBean interfaces – Both these interfaces declare a single method where we can initialize/close resources in the bean. For post-initialization, we can implement InitializingBean interface and provide implementation of afterPropertiesSet() method. For pre-destroy, we can implement DisposableBean interface and provide implementation of destroy() method.</br>
This approach is simple to use but it’s not recommended because it will create tight coupling with the Spring framework in our bean implementations.</br>
= Providing init-method and destroy-method attribute values for the bean in the spring bean configuration file. </br>
This is the recommended approach because of no direct dependency to spring framework and we can create our own methods.</br>
Note that both post-init and pre-destroy methods should have no arguments but they can throw Exceptions. We would also require to get the bean instance from the spring application context for these methods invocation.</br>
= Spring framework also support @PostConstruct and @PreDestroy annotations for defining post-init and pre-destroy methods. These annotations are part of javax.annotation package. However for these annotations to work, we need to configure our spring application to look for annotations. We can do this either by defining bean of type org.springframework.context.annotation.CommonAnnotationBeanPostProcessor or by context:annotation-config element in spring bean configuration file.</br>
= All of the *Aware interfaces are sub-interfaces of Aware and declare a single setter method to be implemented by the bean:</br>
	= ApplicationContextAware – to inject ApplicationContext object, example usage is to get the array of bean definition names.</br>
    = BeanFactoryAware – to inject BeanFactory object, example usage is to check scope of a bean.</br>
    = BeanNameAware – to know the bean name defined in the configuration file.</br>
    = ResourceLoaderAware – to inject ResourceLoader object, example usage is to get the input stream for a file in the classpath.</br>
    = ServletContextAware – to inject ServletContext object in MVC application, example usage is to read context parameters and attributes.</br>
    = ServletConfigAware – to inject ServletConfig object in MVC application, example usage is to get servlet config parameters.</br>
</p>
<p align="justify">
<b>What's new in latest Javas: 8-11?</b></br>
Java 8: https://habr.com/ru/post/216431/</br>
Java 9-11: https://codete.com/blog/java-8-java-11-quick-guide/</br>
Java 11: https://habr.com/ru/post/424683/</br>
</p>
<p align="justify">
<b>Java 8</b></br>
= lambda expressions (closures). lambda expression corresponds to functional interface</br>
= multiple new functional interfaces:</br>
	= Predicates: functions which take one argument and return boolean</br>
	= Functions: take one argument and return result</br>
	= Consumers: operation on one input argument</br>
	= Comparators: some new methods was added: reversed(), comparingInt(), comparingLong() etc</br>
= Optional: allow to prevent NPE</br>
= default methods in interfaces</br>
= Nashorn JS engine</br>
= new Date and Time API: Clock, ZoneId, LocalTime, LocalDate, LocalDateTime, DateTimeFormatter</br>
= links to methods and constructors, for example: String::valueOf, Person::new</br>
= Streams (sequential and parallel): sequence of elements on which we could perform different operations. two types of operations:</br>
	= intermediate: Filter, Sorted, Map</br>
	= terminal: Match (return boolean), Count (return long), Reduce (return Optional)</br>
= new methods in Map: putIfAbsent(), computeIfPresent(), computeIfAbsent(), getOrDefault(), merge()</br>
= annotations became repeatable</br>
= CompletableFuture with about 50 different methods for composing, combining, executing asynchronous computation steps and handling errors</br>
</p>
<p align="justify">
<b>Java 9</b></br>
= Project Jigsaw: introduced modularity to monolithic Java SE ecosystem. The primary goal to make JDK more easily scalable down to small computing devices. Using module-info.java files we could declare which part of module we could expose</br>
= JShell: provides REPL - interactive programming tool</br>
= G1 garbage collector that introduced in Java 8 became default GC instead previous Parallel GC</br>
= private methods in interfaces</br>
= new methods in Optional class: ifPresentOrElse(), or()</br>
= Optional.stream(): Can treat with Optional as a Stream and use all methods from Stream API</br>
= static methods on the List, Set and Map interfaces for creating unmodifiable instances of those collections</br>
= new methods to CompletableFuture class. Most significant one relates to timeouts, for example: orTimeout(), completeOnTimeout()</br>
= enhancements in @Deprecated, added 2 new params to it: 'since' and 'forRemoval'</br>
</p>
<p align="justify">
<b>Java 10</b></br>
= "var" keyword introduced. It allows to replace strict variable type declaration if the type may be easily inferred by the compiler.</br>
We can use var in the context of local variables (instantly initialized), for loops and try-with-resources blocks.</br>
= new overloaded version of Optional.orElseThrow() without params which throws NoSuchElementException dy default</br>
= API for creating unmodifiable collections from existing collections: List.copyOf(), Set.copyOf(), Map.copyOf()</br>
= Collectors class has some new methods like toUnmodifiableList(), toUnmodifiableSet(), toUnmodifiableMap()</br>
= Parallel full GC for G1: G1 which was introduced in Java 9 and mainly designed to prevent "stop the world" event in this Java improved the algorithm to parallelize the full GC</br>
</p>
<p align="justify">
<b>Java 11</b></br>
= Local-Variable Syntax for Lambda Parameters, for example: (var x) -> x * 2. So could use 'var' here already</br>
= Add single-file programs support. Typing simply: 'java SimpleProgram.java' will run the program immediately.</br>
Support of "shebang files" added too: put '#!/usr/bin/java --source 11' into the first line of .java file for that</br>
= HTTP client API introduced in Java 9 as incubator project now became a part of Java SE standard</br>
= some modules removed from standard Java SE (corba, transaction, activation, xml.ws, xml.bind, xml.ws.annotation)</br>
= multiple new methods in public API: String, Pattern, Predicate, Path, Files etc</br>
= new optional Epsilon GC which doesn't collect garbage at all (useful for serverless usage, short-term tasks etc when guaranteed that heap will be enough and JVM should not collect statistics to decide when GC should start)</br>
= Flight Recorder became not-comercial and already presents in OpenJDK too</br>
= Nashorn as replacement of Rhino Javascript engine</br>
</p>
<p align="justify">
<b>Предложить дизайн игры крестики-нолики</b></br>
Several VMs where each of them contains Docker image with spring-boot application inside. Requests goes through load balancer which forward them to VMs. In addition with could use some dashboard to display application metrics</br>
After when player notify server about intention to play, server looking for another player and create game, after that notified both players about game start.</br>
I think lobby creation isn't needed for such simple x-o game</br>
Interaction during game could be implemented by sending/retrieving players moves to/from server. In addition server collects games statistic and it could be displayed via some another service</br>
</p>
<p align="justify">
<b>Написать сиквел на использование оконной функции</b></br>
<a href="https://en.wikipedia.org/wiki/SQL_window_function">https://en.wikipedia.org/wiki/SQL_window_function</a></br>
<a href="https://mode.com/sql-tutorial/sql-window-functions/">https://mode.com/sql-tutorial/sql-window-functions/</a></br>
In the SQL, window functions allow access to data in the records right before and after the current record. A window function defines a frame or window of rows with a given length around the current row, and performs a calculation across the set of data in the window. For example next query extracts for each row the values of a window with one preceding and one following row:</br>
SELECT</br>
	LAG(name,1) OVER(ORDER BY name) "prev",</br>
	name, </br>
	LEAD(name,1) OVER(ORDER BY name) "next"</br>
	FROM people ORDER BY name</br>
</p>
<p align="justify">
List of windows functions: SUM(),COUNT(),AVG(),ROW_NUMBER(),RANK(),DENSE_RANK(),NTILE(),LAG(),LEAD()</br>
To narrow the window from the entire dataset to individual groups within the dataset, you can use PARTITION BY.</br>
To write several window functions into the same query, using the same window, you can create an alias using WINDOW:</br>
SELECT</br>
	LAG(name,1) OVER name_window "prev",</br>
	name, </br>
	LEAD(name,1) OVER name_window "next"</br>
	FROM people </br>
	WINDOW name_window AS (PARTITION BY country ORDER BY name)</br>
	ORDER BY name</br>
</p>
<p align="justify">
<b>LEAN принципы</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%B5%D0%B6%D0%BB%D0%B8%D0%B2%D0%B0%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%B5%D0%B6%D0%BB%D0%B8%D0%B2%D0%B0%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F</a></br>
= Исключение потерь (Eliminate waste). Потерями считается всё, что не добавляет ценности для потребителя. В частности: излишняя функциональность; ожидание (паузы) в процессе разработки; нечёткие требования; бюрократизация; медленное внутреннее сообщение</br>
= Акцент на обучении (Amplify learning). Короткие циклы разработки, раннее тестирование, частая обратная связь с заказчиком</br>
= Предельно отсроченное принятие решений (Decide as late as possible). Решение следует принимать не на основе предположений и прогнозов, а после открытия существенных фактов</br>
= Предельно быстрая доставка заказчику (Deliver as fast as possible). Короткие итерации</br>
= Мотивация команды (Empower the team). Нельзя рассматривать людей исключительно как ресурс. Людям нужно нечто большее, чем просто список заданий</br>
= Интегрирование (Build integrity in). Передать целостную информацию заказчику. Стремиться к целостной архитектуре. Рефакторинг</br>
= Целостное видение (See the whole). Стандартизация, установление отношений между разработчиками. Разделение разработчиками принципов бережливости. "Мыслить широко, делать мало, ошибаться быстро; учиться стремительно"</br>
</p>
<p align="justify">
<b>Как проверить докер образ на секьюрность?</b></br>
При помощи сканирования специальными тулами</br>
</p>
<p align="justify">
<b>Недостатки spring boot?</b></br>
Достаточно большое потребление ресурсов приложением, построенным на его основе</br>
</p>
<p align="justify">
<b>Hot/cold DB storages</b></br>
<a href="https://searchstorage.techtarget.com/definition/hot-data">https://searchstorage.techtarget.com/definition/hot-data</a></br>
Hot data is data that needs to be accessed frequently. It is typically business-critical information that needs to be accessed quickly and is often used by a company for quick decision making (computation). Hot data usually resides on the fastest storage - typically flash in hybrid or tiered storage environments. </br>
Conversely, cool data is data that is accessed less frequently by an organization. Cool data is usually stored on lower performing and less expensive storage environments in-house or in the cloud.</br>
</p>
<p align="justify">
<b>Репликация, фрагментация, отказоустойчивость</b></br>
<a href="https://web-creator.ru/articles/partitioning_replication_sharding">https://web-creator.ru/articles/partitioning_replication_sharding</a></br>
  = Партиционирование — это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным администратором критериям. Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. Для правильного конфигурирования параметров партиционирования необходимо, чтобы в каждом потоке было примерно одинаковое количество записей.</br>
  Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, а не со всем архивом за годы существования новостного ресурса. </br>
  = Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave). Мастера используются для изменения данных, а слэйвы — для считывания. В классической схеме репликации обычно один мастер и несколько слэйвов, так как в большей части веб-проектов операций чтения на несколько порядков больше, чем операций записи.</br>
  Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов — используемый для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.</br>
  = Шардинг — это прием, который позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных.</br>
  Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, таким образом все данные пользователя будут храниться и обрабатываться на одном сервере, а не собираться по частям с нескольких.</br>
</p>
<p align="justify">
<b>Недостатки node.js?</b></br>
<a href="https://toster.ru/q/171253">https://toster.ru/q/171253</a></br>
Асинхронность... ее там нет. Там есть event loop что позволяет писать крайне эффективные программы в плане работы с I/O (что для web очень неплохо) и не париться о таких вещах, как потокобезопасность, блокировки и т.д. А если еще и несколько инстансов приложения запусть - по одному на ядро скажем, то утилизация вычислительных мощностей выйдет неплохой. Но распаралелить что-то в рамках одного процесса воркера мы уже не можем. Нода хороша, когда у нас все состоит из элементарных операций, которые не занимают много времени, все жирное надо выносить из основного процесса и разруливать очередями и т.д. </br>
Callback-hell. Собственно наличие event loop диктует также правила о том, как должна писаться программа. Кучи колбэков, невозможность дебажить нормально и получить четкий стэктрейс из ошибки.</br>
Разработка больших и сложных проектов на ноде возможна, но требует от разработчика хорошие знания и понимание того, как работает его платформа. А это увеличивает стоимость разработки в то время, как можно взять более эффективные в этом плане инструменты.</br>
</p>
<p align="justify">
<b>3 типа класслоадеров (загрузчиков): бутстрап, экстеншн, системный; delegation модель в класслоадерах</b></br>
<a href="http://www.quizful.net/post/Java">http://www.quizful.net/post/Java</a></br>
<a href="https://habr.com/ru/post/103830">https://habr.com/ru/post/103830</a></br>
В начале работы программы создается 3 основных загрузчика классов:</br>
	базовый загрузчик (bootstrap)</br>
    загрузчик расширений (extention)</br>
    системный загрузчик (system/application)</br>
	пользовательский загрузчик</br>
Загрузчики классов являются иерархическими. Иерархия загрузчиков: Bootstrap <- Extensions <- Application <- Пользовательский (если существует)</br>
  = Загрузчик, который загружает основные системные классы, называется базовым (Bootstrap или Primordial), корневым загрузчиком классов. Именно он загружает внутренние классы JDK и пакеты java.* (rt.jar и i18n.jar). Управлять загрузкой базовых классов можно с помощью ключа -Xbootclasspath, который позволяет переопределять наборы базовых классов.</br>
  = Загрузчик расширений – загружает различные пакеты расширений, которые располагаются в директории <JAVA_HOME>/lib/ext или другой директории, описанной в системном параметре java.ext.dirs. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Управлять загрузкой расширений можно с помощью системной опции java.ext.dirs.</br>
  = Системный загрузчик – загружает классы, пути к которым указаны в переменной окружения CLASSPATH или пути, которые указаны после ключей –classpath или  –cp. Также управлять списком классов можно системной опцией java.class.path.</br>
Каждый загрузчик классов (кроме Bootstrap) имеет родительский загрузчик. Если класс уже загружался ранее текущим загрузчиком - он возвращается из кеша. Если нет - загрузчик делегирует поиск класса родительскому классу-загрузчику. Bootstrap загрузчик - загружает класс самостоятельно. Если бутстрап не находит класс для загрузки - управление передается обратно по иерархии предыдущему загрузчику и т.д.:</br>
	1) Системный загрузчик попытается поискать в кеше класс Student.</br>
		1.1) Если класс найден, загрузка окончена.</br>
		1.2) Если класс не найден, загрузка делегируется загрузчику расширений.</br>
	2) Загрузчик расширений попытается поискать в кеше класс Student.</br>
		2.1) Если класс найден, загрузка окончена.</br>
		2.2) Если класс не найден, загрузка делегируется базовому загрузчику.</br>
	3) Базовый загрузчик попытается поискать в кеше класс Student.</br>
		3.1) Если класс найден, загрузка окончена.</br>
		3.2) Если класс не найден, базовый загрузчик попытается его загрузить.</br>
			3.2.1) Если загрузка прошла успешно, она закончена ;)</br>
			3.2.2) Иначе управление предается загрузчику расширений.</br>
		3.3) Загрузчик расширений пытается загрузить класс.</br>
			3.3.1) Если загрузка прошла успешно, она закончена ;)</br>
			3.3.2) Иначе управление предается системному загрузчику.</br>
		3.4) Системный загрузчик пытается загрузить класс.</br>
			3.4.1) Если загрузка прошла успешно, она закончена ;)</br>
			3.4.2) Иначе генерируется исключение java.lang.ClassNotFoundException.</br>
Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке core API,  потом в папке расширений, потом в локальных файлах classpath.</br>
В Java существует возможность создания собственных загрузчиков классов. Это может быть полезно, когда нет возможности или нежелательно перечислять все используемые библиотеки при старте программы в CLASSPATH. Например, в программе должна быть возможность динамической загрузки плагинов. Или возможностей стандартного загрузчика недостаточно для загрузки нужных классов.</br>
Собственные загрузчики классов используют все серверы приложений и web-контейнеры, что и понятно – приложения, разворачиваемые на сервере приложений, должны загружаться динамически, в противном случае перечисление в переменной CLASSPATH всех библиотек, используемых приложениями, становится задачей нетривиальной.</br>
</p>
<p align="justify">
<b>Недостатки Redis?</b></br>
<a href="https://habr.com/ru/post/178525/">https://habr.com/ru/post/178525/</a></br>
<a href="https://habr.com/ru/company/retailrocket/blog/269151/">https://habr.com/ru/company/retailrocket/blog/269151/</a></br>
Redis отличная замена Memcached. Обосновался в нише быстрого кеша (скорость=достоинство), а не как основное хранилище, хотя некоторые рискуют использовать его и так.</br>
Персистентность (сохранение на диск) есть, отключаемая при желании; также персистентность не синхронна с записью в Redis (т.е. наступает позже), поэтому при использовании его в качестве системы основного хранения есть риск потерять данные находившиеся в памяти после последнего сохранения. Это и можно считать недостатком.</br>
</p>
<p align="justify">
<b>Оптимистическая и пессимистическая блокировка в БД, как ее реализовать</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_(%D0%A1%D0%A3%D0%91%D0%94)">https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_(%D0%A1%D0%A3%D0%91%D0%94)</a></br>
  - Пессимистическая блокировка накладывается перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает. Всё время действия такой блокировки исключена модификация данных из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.</br>
  - Оптимистическая блокировка не ограничивает модификацию обрабатываемых данных сторонними сессиями, однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк данных (обычно используется наименование VERSION и целочисленный тип с начальным значением 0). Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута (например, инкрементом) для сигнализации другим сессиям о том, что данные изменились. Конкретно на уровне кода это реализуется выполнением запроса с where VERSION=... .</br>
</p>
<p align="justify">
<b>Настройка сборщика мусора</b></br>
<a href="https://dzone.com/articles/choosing-the-right-gc">https://dzone.com/articles/choosing-the-right-gc</a></br>
Java -XX:+Use[gc_name]GC -Xmx2g -Xms32m -jar app.jar [sleep]</br>
Where params are next:</br>
    - [gc_name] will be substituted with the specific garbage collector type: G1, Parallel, ConcMarkSweep (CMS), Serial, Shenandoah etc</br>
    - Xms is the scaling step (32 MB in our case)</br>
    - Xmx is the maximum scaling limit (2 GB in our case)</br>
    - [sleep] is the interval between memory load cycles in milliseconds. The default is 10</br>
From plot in this article we see that Parallel GC not released memory to OS when it not used already</br>
To choose appropriate GC we need to track memory consumption of live application and experiment with different GCs and their options. In addition optimal settings depend on how fast memory usage growth is</br>
</p>
<p align="justify">
<b>Как работает докер на пальцах?</b></br>
<a href="https://ru.wikipedia.org/wiki/Docker">https://ru.wikipedia.org/wiki/Docker</a></br>
<a href="https://proglib.io/p/docker/">https://proglib.io/p/docker/</a></br>
  - Docker на базе Linux - это когда при помощи chroot создается отдельный sandbox со своей файловой системой.</br>
  - На базе Windows - виртуальная машина с Linux, где уже происходит chroot (см. выше).</br>
Управляет этим всем демон-сервер контейнеров, позволяющий из командной строки управлять образами и контейнерами, а также REST API, позволяющее управлять контейнерами программно. </br>
Создается изолированное окружение на уровне процессов и на уровне сети, можно настраивать мэппинг портов и маунтить volumes, запускать процессы в новых контейнерах (docker run), останавливать и запускать контейнеры (docker stop и docker start), приостанавливать и возобновлять процессы в контейнерах (docker pause и docker unpause), осуществлять мониторинг запущенных процессов (docker ps по аналогии с ps в Unix-системах, docker top по аналогии с top и другие). Новые образы возможно создавать из специального сценарного файла (docker build, файл сценария носит название Dockerfile), возможно записать все изменения, сделанные в контейнере, в новый образ (docker commit). </br>
Можно взаимодействовать с публичным репозиторием Docker Hub, в котором размещены предварительно собранные образы контейнеров, команда docker search позволяет осуществить поиск образов среди размещённых в нём. </br>
Образы можно скачивать в локальную систему (docker pull), или отправить локально собранные образы в Docker Hub (docker push). </br>
Также Docker имеет пакетный менеджер Docker Compose, позволяющий описывать и запускать многоконтейнерные приложения.</br>
</p>
<p align="justify">
<b>Sql-запросы с агрегатными функциями</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D0%BD%D1%8B%D0%B5_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D0%BD%D1%8B%D0%B5_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8</a></br>
Агрегатные функции используются для обобщения данных. К их числу относятся:</br>
    SUM (сумма)</br>
    MAX(максимальное значение)</br>
    MIN (минимальное значение)</br>
    COUNT (количество значений)</br>
    AVG (среднее значение, обычно среднее арифметическое)</br>
    MODE (мода)</br>
    MEDIAN (медиана)</br>
Пример: SELECT SUM(amt) FROM Orders WHERE odate BETWEEN '2016-01-01' and '2016-12-31';</br>
</p>
<p align="justify">
<b>Как работает lazy в jpa под капотом</b></br>
<a href="https://stackoverflow.com/questions/2990799/difference-between-fetchtype-lazy-and-eager-in-java-persistence-api">https://stackoverflow.com/questions/2990799/difference-between-fetchtype-lazy-and-eager-in-java-persistence-api</a></br>
FetchType.LAZY = fetch when needed</br>
FetchType.EAGER = fetch immediately</br>
This is implemented by creating a Proxy around the List (or Set). So for your lazy collections, the concrete types are not ArrayList and HashSet, but PersistentSet and PersistentList (or PersistentBag).</br>
</p>
<p align="justify">
<b>Проблема n+1</b></br>
<a href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-object-relational-mapping">https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-object-relational-mapping</a></br>
  When you have 1-to-may relationship, for example collection of Car objects (database rows) where each Car has a collection of Wheel objects (also rows)</br>
You need to iterate through all the cars, and for each one, print out a list of the wheels. The naive O/R implementation would do the following: SELECT * FROM Cars. </br>
And then for each Car: SELECT * FROM Wheel WHERE CarId = ?</br>
In other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars.</br>
  How to solve N+1 problem:</br>
<a href="https://dou.ua/lenta/articles/hibernate-fetch-types/">https://dou.ua/lenta/articles/hibernate-fetch-types/</a></br>
Используя различные FetchMode, настраиваем как мы хотим, чтобы связанные сущности или коллекции были загружены:</br>
	— SELECT — используя по дополнительному SQL запросу на коллекцию,</br>
	— JOIN — в одном запросе с корневой сущностью, используя SQL оператор JOIN,</br>
	— SUBSELECT— в дополнительном запросе, используя SUBSELECT.</br>
Мы также можем влиять на стратегию загрузки связанных коллекций при помощи аннотации @BatchSize (или атрибут batch-size в XML), которая устанавливает количество коллекций, которые будут загружаться в одном запросе.</br>
</p>
<p align="justify">
<b>Ehcache</b></br>
<a href="https://habr.com/ru/post/25140/">https://habr.com/ru/post/25140/</a></br>
Ehcache — универсальная система распределённого кеширования, которая реализует кеш как динамический (в оперативной памяти), так и дисковый кеш, причём изначально спроектированная для работы с кешами большого объёма (порядка гигабайтов) и в распределённых системах.</br>
Ehcache может реализовывать несколько различных стратегий кеширования, например — LFR (кеширование исходя из частоты использования) или FIFO, а также можно контролировать кеш на уровне отдельных объектов (задавая схему инвалидации объектов в кеше — по времени жизни или времени простоя).</br>
Одной из уникальных функций ehcache является «персистентный кеш», который позволяет хранить состояние объектов даже после перезагрузки виртуальной java-машины. Кроме этого, система кеширования поддерживает консоль управления JMX, что позволяет прозрачно интегрировать её в систему управления любым приложением, используя только стандартные протоколы и возможности.</br>
Синхронизация и/или репликация кешей между узлами может быть как общей, так и локальной, для отдельных кешей по своей схеме, асинхронной или синхронной. Для большинства функциональности от приложения, использующего кеш, совершенно ничего не требуется, все зависит только от одного конфигурационного XML файла.</br>
Кеш может быть как самостоятельной единицей в составе приложения, так и взаимодействовать с другими популярными фреймворками, в частности, с прослойкой для работы с базами данных Hibernate.</br>
</p>
<p align="justify">
<b>Фетч-тайп/мод, сабселект</b></br>
<a href="https://stackoverflow.com/questions/25821718/difference-between-fetchmode-and-fetchtype">https://stackoverflow.com/questions/25821718/difference-between-fetchmode-and-fetchtype</a></br>
<a href="https://www.solidsyntax.be/2013/10/17/fetching-collections-hibernate/ ">https://www.solidsyntax.be/2013/10/17/fetching-collections-hibernate/ </a></br>
FetchType (Lazy/Eager) tells whether we want entity to be loaded eagerly or lazy, when there's call in code.</br>
FetchMode (Select/Join) tells whether we want our entity to be loaded with additional select or in one query with join or subselect.</br>
	a) if you don't specify FetchMode, the default is JOIN and FetchType works normal</br>
	b) if you specify FetchMode.JOIN explicitly, FetchType is ignored and a query is always eager</br>
	c) if you specify FetchMode.SELECT or FetchMode.SUBSELECT, FetchType.Type works normal</br>
What mode choose: select or join:</br>
<a href="https://stackoverflow.com/questions/617145/hibernate-fetching-strategy-when-to-use-join-and-when-to-use-select">https://stackoverflow.com/questions/617145/hibernate-fetching-strategy-when-to-use-join-and-when-to-use-select</a></br>
Join is supposed to solve the n+1 problem. The join method is a little less efficient on the initial query because you're duplicating the parent columns in every row, but you only make one round-trip to the database.</br>
Select:</br>
	SELECT * FROM parent WHERE id=(whatever)</br>
	SELECT * FROM child WHERE id=(parent.child.id)</br>
Join:</br>
	SELECT * FROM parent</br>
	LEFT OUTER JOIN child ON parent.child.id=child.id</br>
	WHERE parent.id=(whatever)</br>
</p>
<p align="justify">
<b>Рассказать о jms (connection, session, producer, consumer)</b></br>
<a href="https://jsehelper.blogspot.com/2016/12/jms.html">https://jsehelper.blogspot.com/2016/12/jms.html</a></br>
JMS, Java Message Service - API для работы с message oriented middleware, чтобы создавать гибкие и слабосвязанные приложения с использованием асинхронного обмена данными между приложениями (клиентами/серверами) через посредника. Асинхронность - и есть основная причина использования JMS.</br>
Компоненты архитектуры обмена сообщениями: </br>
	- Поставщик (брокер сообщений). обрабатывает буферизацию и доставку сообщений</br>
	- Клиенты. Любое приложение или компонент, который производит или потребляет сообщения с помощью поставщика. "Клиент" - это общий термин для производителя, отправителя, издателя, потребителя, приемника и подписчика</br>
	- Сообщения. Объект, который клиенты отправляют или получают от поставщика</br>
	- Администрируемые объекты. Брокер должен предоставить их клиенту (фабрики подключений и места назначения), с помощью поиска JNDI или внедрения</br>
Модели обмена сообщениями:</br>
	- точка-точка (point-to-point). место назначения называется очередью. один клиент помещает сообщение в очередь, другой получает его. как только получение сообщения подтверждено - оно удаляется</br>
	- подписчик-издатель (publisher-subscriber). место назначения называется темой (topic). в этом случае клиент публикует сообщение в теме, и ее подписчики получают это сообщение</br>
Основные интерфейсы:</br>
	- ConnectionFactory</br>
	- Connection</br>
	- Session</br>
	- Destination - Queue / Topic</br>
	- Producer - объект, посылающий сообщения. QueueSender / TopicPublisher</br>
	- Consumer - объект, принимающий сообщения. QueueReciever / TopicSubscriber</br>
	- Message - сообщение</br>
Сообщение состоит из: заголовка, свойств и тела</br>
Модели подтверждения получения сообщения:</br>
	- Auto_acknowledge - автоматическое получение подтверждения</br>
	- Dups_ok_acknowledge - работа по получению подтверждения перекладывается на Session. Сообщения будут вновь доставлены в случае ошибки или "гибели" системы</br>
	- client_acknowledge - клиент должен явно вызывать метод интерфейса Message, чтобы подтвердить получение сообщения</br>
</p>
<p align="justify">
<b>Какие требования к JPA классам? описать минимальный JPA-класс</b></br>
<a href="http://deskbook.info/hibernate/entity/5-entity-class.html">http://deskbook.info/hibernate/entity/5-entity-class.html</a></br>
	- Класс сущности (Entity класс) должен быть аннотирован аннотацией javax.persistence.Entity (или быть обозначен как таковой в XML-сопоставлении)</br>
    - Класс сущности должен иметь public или protected конструктор без аргументов. Entity класс также может определять дополнительные конструкторы с аргументами</br>
    - Класс сущности должен иметь свойство (свойства) – уникальный идентификатор, аннотированный аннотацией javax.persistence.Id</br>
    - Класс сущности должен быть классом верхнего уровня</br>
    - Перечисление [enum] или интерфейс [interface] не могут быть определены как сущность [Entity]</br>
    - Класс сущности не должен быть определен как final. Также ни один из методов или постоянных экземпляров переменных класса сущности не могут быть определены как final</br>
    - Если экземпляр Entity класса должен использоваться удаленно, как отдельный объект, класс сущности должен реализовывать интерфейс Serializable</br>
    - Entity классы могут быть абстрактными</br>
    - Entity классы могут расширять обычные Java классы (не-сущности), а также классы сущностей</br>
    - Обычные Java классы (классы не сущности) также могут расширять Entity классы сущностей</br>
    - Постоянство состояния объекта Entity класса представлено значениями его переменных. Переменные Entity класса не должны быть доступны извне. Доступ к переменным для клиентов обеспечивается только с помощью методов получения и установки значений (getter/setter methods) или иными бизнес методами, определенными разработчиком</br>
Минимальный JPA-класс: Наличие аннотации @Entity на классе и поля, помеченного @Id</br>
</p>
<p align="justify">
<b>Spring bean vs factory bean</b></br>
<a href="http://www.geekabyte.io/2014/11/difference-between-beanfactory-and.html">http://www.geekabyte.io/2014/11/difference-between-beanfactory-and.html</a></br>
A FactoryBean is an interface that you implements when writing factory classes and you want the object created by the factory to be managed as a bean by Spring, </br>
A BeanFactory represents the Spring IoC container, it contains the managed beans and provides access to retrieving them. It is part of the core of the framework which implements the base functionality of an inversion of control container.</br>
In more succinct words, the BeanFactory represents the Spring container while the FactoryBean represents factory classes whose created object are picked up and registered as a bean in the container.</br>
</p>
<p align="justify">
<b>Iterator: fail-fast vs fail-safe</b></br>
<a href="https://www.baeldung.com/java-fail-safe-vs-fail-fast-iterator">https://www.baeldung.com/java-fail-safe-vs-fail-fast-iterator</a></br>
= Fail-fast iterators in Java don’t play along when the underlying collection gets modified.</br>
Collections maintain an internal counter called modCount. Each time an item is added or removed from the Collection, this counter gets incremented.</br>
When iterating, on each next() call, the current value of modCount gets compared with the initial value. If there’s a mismatch, it throws ConcurrentModificationException which aborts the entire operation.</br>
Default iterators for Collections from java.util package such as ArrayList, HashMap, etc. are Fail-Fast.</br>
The ConcurrentModificationException gets thrown at the beginning of a next iteration cycle after the modification was performed.</br>
= Fail-Safe iterators favor lack of failures over the inconvenience of exception handling.</br>
Those iterators create a clone of the actual Collection and iterate over it. If any modification happens after the iterator is created, the copy still remains untouched. Hence, these Iterators continue looping over the Collection even if it’s modified.</br>
However, it’s important to remember that there’s no such thing as a truly Fail-Safe iterator. The correct term is Weakly Consistent.</br>
That means, if a Collection is modified while being iterated over, what the Iterator sees is weakly guaranteed. This behavior may be different for different Collections and is documented in Javadocs of each such Collection.</br>
The Fail-Safe Iterators have a few disadvantages, though. One disadvantage is that the Iterator isn’t guaranteed to return updated data from the Collection, as it’s working on the clone instead of the actual Collection.</br>
Another disadvantage is the overhead of creating a copy of the Collection, both regarding time and memory.</br>
Iterators on Collections from java.util.concurrent package such as ConcurrentHashMap, CopyOnWriteArrayList, etc are Fail-Safe in nature.</br>
</p>
<p align="justify">
<b>OAuth 2</b></br>
<a href="https://www.digitalocean.com/community/tutorials/oauth-2-ru">https://www.digitalocean.com/community/tutorials/oauth-2-ru</a></br>
OAuth 2 представляет собой фреймворк для авторизации, позволяющий приложениям осуществлять ограниченный доступ к пользовательским аккаунтам на HTTP сервисах.</br>
Он работает по принципу делегирования аутентификации пользователя сервису, на котором находится аккаунт пользователя, позволяя стороннему приложению получать доступ к аккаунту пользователя.</br>
OAuth определяет четыре роли:</br>
	- Владелец ресурса</br>
	- Клиент</br>
	- Сервер ресурсов</br>
	- Авторизационный сервер</br>
= Владельцем ресурса является пользователь, который авторизует приложение для доступа к своему аккаунту. Доступ приложения к пользовательскому аккаунту ограничен "областью видимости" (scope) предоставленных прав авторизации (например, доступ на чтение или запись).</br>
= Сервер ресурсов непосредственно хранит защищённые данные аккаунтов пользователей, а авторизационный сервер проверяет подлинность информации, предоставленной пользователем, а затем создаёт авторизационные токены для приложения, с помощью которых приложение будет осуществлять доступ к пользовательским данным.</br>
= Клиентом является приложение, которое хочет осуществить доступ к аккаунту пользователя. Перед осуществлением доступа приложение должно быть авторизовано пользователем, а авторизация должна быть одобрена со стороны API.</br>
Порядок взаимодействия:</br>
    1. Приложение запрашивает у пользователя авторизацию на доступ к серверу ресурсов.</br>
    2. Если пользователь авторизует запрос, приложение получает разрешение на авторизацию (authorization grant).</br>
    3. Приложение запрашивает авторизационный токен у сервера авторизации (API) путём предоставления информации о самом себе и разрешении на авторизацию от пользователя.</br>
    4. Если подлинность приложения подтверждена и разрешение на авторизацию действительно, сервер авторизации (API) создаёт токен доступа для приложения. Процесс авторизации завершён.</br>
    5. Приложение запрашивает ресурс у сервера ресурсов (API), предоставляя при этом токен доступа для аутентификации.</br>
    6. Если токен действителен, сервер ресурсов (API) предоставляет запрашиваемый ресурс приложению.</br>
</p>
<p align="justify">
<b>OpenID</b></br>
<a href="https://ru.wikipedia.org/wiki/OpenID">https://ru.wikipedia.org/wiki/OpenID</a></br>
OpenID — открытый стандарт децентрализованной системы аутентификации, предоставляющей пользователю возможность создать единую учётную запись для аутентификации на множестве не связанных друг с другом интернет-ресурсов, используя услуги третьих лиц.</br>
Базовой функцией OpenID является предоставление портативного, клиент-ориентированного, цифрового идентификатора для свободного и децентрализованного использования.</br>
На сайте, например, example.com находится форма входа с единственным полем ввода для OpenID идентификатора. Зачастую рядом с таким полем располагается логотип OpenID. Для того, чтобы авторизоваться на данном сайте с помощью своего идентификатора, например, pupkin.openid-provider.org, зарегистрированного у OpenID провайдера openid-provider.org, пользователю необходимо ввести свой идентификатор в предлагаемую на сайте форму входа. После этого сайт example.com перенаправляет пользователя на сайт провайдера. Сайт провайдера запрашивает у пользователя подтверждение, действительно ли пользователь желает предоставить информацию о своей учётной записи. Если пользователь соглашается, то сайт провайдера перенаправляет пользователя обратно на сайт зависимой стороны. При обратном перенаправлении провайдер передаст информацию о пользователе зависимой стороне.</br>
OpenID позволяет пользователю использовать одну учетную запись, зарегистрированную у OpenID провайдера, на множестве других сайтов. Пользователь может выбрать, какую информацию предоставить сайту.</br>
Существует возможность делегирования OpenID.</br>
Система OpenID — децентрализованная система. Это значит, что нет какой-либо центральной службы или организации, которая разрешала бы использование системы или регистрировала бы запрашивающие аутентификацию OpenID интернет-ресурсы или провайдеров OpenID. Конечный пользователь может свободно выбирать, какого провайдера OpenID использовать.</br>
</p>
<p align="justify">
<b>JWT</b></br>
<a href="https://habr.com/ru/post/340146/">https://habr.com/ru/post/340146/</a></br>
Приложение использует JWT для проверки аутентификации пользователя следующим образом:</br>
	1. Сперва пользователь заходит на сервер аутентификации с помощью аутентификационного ключа (это может быть пара логин/пароль, либо Facebook ключ, либо Google ключ, либо ключ от другой учетки).</br>
	2. Затем сервер аутентификации создает JWT и отправляет его пользователю.</br>
	3. Когда пользователь делает запрос к API приложения, он добавляет к нему полученный ранее JWT.</br>
	4. Приложение может проверить по переданному с запросом JWT, является ли пользователь тем, за кого себя выдает. В этой схеме сервер приложения сконфигурирован так, что сможет проверить, является ли входящий JWT именно тем, что был создан сервером аутентификации.</br>
JWT состоит из трех частей: заголовок header, полезные данные payload и подпись signature.</br>
= Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись.</br>
= Payload — это полезные данные, которые хранятся внутри JWT. Эти данные также называют JWT-claims (заявки).</br>
= Signature вычисляется на основе предыдущих двух полей. Алгоритм base64url кодирует header и payload, созданные на 1 и 2 шаге. Закодированные строки соединяются через точку, затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.</br>
Важно понимать, что использование JWT НЕ скрывает и не маскирует данные автоматически. Причина, почему JWT используются — это проверка, что отправленные данные были действительно отправлены авторизованным источником. Как было продемонстрировано выше, данные внутри JWT закодированы и подписаны, обратите внимание, это не одно и тоже, что зашифрованы.</br>
Проверка JWT. Только сервер аутентификации и сервер приложения знают секретный ключ. Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к JWT, что в шаге 3. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит JWT валидный, т.е. пришел от проверенного источника.</br>
</p>
<p align="justify">
<b>Профайлинг JVM</b></br>
<a href="https://habr.com/ru/post/143468/">https://habr.com/ru/post/143468/</a></br>
CPU: time/calls, sampling</br>
	= Wall clock time/calls. Быстро, прямо в коде, функцией currentTimeMillis(); но она не точная, меряет только в мсек</br>
	= Short/fast calls. Есть вариант использовать нативный код, слинковать с жава-кодом и так измерять</br>
	= Sampling. Делать треддампы и смотреть, в каких местах застаем программу часто. Если у вас в программе есть строчка, в которой она тратит все, или по крайней мере 90% своего времени, например, какой-нибудь цикл, а там, в глубине, какая-то строчка, то скорее всего, при остановке исполнения вы ее в этой строчке и застанете. Такое место в программе называется "горячей точкой". Это всегда замечательный кандидат для оптимизации. Что классно — есть встроенная фукнция под названием "thread dump", чтобы получить дамп всех потоков. В Windows она делается путем нажатия CTRL-Break на консоли, а на Linux и других юниксах это делается посылкой третьего сигнала, командой "kill -3".</br>
	Также в современных Java-машинах есть замечательная утилита jstack, ей можно передать идентификатор процесса, и получить на выходе thread dump.</br>
	Сделайте не один thread dump, сделайте несколько thread dumpов. Если первый ничего не выловит, посмотрите еще на пару-тройку. Может у вас в горячей точке не сто процентов времени программа проводит, а 50%.</br>
	Эту идею можно развить дальше. Можно, запустив JVM, перенаправить ее выход в файл, и запустить скрипт, который делает thread dump каждые три секунды. Это можно делать совершенно спокойно на живой системе, без какого либо риска что-то с ней сделать. Потому что сам сбор thread dump достаточно быстрая процедура, занимает от силы 100 миллисекунд, даже при очень большом количестве тредов. Т.е. это совершенно безопасный инструмент профилирования живых и работающих систем. После этого, получив файл thread dump, его можно посмотреть глазками, а можно написать несложный кусок кода, который анализирует, считает какие-нибудь статистики → хотя бы тупо, посмотреть, какие методы проявились и сколько раз, посмотреть, в каком состоянии находились потоки.</br>
	= Integration. Более того, thread dump можно интегрировать в приложения, в Java есть замечательный метод Thread.getAllStackTraces, который позволяет получить информацию о stacktrace программно. Таким образом, вы можете интегрировать профилирование, как функциональную часть этого приложения, и распространять приложение вашим клиентам, с уже встроенным профилированием. Тем самым, у вас будет постоянный поток информации, который вы сможете анализировать для улучшения вашего приложения.</br>
Memory: usage, allocation</br>
	= Usage. Есть отличный инструмент jmap, который выводит гистограмму того, чем у вас забита память, какие объекты и сколько памяти занимают. Это замечательный инструмент для общего обзора, что же у вас происходит, и чем забита память. Проблема в том, что вы таким образом получите информацию о всех объектах, даже тех, которые сейчас в данный момент не используются, находятся в мусоре. Поэтому у jmap есть специальная опция 'live', которая перед тем, как сделать гистограмму делает сборку мусора, оставляет только используемые объекты, и только после этого строит гистограмму. Проблема, что уже с этой опцией, большую, живую систему работающую с многими гигабайтами памяти, запрофилировать нельзя, потому что сборка мусора системы, работающей с десятком гигабайт памяти занимает десяток-другой секунд, и это может быть неприемлемо.</br>
	Также дополнительно полезно знать дополнительные опции Java-машин. Например, у Java-машин можно попросить отпечатать гистограмму классов, когда вы делаете thread dump → "PrintClassHistogram". </br>
	JVM можно попросить при исчерпании памяти записывать свое состояние на диск. Это очень полезно, потому что обычно, люди начинают оптимизировать потребление памяти только тогда, когда она заканчивается почему-то. Никто не занимается профилированием, когда все хорошо, а вот когда программе начинает памяти не хватать, она вылетает, начинают думать, как бы так соптимизировать. Поэтому это опцию полезно всегда иметь включенной. Тогда в плохом случае JVM вам запишет бинарный дамп, который вы можете потом, не на живой системе, любыми инструментами проанализировать. При этом, этот дамп можно в любой момент взять с JVM, тем же jmap-ом, с опцией '-dump', но это, опять же, останавливает JVM на долгое время, на живой системе вы это вряд ли заходите делать.</br>
	= Allocation. Cмотрите, на то, сколько процентов времени ваше приложение тратит на сборку мусора. Это может быть сигналом, что много и часто выделяется память, которая потом перестает использоваться - и код можно переписать так, чтобы избежать этого. Это полезная опция '-verbose:gc', '+PrintGC', '+PrintGCDetails', которые позволят вам разобраться, сколько времени вашего приложения уходит на сборку мусора. Если вы видите, что на сборку мусора уходит существенный процент времени, значит вы где-то в программе много выделяете памяти, вы это место не найдете, нужно искать, кто выделяет память. Как искать? Есть встроенный в Java-машину способ, ключик '-Xaprof'. Он вам, к сожалению, только при завершении процесса, выводит так называемый allocation profile, который говорит не о содержимом памяти, а о статистике выделяемых объектов → какие объекты и как часто выделялись. Если у вас это действительно часто происходит, вы скорее всего увидите, что где-то заведен какой-то временный класс, который действительно очень часто выделяется. Попробуйте сразу сделать 'aprof' — может вы сразу найдете вашу проблему. А что делать, если у вас нет идеи, где это происходит? Ну надо как-то добавить сбор статистики всюду, по всем местам, где выделяется память. Для такого рода задач отлично подходит аспектно-ориентированное программирование, либо прямое использование манипуляций байт-кодом. (далее в статье автор доклада делится, как это лучше делать)</br>
</p>
<p align="justify">
<b>Как работает https в деталях?</b></br>
<a href="https://ssl.com.ua/info/how-ssl-works/">https://ssl.com.ua/info/how-ssl-works/</a></br>
Когда вы вводите адрес сайта в браузере, он спрашивает у сервера, установлен ли для сайта сертификат. </br>
В ответ сервер отправляет общую информацию об SSL-сертификате и публичный ключ. </br>
Браузер сверяет информацию со списком авторизованных центров сертификации. Такой список есть во всех популярных браузерах. </br>
Если всё в порядке, браузер генерирует сеансовый ключ, зашифровывает его публичным ключом и отправляет на сервер. </br>
Сервер расшифровывает сообщение и сохраняет сеансовый ключ. </br>
После этого между браузером и сайтом устанавливается безопасное соединение через протокол HTTPS.</br>
Для взаимодействовия в течение установленного сеанса теперь используется данный сеансовый ключ.</br>
</p>
<p align="justify">
<b>Aspects for private methods</b></br>
Yes, it's possible</br>
</p>
<p align="justify">
<b>Aop in Spring</b></br>
Spring makes everything via proxy. Proxy implements same interface as wrapped class. Aop added by extra code in generated proxy class</br>
</p>
<p align="justify">
<b>Современные подходы в сборке мусора в последних Java (алгоритмы, память и т.п.)</b></br>
<a href="https://www.baeldung.com/jvm-garbage-collectors">https://www.baeldung.com/jvm-garbage-collectors</a></br>
= Serial Garbage Collector</br>
This is the simplest GC implementation, as it basically works with a single thread. As a result, this GC implementation freezes all application threads when it runs. Hence, it is not a good idea to use it in multi-threaded applications like server environments.</br>
The Serial GC is the GC of choice for most applications that do not have small pause time requirements and run on client-style machines. </br>
To enable Serial GC, we can use the following argument: -XX:+UseSerialGC</br>
</p>
<p align="justify">
= Parallel Garbage Collector</br>
It’s the default GC of the JVM and sometimes called Throughput Collector. Unlike Serial GC, this uses multiple threads for managing heap space. But it also freezes other application threads while performing GC.</br>
If we use this GC, we can specify maximum garbage collection threads and pause time, throughput and footprint (heap size).</br>
The numbers of garbage collector threads can be controlled with the command-line option -XX:ParallelGCThreads=<N>.</br>
The maximum pause time goal (gap [in milliseconds] between two GC) is specified with the command-line option -XX:MaxGCPauseMillis=<N>.</br>
The maximum throughput target (measured regarding the time spent doing garbage collection versus the time spent outside of garbage collection) is specified by the command-line option -XX:GCTimeRatio=<N>.</br>
Maximum heap footprint (the amount of heap memory that a program requires while running) is specified using the option -Xmx<N>.</br>
To enable Parallel GC, we can use the following argument: -XX:+UseParallelGC</br>
</p>
<p align="justify">
= CMS Garbage Collector</br>
The Concurrent Mark Sweep (CMS) implementation uses multiple garbage collector threads for garbage collection. It’s designed for applications that prefer shorter garbage collection pauses, and that can afford to share processor resources with the garbage collector while the application is running.</br>
Simply put, applications using this type of GC respond slower on average but do not stop responding to perform garbage collection.</br>
A quick point to note here is that since this GC is concurrent, an invocation of explicit garbage collection such as using System.gc() while the concurrent process is working, will result in Concurrent Mode Failure / Interruption.</br>
If more than 98% of the total time is spent in CMS garbage collection and less than 2% of the heap is recovered, then an OutOfMemoryError is thrown by the CMS collector. If necessary, this feature can be disabled by adding the option -XX:-UseGCOverheadLimit to the command line.</br>
This collector also has a mode knows as an incremental mode which is being deprecated in Java SE 8 and may be removed in a future major release.</br>
To enable the CMS GC, we can use the following flag: -XX:+UseParNewGC</br>
</p>
<p align="justify">
= G1 Garbage Collector</br>
G1 (Garbage First) GC is designed for applications running on multi-processor machines with large memory space. It’s available since JDK7 Update 4 and in later releases.</br>
G1 collector will replace the CMS collector since it’s more performance efficient.</br>
Unlike other collectors, G1 collector partitions the heap into a set of equal-sized heap regions, each a contiguous range of virtual memory. When performing garbage collections, G1 shows a concurrent global marking phase (i.e. phase 1 known as Marking) to determine the liveness of objects throughout the heap.</br>
After the mark phase is completed, G1 knows which regions are mostly empty. It collects in these areas first, which usually yields a significant amount of free space (i.e. phase 2 known as Sweeping). It is why this method of garbage collection is called Garbage-First.</br>
To enable G1 GC, we can use the following argument: -XX:+UseG1GC</br>
</p>
<p align="justify">
= News in Java 8</br>
Java 8u20 has introduced one more JVM parameter for reducing the unnecessary use of memory by creating too many instances of same String. This optimizes the heap memory by removing duplicate String values to a global single char[] array.</br>
This parameter can be enabled by adding -XX:+UseStringDeduplication as JVM parameter.</br>
</p>
<p align="justify">
<b>String.intern()</b></br>
<a href="https://habr.com/ru/post/79913/">https://habr.com/ru/post/79913/</a></br>
Сравнение через equals() медленное, т.к. осуществляется посимвольное сравнение.</br>
При вызове intern() строка помещается в множество (пул) строк, и потом для другой тестовой строки можно быстро проверить ее принадлежность к множеству.</br>
Если логика приложения такова, что приходится многократно сравнивать строки, возможно есть смысл интернировать строки, и тогда сравнивать интернированные строки можно посредством оператора ==.</br>
Некоторые замечания:</br>
= Константные строки автоматически интернируются: "version" == "version".intern(). Явно вызывать intern() стоит только для неконстантных строк.</br>
= Интернированные строки не хранятся вечно. Строки, на которых нет ссылок, также удаляются сборщиком мусора.</br>
= В большинстве случаев вы не получите существенного прироста производительности от использования intern() — если сравнение строк не является основной (или очень частой) операцией вашего приложения и сравниваемые строки разные по длине.</br>
</p>
<p align="justify">
<b>Типы мэпингов в гибернейте</b></br>
See example in java-sandbox repo:</br>
<a href="https://bitbucket.org/andrei_punko/java-sandbox/src/master/hibernate-mappings/">https://bitbucket.org/andrei_punko/java-sandbox/src/master/hibernate-mappings/</a></br>
</p>
<p align="justify">
<b>Root-aggregate philosophy</b></br>
<a href="https://deviq.com/aggregate-pattern/">https://deviq.com/aggregate-pattern/</a></br>
An aggregate is a collection of one or more related entities (and possibly value objects). Each aggregate has a single root entity, referred to as the aggregate root. The aggregate root is responsible for controlling access to all of the members of its aggregate. It’s perfectly acceptable to single-entity aggregates, in which case that entity is itself the root of its aggregate. In addition to controlling access, the aggregate root is also responsible for ensuring the consistency of the aggregate. This is why it is important to ensure that the aggregate root does not directly expose its children, but rather controls access itself.</br>
When applying the aggregate pattern, it is also important that persistence operations apply only at the aggregate root level. Thus, the aggregate root must be an entity, not a value object, so that it can be persisted to and from a data store using its ID. This is important, since it means the aggregate root can be certain that other parts of the system are not fetching its children, modifying them, and saving them without its knowledge. It also can simplify the relationships between entities, since typically navigation properties should only exist for types within aggregates, while other relationships should be by key only.</br>
= As an example, consider an e-commerce domain which has concepts for Orders, which have multiple OrderItems, each of which refers to some quantity of Products being purchased. Adding and removing items to an Order should be controlled by the Order – parts of the application shouldn’t be able to reach out and create an individual OrderItem as part of an Order without going through the Order. Deleting an Order should delete all of the OrderItems that are associated with it. So, Order makes sense as an aggregate root for the Order – OrderItem group.</br>
What about Product? Each OrderItem represents (among other things) a quantity of a product. Does it make sense for OrderItem to have a navigation property for Product? If so, that would complicate the Order aggregate, since ideally it should be able to traverse all of its navigation properties when persisting. As a test, does it make sense to delete Product A if an order for that product is deleted? Almost definitely not. Thus, Product doesn’t belong within the Order aggregate. It’s likely that Product should be its own aggregate root, in which case fetching product instances can be done using a Repository. All that’s required to do so is its ID. Thus, if OrderItem only refers to Product by Id, that’s sufficient.</br>
In short (by mine words): we design app in such way, when entity grouped by domain spec and Order contains OrderItems, but OrderItem refers to particular Order by id only</br>
</p>
<p align="justify">
<b>Как работает индекс в БД (какую структуру строит)?</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)">https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)</a></br>
Индекс — объект БД, создаваемый с целью повышения производительности поиска данных.</br>
Для оптимальной производительности запросов индексы обычно создаются на тех столбцах таблицы, которые часто используются в запросах. Для одной таблицы может быть создано несколько индексов. Однако увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этом приходится обновлять сами индексы.</br>
Индексы могут быть реализованы различными структурами. Наиболее часто употребимы B*-деревья, B+-деревья, B-деревья и хеши. </br>
</p>
<p align="justify">
(B-дерево - сбалансированное, сильно ветвистое дерево. Часто используется для хранения данных во внешней памяти.</br>
Сбалансированность означает, что длина любых двух путей от корня до листьев различается не более, чем на единицу.</br>
Ветвистость дерева — это свойство каждого узла дерева ссылаться на большое число узлов-потомков.</br>
B*-дерево — разновидность B-дерева, в которой каждый узел дерева заполнен не менее чем на ⅔ (в отличие от B-дерева, где этот показатель составляет 1/2).</br>
B+-дерево — структура данных на основе B-дерева, сбалансированное n-арное дерево поиска с переменным, но зачастую большим количеством потомков в узле. B+-дерево состоит из корня, внутренних узлов и листьев, корень может быть либо листом, либо узлом с двумя и более потомками)</br>
</p>
<p align="justify">
<b>Ускоряет ли индекс работу с бд для запросов вида like?</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)">https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)</a></br>
Для запроса вида: SELECT email_address FROM customers WHERE email_address LIKE '%@yahoo.com'; наличие индекса для столбца email_address не ускоряет поиск.</br>
Этот запрос должен нам найти всех клиентов, у которых е-мейл заканчивается на @yahoo.com, однако даже если по столбцу email_address есть индекс, СУБД всё равно будет использовать полный перебор таблицы. Это связано с тем, что индексы строятся в предположении, что слова/символы идут слева направо. Использование символа подстановки в начале условия поиска исключает для СУБД возможность использования поиска по B-дереву. Эта проблема может быть решена созданием дополнительного индекса по выражению reverse(email_address) и формированием запроса вида: SELECT email_address FROM customers WHERE reverse(email_address) LIKE reverse('%@yahoo.com');.</br>
В данном случае символ подстановки окажется в самой правой позиции (moc.oohay@%), что не исключает использование индекса по reverse(email_address). </br>
</p>
<p align="justify">
<b>Композитный индекс в БД</b></br>
Составной (многоключевой, композитный) индекс — строится по нескольким столбцам. Важен порядок следования полей</br>
Та же структура данных, что в обычном индексе, но в узлах присутствуют дополнительные условия для других столбцов</br>
Один композитный индекс заменяет несколько более простых: к примеру при наличии составного индекса по А,Б,В следующие индексы уже не необходимы: индекс по А; композитный по А,Б</br>
</p>
<p align="justify">
<b>Уровни изоляции транзакций, названия проблем, которые они решают. какой уровень по умолчанию?</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9</a></br>
При параллельном выполнении транзакций возможны следующие проблемы:</br>
= потерянное обновление (lost update) — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего;</br>
= "грязное" чтение (dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);</br>
= неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;</br>
= фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.</br>
</p>
<p align="justify">
Под "уровнем изоляции транзакций" понимается степень обеспечиваемой внутренними механизмами СУБД (то есть не требующей специального программирования) защиты от всех или некоторых вышеперечисленных видов несогласованности данных, возникающих при параллельном выполнении транзакций. Стандарт SQL-92 определяет шкалу из четырёх уровней изоляции: Read uncommitted, Read committed, Repeatable read, Serializable. Первый из них является самым слабым, последний — самым сильным, каждый последующий включает в себя все предыдущие.</br>
</p>
<p align="justify">
= Read uncommitted (чтение незафиксированных данных)</br>
Низший (первый) уровень изоляции. Он гарантирует только отсутствие потерянных обновлений. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.</br>
Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполняются последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются. </br>
</p>
<p align="justify">
= Read committed (чтение фиксированных данных) (он обычно - по умолчанию)</br>
Большинство промышленных СУБД, в частности, Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют именно этот уровень. На этом уровне обеспечивается защита от чернового, "грязного" чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.</br>
Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или версионности.</br>
</p>
<p align="justify">
= Repeatable read (повторяемость чтения)</br>
Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.</br>
Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.   </br>
</p>
<p align="justify">
= Serializable (упорядочиваемость)</br>
Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется последовательно, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту "фантомного чтения"</br>
</p>
<p align="justify">
<b>Сокеты</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)">https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)</a></br>
Сокет (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.</br>
Следует различать клиентские и серверные сокеты. Клиентские сокеты грубо можно сравнить с конечными аппаратами телефонной сети, а серверные — с коммутаторами. Клиентское приложение (например, браузер) использует только клиентские сокеты, а серверное (например, веб-сервер, которому браузер посылает запросы) — как клиентские, так и серверные сокеты.</br>
Интерфейс сокетов впервые появился в BSD Unix. Программный интерфейс сокетов описан в стандарте POSIX и в той или иной мере поддерживается всеми современными ОС</br>
</p>
<p align="justify">
<b>Long-polling</b></br>
<a href="https://habr.com/ru/post/335106/">https://habr.com/ru/post/335106/</a></br>
Long Polling — это технология, которая позволяет получать информацию о новых событиях с помощью «длинных запросов». Сервер получает запрос, но отправляет ответ на него не сразу, а лишь тогда, когда произойдет какое-либо событие (например, поступит новое входящее сообщение), либо истечет заданное время ожидания.</br>
Другими словами, получая от вас запрос, сервер ждет, когда произойдет событие, о котором он должен вас уведомить, и, когда оно происходит, Long Poll сервер отправляет ответ на ваш запрос, содержащий информацию о случившемся событии.</br>
</p>
<p align="justify">
<b>Http</b></br>
HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных. Основой HTTP является технология «клиент-сервер», т.е. предполагается существование:</br>
	= Потребителей (клиентов), которые инициируют соединение и посылают запрос;</br>
	= Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</br>
HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV. </br>
Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т.д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения, клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым. </br>
HTTP — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования. </br>
</p>
<p align="justify">
= Структура протокола</br>
Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</br>
	= Стартовая строка (англ. Starting line) — определяет тип сообщения;</br>
    = Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;</br>
    = Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.</br>
</p>
<p align="justify">
Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:</br>
    Метод URI HTTP/Версия</br>
</p>
<p align="justify">
Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):</br>
	GET /wiki/HTTP HTTP/1.0</br>
	Host: ru.wikipedia.org</br>
</p>
<p align="justify">
= Методы</br>
	= OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях. </br>
	= GET - Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.</br>
	Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: GET /path/resource?param1=value1&param2=value2 HTTP/1.1</br>
	Согласно стандарту HTTP, запросы типа GET считаются идемпотентными</br>
	= HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. </br>
	= POST - применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер.</br>
	В отличие от метода GET, метод POST не считается идемпотентным, то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).</br>
	При результате выполнения 200 (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location. </br>
	= PUT - Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).</br>
	Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу. </br>
	= PATCH - Аналогично PUT, но применяется только к фрагменту ресурса. </br>
	= DELETE - Удаляет указанный ресурс. </br>
	= TRACE - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе. </br>
</p>
<p align="justify">
= Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение.</br>
Примеры заголовков:</br>
	Server: Apache/2.2.11 (Win32) PHP/5.3.0</br>
	Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT</br>
	Content-Type: text/plain; charset=windows-1251</br>
	Content-Language: ru</br>
Все заголовки разделяются на четыре основных группы:</br>
    General Headers («Основные заголовки») — могут включаться в любое сообщение клиента и сервера;</br>
    Request Headers («Заголовки запроса») — используются только в запросах клиента;</br>
    Response Headers («Заголовки ответа») — только для ответов от сервера;</br>
    Entity Headers («Заголовки сущности») — сопровождают каждую сущность сообщения.</br>
Именно в таком порядке рекомендуется посылать заголовки получателю. </br>
</p>
<p align="justify">
= Тело HTTP-сообщения (message-body), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта (entity-body) только в том случае, когда применяется кодирование передачи, что указывается полем заголовка Transfer-Encoding.</br>
	message-body = entity-body</br>
	| <entity-body закодировано согласно Transfer-Encoding></br>
Поле Transfer-Encoding должно использоваться для указания любого кодирования передачи, применённого приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле Transfer-Encoding — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением в цепочке запросов/ответов. </br>
</p>
<p align="justify">
<b>Уровни кэша Hibernate, кэш запросов</b></br>
<a href="https://habr.com/ru/post/135176/">https://habr.com/ru/post/135176/</a></br>
Hibernate cache — это 3 уровня кеширования:</br>
    Кеш первого уровня (First-level cache);</br>
    Кеш второго уровня (Second-level cache);</br>
    Кеш запросов (Query cache);</br>
= Кеш первого уровня всегда привязан к объекту сессии. Hibernate всегда по умолчанию использует этот кеш и его нельзя отключить.</br>
= Кеш второго уровня привязан к объекту-фабрике сессий (Session Factory object). Что как бы подразумевает, что видимость этого кеша гораздо шире кеша первого уровня.</br>
Hibernate не хранит сами объекты классов. Он хранит информацию в виде массивов строк, чисел и т.д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Приблизительно можно представить себе это так:</br>
1 -> { "Pupkin", 1, null , {1,2,5} }</br>
По умолчанию кеш второго уровня отключен. </br>
Чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня.</br>
На самом деле, Hibernate сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации нашего ORM фреймворка. Из популярных реализаций можно выделить следующие: EHCache, OSCache, SwarmCache, JBoss TreeCache</br>
= Кеш запросов похож на кеш второго уровня. Но в отличии от него — ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса. Таким образом, этот кеш рационально использовать с кешем второго уровня.</br>
Он тоже по умолчанию отключен. </br>
Session factory также может генерировать и сохранять статистику использования всех объектов, регионов, зависимостей в кеше. Для этого есть объекты Statistics для фабрики и SessionStatistics для сессии.</br>
</p>
<p align="justify">
<b>Hibernate second level cache concurrency strategies (стратегии кеширования)</b></br>
<a href="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-cache-mapping">http://docs.jboss.org/hibernate/core/3.3/reference/en/html/performance.html#performance-cache-mapping</a></br>
Стратегии кеширования определяют поведения кеша в определенных ситуациях. Выделяют четыре группы:</br>
= Read-only. If your application needs to read, but not modify, instances of a persistent class, a read-only cache can be used. This is the simplest and optimal performing strategy. It is even safe for use in a cluster. </br>
= Read-write. If the application needs to update data, a read-write cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. </br>
= Nonstrict-read-write. If the application only occasionally needs to update data (i.e. if it is extremely unlikely that two transactions would try to update the same item simultaneously), and strict transaction isolation is not required, a nonstrict-read-write cache might be appropriate. </br>
= Transactional. The transactional cache strategy provides support for fully transactional cache providers such as JBoss TreeCache.</br>
</p>
<p align="justify">
<b>Volatile</b></br>
Модификатор volatile накладывает некоторые дополнительные условия на чтение/запись переменной:</br>
= Операции чтения/записи volatile переменной являются атомарными</br>
= Результат операции записи значения в volatile переменную одним потоком, становится виден всем другим потокам, которые используют эту переменную для чтения из нее значения</br>
Компилятор прекращает выполнять различную оптимизацию, связанную с этой переменной, (к примеру, помещение копии в регистры) и всегда читает ее значение из памяти.</br>
</p>
<p align="justify">
<b>Happens-before</b></br>
<a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html">https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html</a></br>
Happens-before relationship is a guarantee that action performed by one thread is visible to another action in different thread.</br>
Happens-before defines a partial ordering on all actions within the program. To guarantee that the thread executing action Y can see the results of action X (whether or not X and Y occur in different threads), there must be a happens-before relationship between X and Y. In the absence of a happens-before ordering between two operations, the JVM is free to reorder them as it wants (JIT compiler optimization). </br>
Happens-before is not just reordering of actions in 'time' but also a guarantee of ordering of read and write to memory . Two threads performing write and read to memory can be consistent to each other actions in terms of clock time but might not see each others changes consistently (Memory Consistency Errors) unless they have happens-before relationship. </br>
</p>
<p align="justify">
How to establish happens-before relation?</br>
Followings are the rules for happens-before:</br>
= Single thread rule: Each action in a single thread happens-before every action in that thread that comes later in the program order.</br>
= Monitor lock rule: An unlock on a monitor lock (exiting synchronized method/block) happens-before every subsequent acquiring on the same monitor lock.</br>
= Volatile variable rule: A write to a volatile field happens-before every subsequent read of that same field. Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors (synchronized block around reads and writes), but without actually aquiring monitors/locks.</br>
= Thread start rule: A call to Thread.start() on a thread happens-before every action in the started thread. Say thread A spawns a new thread B by calling threadA.start(). All actions performed in thread B's run method will see thread A's calling threadA.start() method and before that (only in thread A) happened before them.</br>
= Thread join rule: All actions in a thread happen-before any other thread successfully returns from a join on that thread. Say thread A spawns a new thread B by calling threadA.start() then calls threadA.join(). Thread A will wait at join() call until thread B's run method finishes. After join method returns, all subsequent actions in thread A will see all actions performed in thread B's run method happened before them.</br>
= Transitivity: If A happens-before B, and B happens-before C, then A happens-before C.</br>
</p>
<p align="justify">
<b>Apache Kafka & NATS</b></br>
<a href="https://habr.com/ru/post/326880/">https://habr.com/ru/post/326880/</a></br>
= Лидером по популярности у разработчиков является RabbitMQ. Это проверенное временем решение класса Enterprise с гарантиями доставки, гибкой системой маршрутизации и поддержкой всевозможных стандартов. Производительность RabbitMQ не превышает десятки тысяч сообщений в секунду.</br>
= Apache Kafka, которая родилась внутри компании LinkedIn как система агрегации логов. Kafka умеет выжимать бОльшую производительность из дисковой подсистемы, чем RabbitMQ, поскольку она пишет данные последовательно (sequential I/O), а не случайно (random I/O).</br>
В Kafka данные делятся по разделам (partition) и чтобы соблюдать порядок доставки каждый получатель сообщений читает данные ровно из одного раздела.</br>
Для управления кластером Kafka требуется отдельный сервис (zookeeper).</br>
= NATS — относительно молодой проект, созданный Derek Collison, за плечами которого более 20 лет работы над распределенными очередями сообщений. По производительности NATS опережает все очереди с “гарантированной доставкой”. NATS написан на языке Go, но имеет клиентские библиотеки для всех популярных языков. Кроме того, клиенты NATS также знают топологию кластера и способны самостоятельно переподключаться в случае потери связи со своим узлом.</br>
</p>
<p align="justify">
<b>Different loggers configuration</b></br>
<a href="https://habr.com/ru/post/247647/	Java logging. Hello World">https://habr.com/ru/post/247647/	Java logging. Hello World</a></br>
<a href="https://habr.com/ru/post/113145/	Java Logging: история кошмара">https://habr.com/ru/post/113145/	Java Logging: история кошмара</a></br>
</p>
<p align="justify">
<b>MQTT</b></br>
<a href="https://ru.wikipedia.org/wiki/MQTT">https://ru.wikipedia.org/wiki/MQTT</a></br>
MQTT (англ. message queuing telemetry transport) — упрощённый сетевой протокол, работающий поверх TCP/IP, ориентированный для обмена сообщениями между устройствами по принципу издатель-подписчик.</br>
Протокол ориентируется на простоту в использовании, невысокую нагрузку на каналы связи, работу в условиях постоянной потери связи, лёгкую встраиваемость в любую систему. Основное предназначение — работа с телеметрией от различных датчиков, устройств, использование шаблона подписчика обеспечивает возможность устройствам выходить на связь и публиковать сообщения, которые не были заранее известны или предопределены, в частности, протокол не вводит ограничений на формат передаваемых данных. </br>
</p>
<p align="justify">
<b>DDD (domain driven design)</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5</a></br>
Предметно-ориентированное проектирование — это набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом.</br>
</p>
<p align="justify">
Предметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD — это набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области.</br>
</p>
<p align="justify">
Подход DDD особо полезен в ситуациях, когда разработчик не является специалистом в области разрабатываемого продукта. К примеру: программист не может знать все области, в которых требуется создать ПО, но с помощью правильного представления структуры, посредством проблемно-ориентированного подхода, может без труда спроектировать приложение, основываясь на ключевых моментах и знаниях рабочей области. </br>
</p>
<p align="justify">
Основные определения:</br>
= Область (англ. domain, домен) — предметная область, к которой применяется разрабатываемое программное обеспечение.</br>
= Модель (англ. model) — описывает отдельные аспекты области и может быть использована для решения проблемы.</br>
= Язык описания — используется для единого стиля описания домена и модели.</br>
</p>
<p align="justify">
Концепция</br>
В идеале, при проектировании хочется иметь одну-единственную модель, которая полностью описывает всю предметную область, но в реальности, для упрощения процесса разработки продукта, домен представляют в виде сочетания нескольких взаимосвязанных моделей.</br>
Схема архитектуры приложения представляет собой описание одной или нескольких моделей предметной области и их взаимосвязей между собой. </br>
</p>
<p align="justify">
Ограниченные связи</br>
Использование нескольких моделей на различных уровнях проекта. Данный подход используется для уменьшения различных связей между моделями, что исключает сложность и запутанность кода. Иногда бывает неясно, в каком именно контексте должна использоваться модель.</br>
Решение: Точно определить контекст, в котором используется модель. Определить границы использования данной модели и её характеристики.</br>
</p>
<p align="justify">
Целостность</br>
Когда над проектом работает большое количество людей, то есть тенденция дробить модель на несколько более мелких, фрагментов. Чем больше людей, тем более значительна данная проблема. В конечном итоге теряется целостность проекта.</br>
Решение: Постоянное объединение кусков кода от различных разработчиков и проверка работоспособности посредством тестирования. Это позволяет держаться всем разработчикам в одной большой концепции.</br>
</p>
<p align="justify">
Взаимосвязь</br>
При работе над несколькими отдельными моделями в большой группе, различные члены команды могут не знать о сущностях других моделей, что усложняет процесс общей сборки конечного продукта.</br>
Решение: На этапе проектирования точно обозначьте, что именно выполняет каждая модель и как она взаимосвязана с другими моделями. В конечном итоге у вас должна получиться карта взаимосвязей моделей.</br>
</p>
<p align="justify">
Элементы DDD</br>
При проектировании на основе проблемно-ориентированного подхода используются следующие понятия:</br>
</p>
<p align="justify">
Контекст</br>
В большинстве систем для предприятий используются крупномасштабные зоны ответственности. В DDD этот высший уровень организации называется ограниченным контекстом. Например, система биллинга крупной телекоммуникационной компании может иметь следующие ключевые элементы:</br>
    клиентская база</br>
    система безопасности и защиты</br>
    резервное копирование</br>
    взаимодействие с платежными системами</br>
    ведение отчетности</br>
    администрирование</br>
    система уведомлений</br>
Все перечисленные элементы должны быть включены в единую, работающую без перебоев систему. При проектировании система уведомлений и система безопасности выделяются как совершенно разные вещи. Системы, в которых при реализации не удаётся разделить и изолировать ограниченные контексты, часто приобретают архитектурный стиль, который имеет красноречивое название «Большой ком грязи».</br>
Сутью проблемно-ориентированного проектирования является конкретное определение контекстов и ограничение моделирования в их рамках.</br>
</p>
<p align="justify">
Сущность</br>
Проще всего сущности выражать в виде существительных: люди, места, товары и т.д. У сущностей есть и индивидуальность, и жизненный цикл. Во время проектирования думать о сущностях следует как о единицах поведения, нежели как о единицах данных. Чаще всего какие-то операции, которые вы пытаетесь добавить в модель, должна получить какая-то сущность, или при этом начинает создаваться или извлекаться новая сущность. В более слабом коде можно найти массу служебных или управляющих классов, проверяющих сущности снаружи.</br>
</p>
<p align="justify">
Объект-значение </br>
— это свойства, важные в той предметной области, которую вы моделируете. У них, в отличие от сущностей, нет обозначения; они просто описывают конкретные сущности, которые уже имеют обозначения. Полезность объектов-значений состоит в том, что они описывают свойства сущностей гораздо более изящным и объявляющим намерения способом. Стоит всегда помнить, что значение объекта никогда не изменяется на протяжении выполнения всего программного кода. После их создания, внесение поправок невозможно.</br>
</p>
<p align="justify">
Сводный корень </br>
— специальная сущность, к которой напрямую обращаются потребители. Использование при проектировании концепции сводных корней позволяет избегать чрезмерного соединения объектов между собой, составляющих модель, за счет применения правила: сводные корни — единственный вид сущностей, на который может ссылаться используемая программа. Это позволяет избежать путаницы и упростить структуру архитектуры кода, потому что теперь у вас есть специальное ограничение, не дающее создавать тесно связанные системы, где все сопряжено со всем.</br>
</p>
<p align="justify">
Службы</br>
Иногда в предметной области есть операции или процессы, у которых нет обозначения или жизненного цикла. Службы области дают инструмент для моделирования этих концепций. Они характеризуются отсутствием состояния и высокой связностью, часто предоставляя один открытый метод и иногда перегрузку для действий над наборами. Если в поведение включено несколько зависимостей, и нет возможности найти подходящего места в сущности для размещения этого поведения, в этом случае используют службу. Хотя сам по себе термин «служба» в мире разработки перегружен различными значениями, но в данной тематике, это обозначает небольшой класс, не представляющий конкретного человека, место или вещь в проектируемом приложении, но включающий в себя какие-то процессы. Использование служб позволяет ввести многослойную архитектуру, так же интегрировать несколько моделей, что вносит зависимость от инфраструктуры.</br>
</p>
<p align="justify">
Взаимосвязь с подходами программирования</br>
Хотя по концепции проблемно-ориентированное проектирование не должно быть ограничено какими-либо представлениями, но на практике используются сильные стороны объектно-ориентированного программирования. Это использование наследования, инкапсуляции, представления в виде методов и классов. Нужно помнить, что объектно-ориентированный подход может быть применен не только к ООП языкам, таким как Java, C# или C++, но так же и к функциональным — F#, Erlang. Особенно удобны языки, поддерживающие создание и использование собственных предметно-ориентированных языков, такие как Scala.</br>
</p>
<p align="justify">
Тестирование</br>
<b>Является неотъемлемой частью разработки. Оно позволяет быть уверенным в работоспособности разрабатываемого продукта на всех этапах разработки. Практичнее производить разработку посредством автотестов по технике TDD.</b></br>
При тестировании сводных корней, применяют модульное тестирование. Причем при использовании проблемно-ориентированного проектирования тесты сводных корней склоняются в сторону парадигмы черного ящика и тестирования состояния. Сводные корни и сущности часто становятся конечными автоматами, и их поведение этому соответствует. </br>
</p>
<p align="justify">
<b>Bounded context</b></br>
<a href="https://codeburst.io/ddd-strategic-patterns-how-to-define-bounded-contexts-2dc70927976e">https://codeburst.io/ddd-strategic-patterns-how-to-define-bounded-contexts-2dc70927976e</a></br>
Bounded context is a logical boundary. It defines tangible boundaries of applicability of some sub-domain. It's an area where a certain sub-domain makes sense, while the others don’t.</br>
</p>
<p align="justify">
<b>JVM memory model</b></br>
<a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></br>
Each thread running in the Java virtual machine has its own thread stack. The thread stack contains information about what methods the thread has called to reach the current point of execution. I will refer to this as the "call stack". As the thread executes its code, the call stack changes.</br>
</p>
<p align="justify">
The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it's own thread stack. Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code, the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.</br>
</p>
<p align="justify">
All local variables of primitive types (boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads. One thread may pass a copy of a pritimive variable to another thread, but it cannot share the primitive local variable itself.</br>
</p>
<p align="justify">
The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap. </br>
</p>
<p align="justify">
A local variable may be of a primitive type, in which case it is totally kept on the thread stack.</br>
</p>
<p align="justify">
A local variable may also be a reference to an object. In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.</br>
</p>
<p align="justify">
An object may contain methods and these methods may contain local variables. These local variables are also stored on the thread stack, even if the object the method belongs to is stored on the heap.</br>
</p>
<p align="justify">
An object's member variables are stored on the heap along with the object itself. That is true both when the member variable is of a primitive type, and if it is a reference to an object.</br>
</p>
<p align="justify">
Static class variables are also stored on the heap along with the class definition.</br>
</p>
<p align="justify">
Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object's member variables. If two threads call a method on the same object at the same time, they will both have access to the object's member variables, but each thread will have its own copy of the local variables. </br>
</p>
<p align="justify">
If two or more threads are sharing an object, without the proper use of either volatile declarations or synchronization, updates to the shared object made by one thread may not be visible to other threads.</br>
</p>
<p align="justify">
Imagine that the shared object is initially stored in main memory. A thread running on CPU one then reads the shared object into its CPU cache. There it makes a change to the shared object. As long as the CPU cache has not been flushed back to main memory, the changed version of the shared object is not visible to threads running on other CPUs. This way each thread may end up with its own copy of the shared object, each copy sitting in a different CPU cache. </br>
</p>
<p align="justify">
<b>С чего начать по CI на новом проекте?</b></br>
= создать репозиторий, настроить Gitlab/Stash, добавить публичные ssh-ключи девелоперов</br>
= установить билд сервер Jenkins/TeamCity и артифактори JFrog/Nexus, нужную версию Java и сборщика Maven/Gradle</br>
= создать джобы автоматических билдов веток по пушу и релизные джобы, добавить пайплайны при необходимости, настроить интеграцию Gitlab/Stash c билд сервером</br>
= настроить нотификации о билдах в командные чаты и почту</br>
</p>
<p align="justify">
<b>Как работает магия Spring Data?</b></br>
Как я это понимаю: Spring парсит названия методов и анализирует JPA классы; при наличии соответствующих полей - создает прокси инстанс с нужными методами, внутри которых производит вызовы соответствующих SQL-запросов</br>
</p>
<p align="justify">
<b>Деловая активность как замена продуктивности:</b></br>
В отсутствие четких индикаторов того, что значить быть продуктивным и ценным на своем рабочем месте, многие интеллектуальные работники возвращаются к индикаторам продуктивности времен индустриальной эпохи, а именно пытаются производить большое количество материала максимально наглядным образом (Кэл Ньюпорт)</br>
</p>
<p align="justify">
<b>Понимание устройства ORM-фреймворков</b></br>
Через reflection читаются аннотации на классах, методах; по ним генерируются соответствующие sql-запросы для взаимодействия с нужными таблицами в БД</br>
</p>
<p align="justify">
<b>Kubernetes</b></br>
<a href="https://eax.me/kubernetes/">https://eax.me/kubernetes/</a></br>
</p>
<p align="justify">
<b>Проблема распознавания символов церковнославянских текстов</b></br>
<a href="http://slavtype.ru/">http://slavtype.ru/</a></br>
<a href="https://sci.ponomar.net/ru/fonts.html">https://sci.ponomar.net/ru/fonts.html</a></br>
Нужные символы в таблицы Unicode добавлены, преобразователи текстов (в виде приложения или онлайн) из старых форматов в Unicode существуют; все уже сделано, в общем</br>
</p>
<p align="justify">
<b>Синхронизаторы</b></br>
<a href="https://habr.com/ru/post/277669/">https://habr.com/ru/post/277669/</a></br>
</p>
<p align="justify">
= Семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (Semaphore(int permits) или Semaphore(int permits, boolean fair)) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.</br>
</p>
<p align="justify">
= CountDownLatch (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. Примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.</br>
</p>
<p align="justify">
= CyclicBarrier реализует шаблон синхронизации Барьер. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». Барьер похож на CountDownLatch, но главное различие между ними в том, что вы не можете заново использовать «замок» после того, как его счётчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается. CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились.</br>
</p>
<p align="justify">
= Exchanger (обменник) может понадобиться, для того, чтобы обменяться данными между двумя потоками в определенной точки работы обоих потоков. Обменник — обобщенный класс, он параметризируется типом объекта для передачи. Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод exchange() блокируется и ждет другой поток. Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждая из них получит аргумент другой в методе exchange(). Стоит отметить, что обменник поддерживает передачу null значения. Это дает возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков.</br>
</p>
<p align="justify">
= Phaser (фазер), как и CyclicBarrier, является реализацией шаблона синхронизации Барьер, но, в отличии от CyclicBarrier, предоставляет больше гибкости. Этот класс позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Как и CyclicBarrier, Phaser является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, Phaser переходит к следующей фазе и снова ожидает ее завершения.</br>
</p>
<p align="justify">
<b>Difference Between Mocks and Stubs</b></br>
<a href="https://www.martinfowler.com/articles/mocksArentStubs.html">https://www.martinfowler.com/articles/mocksArentStubs.html</a></br>
= Dummy objects are passed around but never actually used. Usually they are just used to fill parameter lists.</br>
= Fake objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).</br>
= Stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test.</br>
= Spies are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.</br>
= Mocks are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</br>
</p>
<p align="justify">
<b>Which sorting algorithm is stable?</b></br>
<a href="https://stackoverflow.com/questions/1517793/what-is-stability-in-sorting-algorithms-and-why-is-it-important">https://stackoverflow.com/questions/1517793/what-is-stability-in-sorting-algorithms-and-why-is-it-important</a></br>
= Stable Sorting Algorithms:</br>
	Insertion Sort</br>
	Merge Sort</br>
	Bubble Sort</br>
	Tim Sort</br>
	Counting Sort</br>
</p>
<p align="justify">
= Unstable Sorting Algorithms:</br>
	Heap Sort</br>
	Selection sort</br>
	Shell sort</br>
	Quick Sort</br>
</p>
<p align="justify">
<b>Задачка про "сколько телефонных операторов надо?":</b></br>
Есть 2 массива времЕн длиной N каждый, содержащие времена начала звонка (1й массив) и конца звонка (2й массив). Определить, сколько телефонных операторов колл-центра надо, чтобы обработать все эти звонки (чтобы никто из клиентов не ждал).</br>
</p>
<p align="justify">
<b>Инкапсуляция - в общем случае в разных языках программирования термин относится к одной или обеим одновременно следующим нотациям:</b></br>
= механизм языка, позволяющий ограничить доступ одних компонентов программы к другим;</br>
= языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных.</br>
</p>
<p align="justify">
<b>Differences between the use of synchronized block and using Lock API's:</b></br>
<a href="https://www.baeldung.com/java-concurrent-locks">https://www.baeldung.com/java-concurrent-locks</a></br>
= A synchronized block is fully contained within a method – we can have Lock API's lock() and unlock() operation in separate methods</br>
= A synchronized block doesn't support the fairness, any thread can acquire the lock once released, no preference can be specified. We can achieve fairness within the Lock APIs by specifying the fairness property. It makes sure that longest waiting thread is given access to the lock</br>
= A thread gets blocked if it can't get an access to the synchronized block. The Lock API provides tryLock() method. The thread acquires lock only if it's available and not held by any other thread. This reduces blocking time of thread waiting for the lock</br>
= A thread which is in “waiting” state to acquire the access to synchronized block, can't be interrupted. The Lock API provides a method lockInterruptibly() which can be used to interrupt the thread when it's waiting for the lock</br>
</p>
<p align="justify">
<b>Аутентификация и авторизация</b></br>
<a href="https://artismedia.by/blog/difference-between-authentication-and-authorization/">https://artismedia.by/blog/difference-between-authentication-and-authorization/</a></br>
= Аутентификация используется для подтверждения личности зарегистрированного пользователя. Проверка подлинности – это процесс проверки учетных данных: идентификатора пользователя (имени, адреса электронной почты, номера телефона) и пароля.</br>
	* Однофакторная аутентификация (SFA) – базовый, традиционный метод проверки подлинности с использованием только одной категории. Наиболее распространенным примером SFA являются учетные данные, связанные с введением имени пользователя и обычного пароля.</br>
	* Двухфакторная аутентификация (2FA) – двухступенчатый процесс проверки, который учитывает два разных типа пользовательских данных. Помимо логина и пароля, для обеспечения дополнительного уровня защиты, система может запросить особый код, присланный в SMS сообщении или в письме электронной почты.</br>
	* Многофакторная аутентификация (MFA) – самый современный метод проверки подлинности, который использует два, три (или больше) уровня безопасности. Категории всех уровней должны быть независимыми друг от друга, чтобы устранить любую уязвимость в системе. Финансовые организации, банки, правоохранительные органы пользуются многофакторной аутентификацией для защиты своих данных от потенциальных угроз.</br>
</p>
<p align="justify">
= Авторизация - происходит после того, как личность пользователя успешно аутентифицируется системой. Процесс авторизации определяет, имеет ли прошедший проверку человек доступ к определенным ресурсам: информации, файлам, базе данных. Факторы проверки подлинности, необходимые для авторизации, могут различаться в зависимости от уровня безопасности.</br>
</p>
<p align="justify">
<b>Copy-On-Write</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%B8_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8">https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%B8_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8</a></br>
Механизм копирования при записи (Copy-On-Write, COW) используется для оптимизации многих процессов, происходящих в операционной системе, таких как, например, работа с оперативной памятью или файлами на диске.</br>
Идея подхода copy-on-write заключается в том, что при чтении области данных используется общая копия, в случае изменения данных — создается новая копия.</br>
</p>
<p align="justify">
<b>Spring: инициализация prototype бина как поле в синглтоне (spring bean scope proxy)</b></br>
</p>
<p align="justify">
<b>Описать как происходит оптимистическая/пессимистическая блокировка в БД:</b></br>
    пессимистическая: создание лока до и снятие после транзакции</br>
    оптимистическая: как compare-and-set, только проверяется column version</br>
</p>
<p align="justify">
<b>GRASP (general responsibility assignment software patterns) - общие шаблоны распределения ответственностей, используемые в ООП для решения общих задач по назначению ответственностей классам и объектам.</b></br>
<a href="https://ru.wikipedia.org/wiki/GRASP">https://ru.wikipedia.org/wiki/GRASP</a></br>
</p>
<p align="justify">
GRASP содержит 9 шаблонов:</br>
1. Информационный эксперт (Information Expert)</br>
Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.</br>
Если его не учесть — получится спагетти-код, в котором трудно разобраться.</br>
    Повышает:</br>
        Инкапсуляцию;</br>
        Простоту восприятия;</br>
        Готовность компонентов к повторному использованию;</br>
    Снижает:</br>
        степень зацепления.</br>
</p>
<p align="justify">
2. Создатель (Creator)</br>
Класс должен создавать экземпляры тех классов, которые он может:</br>
    Содержать или агрегировать;</br>
    Записывать;</br>
    Использовать;</br>
    Инициализировать, имея нужные данные.</br>
</p>
<p align="justify">
3. Контроллер (Controller)</br>
Отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление);</br>
Не выполняет работу самостоятельно, а делегирует компетентным исполнителям;</br>
	Может представлять собой:</br>
        Систему в целом;</br>
        Подсистему;</br>
        Корневой объект;</br>
        Устройство.</br>
</p>
<p align="justify">
4. Слабое зацепление (Low Coupling)</br>
«Степень зацепления» — мера неотрывности элемента от других элементов (либо мера данных, имеющихся у него о них).</br>
«Слабое» зацепление является оценочной моделью, которая диктует, как распределить обязанности, которые необходимо поддерживать.</br>
«Слабое» зацепление — распределение ответственностей и данных, обеспечивающее взаимную независимость классов.</br>
Класс со «слабым» зацеплением:</br>
    Имеет слабую зависимость от других классов;</br>
    Не зависит от внешних изменений (изменение в одном классе оказывает слабое влияние на другие классы);</br>
    Прост для повторного использования.</br>
</p>
<p align="justify">
5. Высокая связность (High Cohesion)</br>
Высокая связность класса — это оценочная модель, направленная на удержание объектов должным образом сфокусированными, управляемыми и понятными. Высокая связность обычно используется для поддержания низкого зацепления. Высокая связность означает, что обязанности данного элемента тесно связаны и сфокусированы. Разбиение программ на классы и подсистемы является примером деятельности, которая увеличивает связность системы.</br>
И наоборот, низкая связность — это ситуация, при которой данный элемент имеет слишком много несвязанных обязанностей. Элементы с низкой связностью часто страдают от того, что их трудно понять, трудно использовать, трудно поддерживать.</br>
Связность класса — мера сфокусированности предметных областей его методов:</br>
    «Высокая» связность — сфокусированные подсистемы (предметная область определена, управляема и понятна);</br>
    «Низкая» связность — абстрактные подсистемы, затруднены:</br>
        Восприятие;</br>
        Повторное использование;</br>
        Поддержка;</br>
        Устойчивость к внешним изменениям.</br>
</p>
<p align="justify">
6. Полиморфизм (Polymorphism)</br>
Устройство и поведение системы:</br>
    Определяется данными;</br>
    Задано полиморфными операциями её интерфейса.</br>
</p>
<p align="justify">
7. Чистая выдумка (Pure Fabrication)</br>
Не относится к предметной области, но:</br>
    Уменьшает зацепление;</br>
    Повышает связность;</br>
    Упрощает повторное использование.</br>
«Pure Fabrication» отражает концепцию сервисов в модели предметно-ориентированного проектирования. </br>
</p>
<p align="justify">
8. Посредник (Indirection)</br>
Слабое зацепление между элементами системы (и возможность повторного использования) обеспечивается назначением промежуточного объекта их посредником.</br>
</p>
<p align="justify">
9. Устойчивость к изменениям (Protected Variations)</br>
Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами. Поведение может варьироваться лишь через создание другой реализации интерфейса. </br>
</p>

<p align="justify">
<b>Рассказать про Gitflow</b></br>
<a href="https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow">https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow</a></br>
Gitflow Workflow — это модель рабочего процесса Git. Gitflow идеально подходит для проектов, в которых цикл релиза протекает по графику. Помимо веток feature в рамках этого рабочего процесса используются отдельные ветки для подготовки, поддержки и регистрации выпусков.</br>
Набор инструментов git-flow представляет собой отдельную командную строку, которая требует установки.</br>
После установки git-flow необходимо выполнить команду git flow init, чтобы использовать его в проекте. Этот набор играет роль оболочки Git.</br>
</p>
<p align="justify">
= Основные ветки (master) и ветки разработки (develop)</br>
Для фиксации истории проекта в рамках этого процесса вместо одной ветки master используются две ветки. В ветке master хранится официальная история релиза, а ветка develop предназначена для объединения всех функций. Кроме того, для удобства рекомендуется присваивать всем коммитам в ветке master номер версии.</br>
Первый шаг рабочего процесса заключается в создании ветки develop от стандартной ветки master.</br>
В этой ветке будет храниться полная история проекта, а в ветке master — сокращенная. Теперь другим разработчикам следует клонировать центральный репозиторий и создать отслеживающую ветку для ветки develop.</br>
</p>
<p align="justify">
= Функциональные ветки (feature)</br>
Под каждую новую функцию должна быть отведена собственная ветка feature, которую можно отправлять в центральный репозиторий для создания резервной копии или совместной работы команды. Ветки feature создаются не на основе master, а на основе develop. Когда работа над функцией завершается, соответствующая ветка сливается обратно с веткой develop. Функции не следует отправлять напрямую в ветку master.</br>
Как правило, ветки feature создаются на основе последней ветки develop.</br>
По завершении работы над функцией следует объединить ветку feature с develop.</br>
</p>
<p align="justify">
= Ветки выпуска (release)</br>
Когда в ветке develop оказывается достаточно функций для выпуска (или приближается назначенная дата выпуска), от ветки develop создается ветка release. Создание этой ветки запускает следующий цикл выпуска, и с этого момента новые функции добавить больше нельзя — допускается лишь отладка багов, создание документации и решение других задач, связанных с выпуском. Когда подготовка к поставке завершается, ветка release сливается с master и ей присваивается номер версии. Кроме того, для нее нужно выполнить слияние с веткой develop, в которой с момента создания ветки релиза могли возникнуть изменения.</br>
Благодаря тому, что для подготовки выпусков используется специальная ветка, одна команда может дорабатывать текущий выпуск, в то время как другая команда продолжает работу над функциями для следующего. Это также позволяет разграничить этапы разработки (например, можно без труда посвятить неделю подготовке к версии 4.0 и действительно увидеть это в структуре репозитория).</br>
Создание веток release — это еще одна простая операция ветвления. Как и ветки feature, ветки release основаны на ветке develop</br>
Когда релиз готов к отправке, он сливается в master и develop, а ветка release удаляется. Важно влить ее обратно в ветку develop, поскольку в ветку release могут быть добавлены критические обновления, и они должны быть доступны для новых функций. Если в вашей организации уделяют повышенное внимание проверке кода, это идеальное место для осуществления запроса pull.</br>
</p>
<p align="justify">
= Ветки исправления (hotfix) </br>
Ветки поддержки или ветки hotfix используются для быстрого внесения исправлений в рабочие релизы. Ветки hotfix очень похожи на ветки release и feature, за исключением того, что они создаются от master, а не от develop. Это единственная ветка, которая должна быть создана непосредственно от master. Как только исправление завершено, ветку следует объединить с master и develop (или текущей веткой release), а ветка master должна быть помечена обновленным номером версии.</br>
Наличие специальной ветки для исправления ошибок позволяет команде решать проблемы, не прерывая остальную часть рабочего процесса и не ожидая следующего цикла релиза. Ветки поддержки можно рассматривать как специальные ветки release, которые работают непосредственно с master. </br>
По завершении работы ветка hotfix, так же как и в случае с веткой release, объединяется с master и develop.</br>
</p>
<p align="justify">
= Пример</br>
Далее продемонстрирован полный цикл работы с функциональной веткой (предположим, что у нас есть репозиторий с веткой master):</br>
Git checkout master</br>
Git checkout -b develop</br>
Git checkout -b feature_branch</br>
# work happens on feature branch</br>
Git checkout develop</br>
Git merge feature_branch</br>
Git checkout master</br>
Git merge develop</br>
Git branch -d feature_branch</br>
</p>
<p align="justify">
Помимо работы с ветками feature и release, продемонстрируем работу с веткой hotfix:</br>
Git checkout master</br>
Git checkout -b hotfix_branch</br>
# идет работа, в hotfix_branch добавляются коммиты</br>
Git checkout develop</br>
Git merge hotfix_branch</br>
Git checkout master</br>
Git merge hotfix_branch</br>
</p>
<p align="justify">
= Последовательность действий при работе по модели Gitflow:</br>
Из ветки master создается ветка develop.</br>
Из ветки develop создается ветка release.</br>
Из ветки develop создаются ветки feature.</br>
Когда работа над веткой feature завершена, она сливается с веткой develop.</br>
Когда работа над веткой релиза release завершена, она сливается в ветки develop и master.</br>
Если в master обнаружена проблема, из master создается ветка hotfix.</br>
Когда работа над веткой исправления hotfix завершена, она сливается в ветки develop и master.</br>
</p>

<p align="justify">
<b>Написать сократитель ссылок</b></br>
1. записываем строку из символов англ. алфавита и цифр: abc..zABC..Z01..9 (62 символа)</br>
2. записываем исходную ссылку в БД, кодируем полученную ID записи по основанию 62 в цифро-буквенную строку</br>
3. записываем в БД (в ту же строку) сгенерированную цифро-буквенную строку</br>
4. возвращаем юзеру сгенерированную цифро-буквенную строку</br>
</p>
<p align="justify">
<b>Описать реализацию шардирования сократителя ссылок</b></br>
= Кодирование длинного урла (1й вариант):</br>
1. из исходного url отбрасываем 'http://' вначале, берем 1+ первых букв (сколько - зависит от кол-ва шард N у нас), кодируем эту пару букв в число (с основанием 26), берем остаток от деления числа этого на N - это будет номер шарды</br>
2. добавляем в таблицу БД новую запись вида (ID, LONG_STRING), генерируем короткую строку SHORT_STRING по ID, дописываем SHORT_STRING в эту строку.</br>
3. возвращаем пользователю строку вида 'http://' + домен кодировщика урлов + '/' + (использованые первые буквы исх. урла) + SHORT_STRING</br>
</p>
<p align="justify">
= Декодирование короткого урла (1й вариант):</br>
1. достаем нужное кол-во первых букв, декодируем в номер шарды</br>
2. из данной шарды достаем данные по ключу, полученного декодированием остальной строки</br>
3. возвращаем юзеру LONG_STRING</br>
</p>
<p align="justify">
= Кодирование url-a (2й вариант):</br>
1. выбираем случайную шарду. конвертируем номер шарды в букву (либо несколько букв, если шард много). так получим строку SHARD_STRING</br>
2. см. п.2 выше</br>
3. возвращаем пользователю строку вида 'http://' + домен кодировщика урлов + '/' + SHARD_STRING + SHORT_STRING</br>
</p>
<p align="justify">
= Декодирование короткого урла (2й вариант):</br>
Совпадает с первым вариантом</br>
</p>

<p align="justify">
<b>Паттерн Стратегия</b></br>
<a href="https://refactoring.guru/ru/design-patterns/strategy">https://refactoring.guru/ru/design-patterns/strategy</a></br>
Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.</br>
</p>
<p align="justify">
<b>Паттерн Шаблонный метод</b></br>
<a href="https://refactoring.guru/ru/design-patterns/template-method">https://refactoring.guru/ru/design-patterns/template-method</a></br>
Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.</br>
</p>
<p align="justify">
<b>What Is Inversion of Control?</b></br>
<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring</a></br>
= Inversion of Control is a principle in software engineering by which the control of objects or portions of a program is transferred to a container or framework. It's most often used in the context of object-oriented programming.</br>
</p>
<p align="justify">
= By contrast with traditional programming, in which our custom code makes calls to a library, IoC enables a framework to take control of the flow of a program and make calls to our custom code. To enable this, frameworks use abstractions with additional behavior built in. If we want to add our own behavior, we need to extend the classes of the framework or plugin our own classes.</br>
</p>
<p align="justify">
= The advantages of this architecture are:</br>
  - decoupling the execution of a task from its implementation</br>
  - making it easier to switch between different implementations</br>
  - greater modularity of a program</br>
  - greater ease in testing a program by isolating a component or mocking its dependencies and allowing components to communicate through contracts</br>
</p>
<p align="justify">
= Inversion of Control can be achieved through various mechanisms such as: Strategy design pattern, Service Locator pattern, Factory pattern, and Dependency Injection (DI).</br>
</p>

<p align="justify">
<b>What Is Dependency Injection?</b></br>
<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring</a></br>
Dependency injection is a pattern through which to implement IoC, where the control being inverted is the setting of object's dependencies.</br>
The act of connecting objects with other objects, or “injecting” objects into other objects, is done by an assembler rather than by the objects themselves.</br>
</p>

<p align="justify">
<b>Describe Asynchronous and Reactive approaches</b></br>
<a href="https://dzone.com/articles/5-things-to-know-about-reactive-programming">https://dzone.com/articles/5-things-to-know-about-reactive-programming</a></br>
= Asynchronous</br>
You organize you code in some way, when code for processing results of some actions works in separate (non-main) thread.</br>
</p>
<p align="justify">
= Reactive</br>
When using reactive programming, data streams are going to be the spine of your application. Events, messages, calls, and even failures are going to be conveyed by a data stream. With reactive programming, you observe these streams and react when a value is emitted.</br>
So, in your code, _you are going to create data streams of anything and from anything_: click events, HTTP requests, ingested messages, availability notifications, changes on a variable, cache events, measures from a sensor, literally anything that may change or happen. </br>
RX Java (for example) is an implementation of the reactive programming principles to “compose asynchronous and event-based programs by using observable sequence”. With RX, your code creates and subscribes to data streams named Observables. While Reactive Programming is about the concepts, RX provides you an amazing toolbox. By combining the observer and iterator patterns and functional idioms, RX gives you superpowers. You have an arsenal of functions to combine, merge, filter, transform and create the data streams.</br>
</p>
<p align="justify">
<b>Разница между Serializable и Externalizable</b></br>
<a href="https://javarush.ru/groups/posts/2023-znakomstvo-s-interfeysom-externalizable">https://javarush.ru/groups/posts/2023-znakomstvo-s-interfeysom-externalizable</a></br>
= В случае использования Serializable, все что можем сделать для управления процессом сериализации - это использовать ключевое слово transient, идентификатор версии и в общем-то все. Весь остальной процесс "зашит" в Java и к нему доступа нет</br>
Также производительность Serializable оставляет желать лучшего, т.к.:</br>
	- во время работы генерирует большой объем служебной информации и разного рода временных данных.</br>
	- основано на Reflection API (а это не быстро)</br>
Недостаточная гибкость</br>
Проблемы с безопасностью (не все поля возможно стоит раскрывать для "чужих ушей/глаз")</br>
</p>
<p align="justify">
= В случае использования Externalizable мы должны описать имплементацию методов writeExternal, readExternal. В итоге вся ответственность за сериализацию и десериализацию будет лежать на программисте.</br>
В итоге решается проблема отсутствия контроля над этим процессом, получаем определенную гибкость, решаем проблемы с безопасностью.</br>
Поскольку отсутствуем использование Reflection, скорость также должна увеличиться.</br>
Пример:</br>
{</br>
   ...</br>
   @Override</br>
   public void writeExternal(ObjectOutput out) throws IOException {</br>
       out.writeObject(this.getFirstName());</br>
       out.writeObject(this.getLastName());</br>
       out.writeObject(this.encryptString(this.getSuperSecretInformation()));</br>
   }</br>
</p>
<p align="justify">
   @Override</br>
   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {</br>
       firstName = (String) in.readObject();</br>
       lastName = (String) in.readObject();</br>
       superSecretInformation = this.decryptString((String) in.readObject());</br>
   }</br>
</p>
<p align="justify">
   private String encryptString(String data) {</br>
       String encryptedData = Base64.getEncoder().encodeToString(data.getBytes());</br>
       System.out.println(encryptedData);</br>
       return encryptedData;</br>
   }</br>
</p>
<p align="justify">
   private String decryptString(String data) {</br>
       String decrypted = new String(Base64.getDecoder().decode(data));</br>
       System.out.println(decrypted);</br>
       return decrypted;</br>
   }</br>
}</br>
</p>
<p align="justify">
= Еще нюанс:</br>
При использовании Serializable под объект просто выделяется память, после чего из потока считываются значения, которыми заполняются все его поля. Т.е. конструктор объекта не вызывается! Вся работа производится через рефлексию.</br>
В случае с Externalizable механизм десериализации будет иным. В начале вызывается конструктор по умолчанию. И только потом у созданного объекта вызывается метод readExternal(), который и отвечает за заполнение полей объекта.</br>
Именно поэтому любой класс, имплементирующий интерфейс Externalizable, обязан иметь конструктор по умолчанию.</br>
</p>
<p align="justify">
= When Hibernate is not good choice?</br>
When long time to app start - isn't appropriate</br>
</p>
<p align="justify">
= Spring @PreDestroy - is it running when performs System.exit() in some part of code?</br>
It will be runned because shutdown hook used for that</br>
</p>
<p align="justify">
= queue broker - забрали месседж из очереди и при процессинге упали. надо репроцессинг - как действовать?</br>
Use acknowledge mechanism for that</br>
</p>
<p align="justify">
= How to make undo/rollback in Flyway</br>
Use file with name 'u' (undo)</br>
</p>
<p align="justify">
= How to apply some script during each migration in Flyway</br>
Use file with name 'r' (repeatable)</br>
</p>
<p align="justify">
= вывести все значения, которые есть в колонке одной таблицы (T1.col1) и отсутствуют в колонке другой таблицы (T2.col2)</br>
Select t2.col1 from T1 t1 left join T2 t2 on t2.col2 == null;</br>
</p>
<p align="justify">
<b>Вызов транзакц. метода из не транзакц. метода - будет ли начата транзакция?</b></br>
Нет, т.к. при вызове должна пересекаться граница прокси-объекта</br>
</p>
<p align="justify">
<b>Как работает магия Spring Boot?</b></br>
...</br>
</p>
<p align="justify">
<b>Зачем нужен файл spring.factories?</b></br>
Файл spring.factories нужен, чтобы избежать сканирования пакетов для нахождения классов автоконфигурации (с аннотациями).</br>
Его нужно поместить в папку META-INF получающегося jar-файла. В нем надо указать наши AutoConfiguration-классы:</br>
# Auto Configure</br>
Org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</br>
Org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</br>
Org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration</br>
</p>
<p align="justify">
<b>Как сделать стрим из листа/массива?</b></br>
Из листа: list.stream()</br>
Из массива: Arrays.stream(array) или Stream.of(array)</br>
</p>
<p align="justify">
<b>Зачем peek в стриме, ленивый ли он?</b></br>
Stream peek(Consumer action) returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation i.e, it creates a new stream that, when traversed, contains the elements of the initial stream that match the given predicate.</br>
В итоге ответ: при вызове peek, без терминальной операции - ничего не происходит</br>
</p>
<p align="justify">
<b>Richardson maturity model</b></br>
<a href="https://restfulapi.net/richardson-maturity-model/">https://restfulapi.net/richardson-maturity-model/</a></br>
Leonard Richardson analyzed a hundred different web service designs and divided them into four categories based on how much they are REST compliant. This model of division of REST services to identify their maturity level – is called Richardson Maturity Model.</br>
Richardson used three factors to decide the maturity of a service i.e. URI, HTTP Methods and HATEOAS (Hypermedia). The more a service employs these technologies – more mature it shall be considered.</br>
</p>
<p align="justify">
= Level Zero of maturity does not make use of any of URI, HTTP Methods, and HATEOAS capabilities.</br>
These services have a single URI and use a single HTTP method (typically POST). For example, most Web Services (WS-*)-based services use a single URI to identify an endpoint, and HTTP POST to transfer SOAP-based payloads, effectively ignoring the rest of the HTTP verbs.</br>
Similarly, XML-RPC based services send data as Plain Old XML (POX). These are the most primitive way of building SOA applications with a single POST method and using XML to communicate between services.</br>
</p>
<p align="justify">
= Level One of maturity makes use of URIs out of URI, HTTP Methods, and HATEOAS.</br>
These services employ many URIs but only a single HTTP verb – generally HTTP POST. They give each resource in their universe a URI. A unique URI separately identifies one unique resource – and that makes them better than level zero.</br>
</p>
<p align="justify">
= Level Two maturity makes use of URIs and HTTP out of URI, HTTP Methods, and HATEOAS.</br>
Level two services host numerous URI-addressable resources. Such services support several of the HTTP verbs on each exposed resource – Create, Read, Update and Delete (CRUD) services. Here the state of resources, typically representing business entities, can be manipulated over the network.</br>
Here service designer expects people to put some effort into mastering the APIs – generally by reading the supplied documentation.</br>
Level two is the excellent use-case of REST principles, which advocate using different verbs based on the HTTP request methods, and the system can have multiple resources.</br>
</p>
<p align="justify">
= Level Three of maturity makes use of all three, i.e. URIs and HTTP and HATEOAS.</br>
This level is the most mature level of Richardson’s model, which encourages easy discoverability. This level makes it easy for the responses to be self-explanatory by using HATEOAS.</br>
The service leads consumers through a trail of resources, causing application state transitions as a result.</br>
</p>
<p align="justify">
<b>What is the difference between import and static import ?</b></br>
The import allows the java programmer to access classes of a package without package qualification whereas the static import feature allows to access the static members of a class without the class qualification.</br>
</p>
<p align="justify">
<b>Имеется таблица User(id, age, sex). Необходимо посчитать сколько записей у которых age>20, и сколько записей у которых sex="M"</b></br>
Select count(u.id) from User u where u.age>20 union select count(u.id) from User u where u.sex='M';</br>
Select count(u.age>20), count(u.sex='M') from User u; (в PostgreSQL такое работает)</br>
</p>
<p align="justify">
<b>Xss*N+Xmx - весь ли это объем памяти, занимаемый JVM?</b></br>
Нет, поскольку есть т.н. off heap (память, выделяемая нативными тулами)</br>
</p>
<p align="justify">
<b>В чем отличие Spring MVC от Spring REST ?</b></br>
В Spring MVC в методах контроллера возвращаем имя view темплейта, который надо отобразить,</br>
В Spring REST - методы контроллера матчатся на URI, для реализации CRUD-операций в отношении ресурсов</br>
</p>
<p align="justify">
<b>How to create array/list populated with int values?</b></br>
Int[] data = new int[] {0, 1, 3};</br>
List<Integer> list = Arrays.asList(0, 1, 3);</br>
</p>
<p align="justify">
<b>List<->array conversions</b></br>
List->Array: list.toArray(new String[0])</br>
Array->List: Arrays.asList(arr) or for type-safe: Arrays.<String>asList(arr)</br>
</p>
<p align="justify">
<b>Describe levels of transactions isolation in DB</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9</a></br>
= Проблемы:</br>
== Потерянное обновление - при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется.</br>
== «Грязное» чтение - чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).</br>
== Неповторяющееся чтение - при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.</br>
== Чтение «фантомов» - при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.  От неповторяющегося чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.</br>
</p>
<p align="justify">
= Уровни изоляции</br>
== Read uncommitted - «грязное» чтение, неповторяющееся чтение, фантомы</br>
== Read commited - неповторяющееся чтение, фантомы</br>
== Repeatable read - фантомы</br>
== Serializable - все ок</br>
</p>
<p align="justify">
<b>Docker: describe namespaces / cgroups</b></br>
<a href="https://stackoverflow.com/questions/34820558/difference-between-cgroups-and-namespaces">https://stackoverflow.com/questions/34820558/difference-between-cgroups-and-namespaces</a></br>
Under the hood, Docker is built on the following components: the cgroups and namespaces capabilities of the Linux kernel</br>
In long:</br>
    = cgroup: Control Groups provide a mechanism for aggregating/partitioning sets of tasks, and all their future children, into hierarchical groups with specialized behaviour. It determines how much host machine resources to be given to containers.</br>
	Cgroups involve resource metering and limiting:</br>
		memory</br>
		CPU</br>
		block I/O</br>
		network</br>
    = namespace: wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource. Namespaces provide processes with their own view of the system. </br>
	Multiple namespaces:</br>
		pid - process id isolation</br>
		net - takes care of different ip allocation to different containers</br>
		mnt - for file system</br>
		uts (unique time sharing) - which checks for different hostnames of running containers</br>
		ipc - interprocess communication</br>
		user - different username (uid)</br>
</p>
<p align="justify">
In short:</br>
    = Cgroups - limits how much you can use;</br>
    = namespaces - limits what you can see (and therefore use)</br>
</p>
<p align="justify">
<b>Как БД восстанавливается после сбоя (рассказать о "write-ahead log")</b></br>
<a href="https://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B0%D1%8F_%D0%B6%D1%83%D1%80%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">https://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B0%D1%8F_%D0%B6%D1%83%D1%80%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F</a></br>
Упреждающая журнализация — техника для обеспечения атомарности и устойчивости БД — двух ключевых ACID-свойств — посредством ведения журнала упреждающей записи (англ. write-ahead log), в который информация об изменениях в БД вносится и фиксируется перед записью в БД.</br>
В журнал могут вноситься записи как для осуществления повтора операции (redo), так и отмены (undo), могут вестись оба вида записей. В случае неожиданного перезапуска системы управления БД (например, из-за сбоя по питанию), журналирование позволяет установить, не была ли прервана какая-либо операция, и основываясь на этом завершить операцию, или произвести необходимые действия по отмене частичных изменений. </br>
</p>
<p align="justify">
<b>Вызов @Transactional метода из другого (не @Transactional) метода этого класса - будет ли транзакция?</b></br>
Нет, не будет. при вызове должна пересекаться граница прокси-объекта</br>
</p>
<p align="justify">
<b>Если есть поле GUID - какой тип индекса в БД лучше использовать для него?</b></br>
При помещении новой записи - в случае B-tree будет часто происходить перестроение дерева, поэтому вроде как лучше hashtable</br>
</p>
<p align="justify">
<b>Как реализовать версионирование соап сервисов?</b></br>
...</br>
</p>
<p align="justify">
<b>Метод содержащий вызов repository.findByOne() - можно ли с него убрать @Transactional?</b></br>
Нет, надо оставить @Transactional с readOnly=true. Это позволит не конфликтовать операциям чтения между собой, а лок защитит при операции записи от вычитывания частично модифицированного ентити.</br>
</p>
<p align="justify">
<b>How to realize optimistic blocking via JDBC (and the same question, but without usage of DB record versions)</b></br>
<a href="https://stackoverflow.com/questions/8691684/how-to-code-optimistic-and-pessimistic-locking-from-java-code">https://stackoverflow.com/questions/8691684/how-to-code-optimistic-and-pessimistic-locking-from-java-code</a></br>
= Use next steps:</br>
	1. Add integer "version" column to your table.</br>
	2. Increase the value of this column with each update of corresponding row.</br>
	3. To obtain lock, just read "version" value of the row.</br>
	4. Add "version = obtained_version" condition to where clause of your update statement. Verify number of affected rows after update. If no rows were affected - someone has already modified your entry.</br>
In result your update should look like: UPDATE mytable SET name='Andy',version=3 WHERE id=1 and version=2</br>
</p>
<p align="justify">
= How to make optimistic blocking without versions usage - still don't know :(</br>
</p>
<p align="justify">
<b>Задачка про турникет: есть таблица (id, timestamp), куда сохраняются проходы через турникет. написать запрос, чтобы посчитать, сколько людей </b></br>
Сейчас в здании (часть может быть на обеде). интервал рабочего времени - известный, фиксированный</br>
Select count(*) from T where DATE(`timestamp`) = CURDATE() group by id having count(id) mod 2 = 1;</br>
</p>
<p align="justify">
<b>Public/private/protection метод с @Transactional на нем - будет ли открываться транзакция?</b></br>
<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations">https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations</a></br>
Из документации, пункт "Method visibility and @Transactional":</br>
When you use proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. If you need to annotate non-public methods, consider using AspectJ.</br>
Таким образом, если вы используете (по умолчанию) Spring Proxy AOP, то все функциональные возможности AOP, предоставляемые Spring (например @Transational), будут приниматься во внимание, только если вызов проходит через прокси. Обычно это так, если аннотированный метод вызывается из другого компонента.</br>
Способы заставить работать непубличные методы - использовать режим AspectJ вместо Spring Proxies.</br>
Также можно выполнить self injection компонента и вызывать метод на нем.</br>
</p>
<p align="justify">
<b>Использование Spring Boot admin для мониторинга сервисов</b></br>
<a href="https://www.baeldung.com/spring-boot-admin">https://www.baeldung.com/spring-boot-admin</a></br>
<a href="https://habr.com/ru/post/479954/">https://habr.com/ru/post/479954/</a></br>
Spring Boot Admin предлагает удобную и полезную прослойку пользовательского интерфейса поверх конечных точек Actuator. Более того, он позволяет централизованно контролировать несколько приложений с несколькими экземплярами, что неоценимо при работе в облаке и с микросервисами. </br>
</p>
<p align="justify">
<b>Что плохого в том, чтобы вешать @Transactional на контроллер? аналогичный вопрос - насколько высоко или низко по иерархии вызовов надо вешать @Transactional?</b></br>
<a href="https://stackoverflow.com/questions/1079114/where-does-the-transactional-annotation-belong">https://stackoverflow.com/questions/1079114/where-does-the-transactional-annotation-belong</a></br>
Надо вешать на уровне сервиса:</br>
I think transactions belong on the Service layer. It's the one that knows about units of work and use cases. It's the right answer if you have several DAOs injected into a Service that need to work together in a single transaction.</br>
Sometimes it does not matter, but sometimes you can benefit from that e.g. Hibernate session is spanned for the while transaction, so all loaded objects are in 1st-level cache and you don't need to reattach the objects to session again, plus lazily loaded properties function without fuzz.</br>
И хорошее замечание:</br>
However, in the mean time I also started adding @Transactional(propagation = Propagation.MANDATORY) to my DAO layer (and other layers that are not allowed to start transactions but require existing ones) because it is much easier to detect errors where you have forgotten to start a transaction in the caller (e.g. the service). If your DAO is annotated with mandatory propagation you will get an exception stating that there is no active transaction when the method is invoked.</br>
</p>
<p align="justify">
<b>Как посмотреть логи сервиса, запущенного в докер-контейнере?</b></br>
<a href="https://linux-notes.org/rabota-s-logami-logs-v-docker/">https://linux-notes.org/rabota-s-logami-logs-v-docker/</a></br>
Docker logs <имя контейнера> # Если при старте дали контейнеру имя</br>
Docker logs $(docker ps -aql) #a - Show all containers (default shows just running), q - Only display container IDs, l - Show the latest created container</br>
</p>
<p align="justify">
<b>Рассказать подробно, как работает https запрос (вопрос возник из другого - почему для секьюрности надо использовать POST, а не GET?)</b></br>
= https://firstssl.ru/faq/general-questions/chto-takoe-https</br>
HTTPS — протокол безопасной передачи данных, поддерживает технологию шифрования TLS/SSL.</br>
Стандартный протокол HTTP передаёт данные в открытом виде. Злоумышленники могут "вклиниться" в передачу — изменить или перехватить данные. В HTTPS для передачи данных создаётся защищённый канал. Вот как это происходит:</br>
Вася хочет перейти на сайт FirstSSL, защищённый SSL-сертификатом</br>
<b>Васин браузер посылает запрос к сайту</b></br>
<b>Сайт отправляет в ответ копию сертификата</b></br>
<b>Браузер проверяет подлинность сертификата — узнаёт у центра сертификации, который его выдал</b></br>
<b>Если сертификат не поддельный, сайт и браузер тайно (как - см. ниже) договариваются о секретном симметричном ключе</b></br>
С помощью этого ключа Васин браузер и сайт устанавливают защищённое HTTPS-соединение. Ключ шифрует данные – мошенники не могут получить доступ к паролям и номерам кредитных карт пользователей.</br>
Для каждого соединения с сайтом создается новый секретный ключ. Его нельзя перехватить – сайт и браузер договариваются о ключе тайно. И невозможно подобрать – обычно это набор из 100 и более букв и цифр.</br>
</p>
<p align="justify">
= Как сайт и браузер договариваются о секретном симметричном ключе:</br>
<a href="https://firstssl.ru/faq/general-questions/kluch-shifrovania">https://firstssl.ru/faq/general-questions/kluch-shifrovania</a></br>
Протокол SSL использует асимметричное шифрование или шифрование с открытым ключом для установки соединения. Несмотря на название, здесь используются 2 ключа: открытый и закрытый. Оба формируются при запросе SSL-сертификата.</br>
Открытый (публичный ключ) доступен всем. Используется для шифрования данных при обращении браузера к серверу.</br>
Закрытый (секретный ключ) известен только владельцу сайта. Используется для расшифровки данных, отправленных браузером.</br>
Шифрование с двумя ключами разного типа гарантирует сохранность информации. Даже если мошенник перехватит трафик, не сможет расшифровать его без закрытого ключа.</br>
Однако асимметричный алгоритм ресурсоемок, а скорость шифрования на 2-3 порядка ниже симметричного алгоритма. Поэтому в SSL-технологии шифрование с открытым ключом используется только для согласования секретного симметричного ключа. С его помощью устанавливается защищённое HTTPS-соединение – данные передаются быстро и безопасно.</br>
Сразу использовать симметричное шифрование ненадежно. В этом алгоритме один и тот же ключ шифрует и расшифровывает информацию. Посетитель сайта и владелец сервера должны договориться о нем без свидетелей.</br>
Передать по почте, телефону или смской не получится – перехватят или подслушают.</br>
Значит, нужно отправить симметричный ключ в зашифрованном сообщении. Но сначала убедиться, что его получит правильный адресат.</br>
    Чтобы аутентифицировать сервер, браузер посетителя проверяет, подписан ли SSL-сертификат сертификатом доверенного центра.</br>
    Чтобы договориться о симметричном ключе шифрования сервер и браузер используют асимметричное шифрование с открытым ключом.</br>
</p>
<p align="justify">
= Рассмотрим этот процесс на примере реальных ключей:</br>
<b>Боб (сервер) отправляет Алисе (браузеру) замок, ключ от которого есть только у него. Замок здесь – публичный ключ.</b></br>
<b>Алиса закрывает замком Боба ящик с секретом и посылает обратно.</b></br>
Так же браузер шифрует сообщение с помощью публичного ключа и передаёт на сервер.</br>
Открыть ящик не сможет никто: ни сама Алиса, ни сотрудники почты. Мошенник точно так же не может расшифровать сообщение браузера без закрытого ключа.</br>
<b>Боб получает ящик, открывает своим единственным ключом и узнаёт секрет.</b></br>
Сервер расшифровывает сообщение закрытым ключом, который есть только у него.</br>
Как Алиса и Боб ведут тайную переписку, так браузер и сервер устанавливают защищённое HTTPS-соединение и обмениваются данными.</br>
</p>
<p align="justify">
<b>DAU, WAU, MAU метрики</b></br>
<a href="https://gravitec.net/ru/blog/mau-dau-arpu-ili-metriki-poseshhaemosti-kotory-e-nado-znat/">https://gravitec.net/ru/blog/mau-dau-arpu-ili-metriki-poseshhaemosti-kotory-e-nado-znat/</a></br>
DAU (Daily Active Users) - ежедневные активные пользователи. Метрика демонстрирует, сколько пользователей зашло в приложение за день.</br>
WAU (Weekly Active Users) – еженедельные активные пользователи.</br>
MAU (Monthly Active Users) - уникальные пользователи, которые посещают приложение хотя бы раз в месяц. Уникальность пользователей определяется по ID или логину.</br>
Чтобы получить коэффициент вовлеченности пользователя за неделю, нужно разделить «ежедневный» показатель на «еженедельный» (DAU/WAU).</br>
Если нужно знать коэффициент «прилипаемости» пользователей к сервису в месяц, сопоставляем «ежедневный» и «ежемесячный» результаты (DAU/MAU).</br>
</p>
<p align="justify">
<b>CSI метрика</b></br>
CSI (customer satisfaction index) - индекс удовлетворенности клиентов. Оценка удовлетворенности производится за четыре шага: </br>
<a href="http://www.marketch.ru/marketing_dictionary/marketing_terms_i/customer-satisfaction-index/">http://www.marketch.ru/marketing_dictionary/marketing_terms_i/customer-satisfaction-index/</a></br>
1. произвольно и экспертно определяются параметры, которые компания считает важными. Для определения показателей можно воспользоваться экспертным мнением, результатами предварительного опроса активной части ЦА. Чаще всего оценивают отношение покупателей к следующим параметрам маркетинга:</br>
    = к товару или услуге (качеством продукта, упаковки, удобства покупки и пользования); </br>
    = клиентскому сервису (скорость обслуживания, компетентность, дружелюбие и проч.); </br>
    = к качеству и количеству информационно-маркетингового воздействия;</br>
    = соответствие цен с потребительским ожиданием и сравнение цен с ценами конкурентов.</br>
2. в результате опроса потребителей, выявляется их отношение к этим параметрам по пятибалльной шкале: один балл означает неудовлетворенность, пять — удовлетворенность. </br>
3. выяснение у покупателей, насколько важен для них тот или иной параметр из экспертного списка  — также по пятибалльной шкале.  </br>
4. необходимо провести анализ полученных ответов потребителей о их удовлетовренности. </br>
</p>
<p align="justify">
<b>KVM</b></br>
KVM (Kernel-based Virtual Machine) - программное решение, обеспечивающее виртуализацию в среде Linux на платформе x86, которая поддерживает аппаратную виртуализацию на базе Intel VT (Virtualization Technology) либо AMD SVM (Secure Virtual Machine). </br>
</p>
<p align="justify">
<b>LXC</b></br>
LXC (Linux Containers) — система виртуализации на уровне ОС для запуска нескольких изолированных экземпляров ОС Linux на одном узле. LXC не использует виртуальные машины, а создаёт виртуальное окружение с собственным пространством процессов и сетевым стеком. Все экземпляры LXC используют один экземпляр ядра операционной системы.</br>
<a href="https://stackoverflow.com/questions/20578039/difference-between-kvm-and-lxc">https://stackoverflow.com/questions/20578039/difference-between-kvm-and-lxc</a></br>
The main difference between the KVM virtualization and Linux Containers is that virtual machines require a separate kernel instance to run on, while containers can be deployed from the host operating system. This significantly reduces the complexity of container creation and maintenance. Also, the reduced overhead lets you create a large number of containers with faster startup and shutdown speeds.</br>
</p>
<p align="justify">
<b>Kotlin coroutines</b></br>
Coroutines - lightweight threads</br>
</p>
<p align="justify">
<b>Как потерять объект в хэшмапе? что делать чтобы такого не было?</b></br>
Это случится, если использовать не-immutable ключи. Чтобы предотвратить это - надо использовать immutable ключи.</br>
</p>
<p align="justify">
<b>Каков размер ссылки в JVM в 32/64-битных системах?</b></br>
<a href="https://habr.com/ru/post/440166/">https://habr.com/ru/post/440166/</a></br>
Сжатие указателей в JVM 64-bit, контролируется опцией UseCompressedOops и включено по-умолчанию для 64-битных систем начиная с Java SE 6u23.</br>
Так что в итоге ответ - 32 бита</br>
</p>
<p align="justify">
<b>@EntityGraph в JPA</b></br>
<a href="https://sysout.ru/entity-graph-v-spring-data-jpa/">https://sysout.ru/entity-graph-v-spring-data-jpa/</a></br>
<a href="https://habr.com/ru/post/444240/">https://habr.com/ru/post/444240/</a></br>
С помощью Entity Graph можно задать для каждого запроса свою стратегию загрузки данных: LAZY либо EAGER.</br>
(всё, что указано в  attributeNodes будет загружаться EAGER)</br>
В репозиторий-классе можно как сослаться на граф, прописанный в аннотации @NamedEntityGraph, так и создать свой на ходу.</br>
</p>
<p align="justify">
<b>Cglib-proxy vs dynamic-proxy</b></br>
<a href="https://coderoad.ru/10664182/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%BC-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%BC-JDK-%D0%B8-CGLib">https://coderoad.ru/10664182/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%BC-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%BC-JDK-%D0%B8-CGLib</a></br>
= Динамический прокси-сервер JDK может работать только через интерфейс (поэтому ваш целевой класс должен реализовать интерфейс, который затем также реализуется прокси-классом).</br>
= CGLIB (и javassist) могут создать прокси-сервер путем подклассов. В этом случае прокси-сервер становится подклассом целевого класса. Нет необходимости в интерфейсах.</br>
</p>
<p align="justify">
<b>Full-text index in DB for queries with "like '%text%'"</b></br>
<a href="https://www.mssqltips.com/sqlservertutorial/9136/sql-server-full-text-indexes/">https://www.mssqltips.com/sqlservertutorial/9136/sql-server-full-text-indexes/</a></br>
A full-text index is a special type of index that provides index access for full-text queries against character or binary column data. A full-text index breaks the column into tokens and these tokens make up the index data. Before you can create a full-text index you must create a FULL TEXT CATALOG and this catalog is where the full-text index data is stored. A full-text catalog can contain many indexes but a full-text index can only be part of one catalog. Also, only one full-text index can be created on each table so if you have more than one column you need to be indexed the columns have to be moved to separate tables. It is also important to note that full-text indexes are not updated right away as is the case with regular indexes. Populating full-text indexes can be resource intensive so there are more options that let you control when they are updated.</br>
</p>
<p align="justify">
<b>Describe date/time types in Java 8</b></br>
<a href="https://www.baeldung.com/java-8-date-time-intro">https://www.baeldung.com/java-8-date-time-intro</a></br>
= LocalDate represents a date in ISO format (yyyy-MM-dd) without time.</br>
= LocalTime represents time without a date.</br>
= LocalDateTime is used to represent a combination of date and time.</br>
= ZonedDateTime used when we need to deal with time zone specific date and time.</br>
= ZoneId is an identifier used to represent different zones. There are about 40 different time zones and the ZoneId are used to represent them as follows.</br>
= OffsetDateTime is an immutable representation of a date-time with an offset. This class stores all date and time fields, to a precision of nanoseconds, as well as the offset from UTC/Greenwich.</br>
= Period represents a quantity of time in terms of years, months and days.</br>
= Duration class represents a quantity of time in terms of seconds and nano seconds.</br>
= DateTimeFormatter provides various standard formatting options.</br>
<a href="https://www.baeldung.com/java-clock">https://www.baeldung.com/java-clock</a></br>
= Clock provides access to an instant in time using the best available system clock, and to be used as a time provider which can be effectively stubbed for testing purposes.</br>
</p>
<p align="justify">
<b>Как реализовать параллельное вычитывание месседжей из брокера?</b></br>
<a href="https://habr.com/ru/post/466585/">https://habr.com/ru/post/466585/</a></br>
(в Кафка) Партиции являются основным механизмом распараллеливания чтения и масштабирования топика за пределы пропускной способности одного экземпляра брокера.</br>
В то время, как в JMS мы используем структуру сообщения с метаданными (заголовками и свойствами) и телом, содержащим полезную нагрузку (payload), в Kafka сообщение является парой «ключ-значение». Полезная нагрузка сообщения отправляется как значение (value). Ключ, с другой стороны, используется главным образом для партиционирования и должен содержать специфичный для бизнес-логики ключ, чтобы поместить связанные сообщения в ту же партицию.</br>
</p>
<p align="justify">
<b>Как несколько раз обработать одно и то же сообщение в очереди?</b></br>
<a href="https://habr.com/ru/post/466585/">https://habr.com/ru/post/466585/</a></br>
Прочитанные сообщения все равно не удаляются, в отличие от обычного брокера, и клиент может перемотать (rewind) смещение, чтобы повторно обработать уже просмотренные сообщения.</br>
</p>
<p align="justify">
<b>Одно- и двунаправленные ссылки в JPA ентитях. владелец связи в JPA</b></br>
<a href="https://coderoad.ru/11938253/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-JoinColumn-%D0%B8-mappedBy-%D0%BF%D1%80%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%B0%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%86%D0%B8%D0%B8-JPA">https://coderoad.ru/11938253/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-JoinColumn-%D0%B8-mappedBy-%D0%BF%D1%80%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%B0%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%86%D0%B8%D0%B8-JPA</a></br>
Простые правила двунаправленных отношений:</br>
= For many-to-one - двунаправленные отношения, сторона многих всегда является стороной владения отношениями. Пример: 1 комната имеет много человек (человек принадлежит только одной комнате) -> владеющая сторона-это человек</br>
= For one-to-one - двунаправленные отношения, сторона-владелец соответствует стороне, содержащей соответствующий внешний ключ.</br>
= For many-to-many - двунаправленные отношения, любая сторона может быть стороной-владельцем. </br>
</p>
<p align="justify">
<b>Describe assertions in Java</b></br>
<a href="https://www.baeldung.com/java-assert">https://www.baeldung.com/java-assert</a></br>
= Using assertions we can remove the 'if' and 'throw' statement with a single assert statement.</br>
JVM disables assertion validation by default. They must be explicitly enabled using either the -enableassertions command line argument, or its shorthand -ea:</br>
	java -ea com.baeldung.assertion.Assertion</br>
We can also enable assertions for specific packages and classes:</br>
	java -ea:com.baeldung.assertion... com.baeldung.assertion.Assertion</br>
Here, we've enabled assertions for all the classes in the com.baeldung.assertion package.</br>
Likewise, they can be disabled for specific packages and classes using the -disableassertions command line argument, or its shorthand -da. We can also use all four of these arguments together.</br>
</p>
<p align="justify">
= JVM will automatically throw an AssertionError. The class AssertionError extends Error, which itself extends Throwable. This means that AssertionError is an unchecked exception.</br>
Therefore methods that use assertions are not required to declare them, and further calling code should not try and catch them.</br>
AssertionErrors are meant to indicate unrecoverable conditions in an application, so never try to handle them or attempt recovery.</br>
</p>
<p align="justify">
= Just remember that assertions aren't enabled by default, so never assume they will be executed when used in the code.</br>
</p>
<p align="justify">
<b>Service mesh</b></br>
<a href="https://habr.com/ru/company/flant/blog/478306/">https://habr.com/ru/company/flant/blog/478306/</a></br>
Service mesh - это всего лишь куча userspace-прокси, расположенных «рядом» с сервисами, плюс набор управляющих процессов. Прокси в совокупности получили название data plane, а управляющие процессы именуются control plane. Data plane перехватывает вызовы между сервисами и делает с ними «всякое-разное»; control plane, соответственно, координирует поведение прокси и обеспечивает доступ для вас, т.е. оператора, к API, позволяя манипулировать сетью и изменять её как единое целое.</br>
</p>
<p align="justify">
<b>Рекурсивный вызов в JPA - как с ним бороться? Например у классов ентитей А и В есть взаимные ссылки друг на друга.</b></br>
В случае если это в toString() или сериализации в json - исключить из toString, или при помощи соответствующей аннотации в json.</br>
Также при необходимости некоторые сущности можно загружать как lazy, управляя этим при помощи FetchType/FetchMode</br>
</p>
<p align="justify">
<b>Рассказать об алгоритмах сборки мусора; что точно не надо собирать?</b></br>
</p>
<p align="justify">
<b>Какие есть gc? какой бы выбрал?</b></br>
<a href="https://www.baeldung.com/jvm-garbage-collectors">https://www.baeldung.com/jvm-garbage-collectors</a></br>
= Serial Garbage Collector</br>
This is the simplest GC implementation, as it basically works with a single thread. As a result, this GC implementation freezes all application threads when it runs. Hence, it is not a good idea to use it in multi-threaded applications like server environments.</br>
The Serial GC is the garbage collector of choice for most applications that do not have small pause time requirements and run on client-style machines. To enable Serial Garbage Collector, we can use the following argument: java -XX:+UseSerialGC -jar Application.java</br>
</p>
<p align="justify">
= Parallel Garbage Collector</br>
It's the default GC of the JVM and sometimes called Throughput Collectors. Unlike Serial Garbage Collector, this uses multiple threads for managing heap space. But it also freezes other application threads while performing GC.</br>
If we use this GC, we can specify maximum garbage collection threads and pause time, throughput, and footprint (heap size).</br>
The numbers of garbage collector threads can be controlled with the command-line option -XX:ParallelGCThreads=<N>.</br>
The maximum pause time goal (gap [in milliseconds] between two GC)is specified with the command-line option -XX:MaxGCPauseMillis=<N>.</br>
The maximum throughput target (measured regarding the time spent doing garbage collection versus the time spent outside of garbage collection) is specified by the command-line option -XX:GCTimeRatio=<N>.</br>
The maximum heap footprint (the amount of heap memory that a program requires while running) is specified using the option -Xmx<N>.</br>
To enable Parallel Garbage Collector, we can use the following argument: java -XX:+UseParallelGC -jar Application.java</br>
</p>
<p align="justify">
= CMS Garbage Collector</br>
The Concurrent Mark Sweep (CMS) implementation uses multiple garbage collector threads for garbage collection. It's designed for applications that prefer shorter garbage collection pauses, and that can afford to share processor resources with the garbage collector while the application is running.</br>
Simply put, applications using this type of GC respond slower on average but do not stop responding to perform garbage collection.</br>
A quick point to note here is that since this GC is concurrent, an invocation of explicit garbage collection such as using System.gc() while the concurrent process is working, will result in Concurrent Mode Failure / Interruption.</br>
If more than 98% of the total time is spent in CMS garbage collection and less than 2% of the heap is recovered, then an OutOfMemoryError is thrown by the CMS collector. If necessary, this feature can be disabled by adding the option -XX:-UseGCOverheadLimit to the command line.</br>
This collector also has a mode knows as an incremental mode which is being deprecated in Java SE 8 and may be removed in a future major release.</br>
To enable the CMS Garbage Collector, we can use the following flag: java -XX:+UseParNewGC -jar Application.java</br>
As of Java 9, the CMS garbage collector has been deprecated.</br>
Moreover, Java 14 completely dropped the CMS support.</br>
</p>
<p align="justify">
= G1 Garbage Collector</br>
G1 (Garbage First) Garbage Collector is designed for applications running on multi-processor machines with large memory space. It's available since JDK7u4.</br>
G1 collector will replace the CMS collector since it's more performance efficient.</br>
Unlike other collectors, G1 collector partitions the heap into a set of equal-sized heap regions, each a contiguous range of virtual memory. When performing garbage collections, G1 shows a concurrent global marking phase (i.e. phase 1 known as Marking) to determine the liveness of objects throughout the heap.</br>
After the mark phase is completed, G1 knows which regions are mostly empty. It collects in these areas first, which usually yields a significant amount of free space (i.e. phase 2 known as Sweeping). It is why this method of garbage collection is called Garbage-First.</br>
To enable the G1 Garbage Collector, we can use the following argument: java -XX:+UseG1GC -jar Application.java</br>
</p>
<p align="justify">
= ZGC</br>
<a href="https://wiki.openjdk.java.net/display/zgc/Main">https://wiki.openjdk.java.net/display/zgc/Main</a></br>
The Z Garbage Collector, also known as ZGC, is a scalable low latency garbage collector designed to meet the following goals:</br>
    Max pause times of a few milliseconds</br>
    Pause times do not increase with the heap or live-set size</br>
    Handle heaps ranging from a 8MB to 16TB in size</br>
At a glance, ZGC is:</br>
    Concurrent</br>
    Region-based</br>
    Compacting</br>
    NUMA-aware</br>
    Using colored pointers</br>
    Using load barriers</br>
At its core, ZGC is a concurrent garbage collector, meaning all heavy lifting work is done while Java threads continue to execute. This greatly limits the impact garbage collection will have on your application's response time.</br>
</p>
<p align="justify">
= Shenandoah</br>
</p>
<p align="justify">
= Какой бы GC выбрал - зависит от конкретной задачи</br>
</p>
<p align="justify">
<b>Есть ли транзакции в MongoDB?</b></br>
В июне 2018 года (в версии 4.0) добавлена поддержка транзакций, удовлетворяющих требованиям ACID</br>
</p>
<p align="justify">
<b>Транзакции в NoSQL базах данных</b></br>
<a href="https://ru.wikipedia.org/wiki/NoSQL">https://ru.wikipedia.org/wiki/NoSQL</a></br>
Традиционные СУБД ориентируются на требования ACID к транзакционной системе: атомарность (atomicity), согласованность (consistency), изолированность (isolation), надёжность (durability), тогда как в NoSQL вместо ACID может рассматриваться набор свойств BASE:</br>
= базовая доступность (basic availability) — каждый запрос гарантированно завершается (успешно или безуспешно).</br>
= гибкое состояние (soft state) — состояние системы может изменяться со временем, даже без ввода новых данных, для достижения согласования данных.</br>
= согласованность в конечном счёте (eventual consistency) — данные могут быть некоторое время рассогласованы, но приходят к согласованию через некоторое время.</br>
</p>
<p align="justify">
<b>Как при работе со стримами получить и значения и индексы эл-тов в коллекции?</b></br>
<a href="https://youtu.be/vxikpWnnnCU">https://youtu.be/vxikpWnnnCU</a></br>
IntStream.range(0, list.size()).mapToObj(idx -> new IndexedValue<>(idx, list.get(idx))), где IndexedValue - собственный тип с двумя полями</br>
</p>
<p align="justify">
<b>Рассказать о lazy-initialization exception</b></br>
</p>
<p align="justify">
<b>Partitioning vs sharding vs sectioning</b></br>
</p>
<p align="justify">
<b>Describe Jsonb in PostgreSQL</b></br>
<a href="https://scalegrid.io/blog/using-jsonb-in-postgresql-how-to-effectively-store-index-json-data-in-postgresql/#3">https://scalegrid.io/blog/using-jsonb-in-postgresql-how-to-effectively-store-index-json-data-in-postgresql/#3</a></br>
<a href="https://postgrespro.ru/docs/postgresql/9.6/datatype-json">https://postgrespro.ru/docs/postgresql/9.6/datatype-json</a></br>
</p>
<p align="justify">
<b>Postgres JSONB indexes</b></br>
<a href="https://dzone.com/articles/using-jsonb-in-postgresql-how-to-effectively-store">https://dzone.com/articles/using-jsonb-in-postgresql-how-to-effectively-store</a></br>
Support 3 types of indexes: GIN, BTREE and HASH</br>
</p>
<p align="justify">
= GIN supports two operator classes:</br>
    jsonb_ops (default) - ?, ?|, ?&, @>, @@, @? [Index each key and value in the JSONB element]</br>
    jsonb_pathops - @>, @@, @? [Index only the values in the JSONB element; index has reduced size]</br>
</p>
<p align="justify">
= B-tree indexes are the most common index type in relational databases. However, if you index an entire JSONB column with a B-tree index, the only useful operators are '=', '<', '>', '>=', '<='.</br>
</p>
<p align="justify">
= If you are only interested in the "=" operator, then Hash indexes become interesting. For example, consider the case when we are looking for a particular tag on a book. The element to be indexed can be a top level element or deeply nested.</br>
</p>

</div>

<!-- Optional JavaScript; choose one of the two! -->

<!-- Option 1: Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
        crossorigin="anonymous"></script>

<!-- Option 2: Separate Popper and Bootstrap JS -->
<!--
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.6.0/dist/umd/popper.min.js" integrity="sha384-KsvD1yqQ1/1+IA7gi3P0tyJcT3vR+NdBTt13hSJ2lnve8agRGXTTyNaBYmCR/Nwi" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.min.js" integrity="sha384-nsg8ua9HAw1y0W1btsyWgBklPnCUAFLuTMS2G72MMONqmOymq585AcH49TLBQObG" crossorigin="anonymous"></script>
-->
</body>
</html>
